<pre class='metadata'>
Title: Crank Component Specification
Shortname: crank-components
Level: 1
Status: LS
Date: 2026-02-11
URL: https://crank.js.org/spec
Editor: Brian Kim, bikeshaving, https://github.com/brainkim
Abstract: This document specifies the component model for [Crank.js](https://crank.js.org). It defines how the framework invokes components, manages their lifecycle, handles async rendering, propagates errors, reconciles element trees, and creates elements via JSX, tagged templates, and createElement. The core framework is renderer-agnostic; this specification describes the component model independently of any particular output target, with DOM-specific behavior noted where applicable.
Markup Shorthands: markdown yes
Boilerplate: copyright off
</pre>

<div class="copyright">
  Copyright © 2026 Brian Kim. Licensed under the <a href="https://opensource.org/licenses/MIT">MIT License</a>.
</div>

<pre class='link-defaults'>
</pre>

# Elements # {#elements}

An <dfn>element</dfn> is a lightweight object describing a node in the UI tree. Each [=element=] has a **tag** and **props**.

[=Elements=] are created by `createElement(tag, props, ...children)`, JSX (see [[#jsx]]), or tagged templates (see [[#template-tags]]). The framework uses the term "tag" where the [JSX specification](https://facebook.github.io/jsx/) uses "type."

The tag determines what the [=element=] represents:

- **Host elements**: the tag is a string (`"div"`, `"span"`) — the [=renderer=] creates a node in the host environment.
- **Component elements**: the tag is a function — the framework invokes it as a [=component=] (see [[#invocation]]).
- **Symbol elements**: the tag is a symbol — used for special [=components=] like Portal, Raw, Copy, and Text (see [[#special-components]]).

[=Elements=] are identified across versions and realms by an internal `$$typeof` symbol, following the [same pattern as React](https://overreacted.io/why-do-react-elements-have-typeof-property/) to protect against injection attacks.

The `children` prop contains child content passed between opening and closing tags. See [[#child-normalization]] for the normalization rules applied to children.

# Renderers # {#renderers}

A <dfn>renderer</dfn> is the entry point to the framework. It translates the abstract [=element=] tree into mutations on a host environment.

## render() ## {#renderer-render}

`render(children, root?, bridge?)` — renders an [=element=] tree into a root. The [=renderer=] caches per root; subsequent calls to `render` with the same root update in place. Returns `Promise<TResult> | TResult`.

## hydrate() ## {#renderer-hydrate}

`hydrate(children, root, bridge?)` — attaches to pre-existing content in the root rather than creating from scratch. Used for server-rendered HTML.

## Bridging ## {#bridging}

The `bridge` parameter connects [=renderers=] so that events, provisions, and errors propagate across [=renderer=] boundaries.

## Built-in Renderers ## {#built-in-renderers}

The framework ships two [=renderers=]:

- **DOM renderer** (`@b9g/crank/dom`) — renders into DOM Elements, creates DOM Nodes.
- **HTML renderer** (`@b9g/crank/html`) — renders to HTML strings for server-side rendering.

The core framework is [=renderer=]-agnostic: it manages [=component=] lifecycles, reconciles [=element=] trees, and tracks state independently of any output target. The [=renderer=] adapter interface is described in [[#render-adapter]].

# Component Invocation # {#invocation}

A <dfn>component</dfn> is a function. The framework calls it with:

- <strong><code>this</code></strong> bound to a [=component context=] object
- <strong>First argument</strong>: the current props object
- <strong>Second argument</strong>: the same [=component context=] object (for arrow functions and destructuring)

```
(this: Context, props: TProps, ctx: Context) =>
  Children | Promise<Children> | Iterator<Children> | AsyncIterator<Children>
```

The framework distinguishes [=component=] types by return value, not declaration syntax.

<table class="data">
  <thead>
    <tr><th>Type<th>Syntax<th>Returns<th>Stateful
  </thead>
  <tbody>
    <tr><td>Function<td><code>function C(props)</code><td><code>Children</code><td>No — re-called on every update.
    <tr><td>Generator<td><code>function *C(props)</code><td>[Iterator](https://tc39.es/ecma262/#sec-iterator-interface)<code>&lt;Children></code><td>Yes — lexical scope preserved across yields.
    <tr><td>Async function<td><code>async function C(props)</code><td>[Promise](https://tc39.es/ecma262/#sec-promise-objects)<code>&lt;Children></code><td>No — re-called on every update.
    <tr><td>Async generator<td><code>async function *C(props)</code><td>[AsyncIterator](https://tc39.es/ecma262/#sec-asynciterator-interface)<code>&lt;Children></code><td>Yes — lexical scope preserved across yields.
  </tbody>
</table>

## Function Components ## {#function-components}

The framework calls the function on every update. The return value is rendered as children. Function [=components=] never [=block=].

## Generator Components ## {#generator-components}

The framework calls the function once and stores the returned [iterator](https://tc39.es/ecma262/#sec-iterator-interface). On each subsequent update, the framework calls [`next(previousResult)`](https://tc39.es/ecma262/#sec-iteratorresult-interface) where `previousResult` is the rendered result of the previous yield.

The framework preserves the generator's lexical scope across yields by retaining the iterator for as long as the [=component=] element occupies the same position in the element tree.

Generator [=components=] [=block=] while their children render — `previousResult` is always a settled value, never a promise. The framework calls [`return()`](https://tc39.es/ecma262/#sec-iterator-interface) on unmount.

## Async Function Components ## {#async-function-components}

The framework calls the function on every update. The [=component=] [=blocks=] while its own async execution is pending, but does not [=block=] while its children render. See [[#enqueuing]] for queuing behavior.

## Async Generator Components ## {#async-generator-components}

The framework calls the function once and stores the returned [async iterator](https://tc39.es/ecma262/#sec-asynciterator-interface). Async generators operate in three modes:

: [`for...of`](https://tc39.es/ecma262/#sec-for-in-and-for-of-statements) mode (sync iterator)
:: The [=component=] [=blocks=] while children render, identical to sync generators. `yield` evaluates to the settled rendered result.

: [`for await...of`](https://tc39.es/ecma262/#sec-for-in-and-for-of-statements) mode (async iterator)
:: The framework enters a pull-based loop. The [=component=] resumes continuously — it does not [=block=] while children render. `yield` evaluates to a [`Promise`](https://tc39.es/ecma262/#sec-promise-objects) that resolves to the rendered result. The [=component=] suspends at the bottom of the loop until new props are available or `refresh()` is called. This mode enables racing patterns: multiple yields per update produce successive element trees that are raced via the [=chase|chasing=] algorithm ([[#chasing]]).

: No-loop mode (no iterator)
:: The [=component=] [=blocks=] while children render, identical to sync generators.

# Context # {#context}

The framework provides a <dfn>component context</dfn> object to each [=component=] instance.

## Properties ## {#context-properties}

<table class="data">
  <thead>
    <tr><th>Property<th>Type<th>Description
  </thead>
  <tbody>
    <tr><td><code>props</code><td><code>TProps</code> (readonly)<td>Current props of the associated element.
    <tr><td><code>isExecuting</code><td><code>boolean</code> (readonly)<td><code>true</code> during the synchronous call to the [=component=] function or <code>iterator.next()</code>. Set to <code>false</code> before children are diffed.
    <tr><td><code>isUnmounted</code><td><code>boolean</code> (readonly)<td><code>true</code> after the [=component=] has been unmounted.
  </tbody>
</table>

## Methods ## {#context-methods}

<dl>
  <dt>`refresh(callback?)`
  <dd>[=Enqueue|Enqueues=] a re-execution of the [=component=]. If a callback is provided, the framework runs it before re-executing. If called while `isExecuting` is `true`, the framework logs an error and returns the current value.

  <dt>`schedule(callback?)`
  <dd>Registers a callback that the framework calls after DOM nodes are created but before they are inserted into the document. The callback receives the [=element value=]. Callbacks are <strong>one-shot</strong>: they fire once and must be re-registered on subsequent renders. Multiple distinct callbacks may be registered; callbacks are deduplicated by function identity (registering the same function reference twice in one update fires it once). If the callback returns a promise on the [=component's=] initial render, the framework defers DOM insertion until the promise resolves; on subsequent renders, promise return values are ignored. When called with no arguments, returns a `Promise<TResult>` that resolves with the [=element value=] at schedule time.

  <dt>`after(callback?)`
  <dd>Registers a callback that the framework calls after DOM nodes are inserted into the document. The callback receives the [=element value=]. Same one-shot and deduplication semantics as `schedule`. Promise return values from `after` callbacks are always ignored. When called with no arguments, returns a `Promise<TResult>` that resolves with the [=element value=] at insertion time.

  <dt>`cleanup(callback?)`
  <dd>Registers a callback that the framework calls when the [=component=] unmounts, before children are unmounted. The callback receives the [=element value=]. Unlike `schedule` and `after`, cleanup callbacks are <strong>persistent</strong>: they survive across renders and fire once on unmount. Callbacks are deduplicated by function identity. If a callback returns a promise, the framework defers child unmounting until the promise resolves, keeping the [=component's=] DOM nodes in the document while awaiting. When called with no arguments, returns a `Promise<TResult>` that resolves with the [=element value=] at unmount time.

  <dt>`provide(key, value)`
  <dd>Stores a value on this [=component context=], retrievable by descendants via `consume`.

  <dt>`consume(key)`
  <dd>Walks up the [=component context=] tree and returns the value from the nearest ancestor that called `provide` with the same key.

  <dt>`dispatchEvent(event)`
  <dd>Dispatches an [`Event`](https://dom.spec.whatwg.org/#interface-event) on the [=component context=] and invokes the matching `on*` prop on the [=component=] element, if present. See [[#events]].

  <dt>`addEventListener` / `removeEventListener`
  <dd>[`EventTarget`](https://dom.spec.whatwg.org/#interface-eventtarget) methods that delegate to the host nodes produced by the [=component=]. See [[#events]].
</dl>

## Method Signatures ## {#method-signatures}

<table class="data">
  <thead>
    <tr><th>Method<th>Signature
  </thead>
  <tbody>
    <tr><td><code>refresh</code><td><code>(callback?: () => unknown) => Promise&lt;TResult> | TResult</code>
    <tr><td><code>schedule</code><td><code>(callback?: (value: TResult) => unknown) => Promise&lt;TResult> | void</code>
    <tr><td><code>after</code><td><code>(callback?: (value: TResult) => unknown) => Promise&lt;TResult> | void</code>
    <tr><td><code>cleanup</code><td><code>(callback?: (value: TResult) => unknown) => Promise&lt;TResult> | void</code>
    <tr><td><code>provide</code><td><code>(key: unknown, value: unknown) => void</code>
    <tr><td><code>consume</code><td><code>(key: unknown) => unknown</code>
    <tr><td><code>dispatchEvent</code><td><code>(event: Event) => boolean</code>
  </tbody>
</table>

# Props Iteration # {#props-iteration}

The [=component context=] implements both [`Symbol.iterator`](https://tc39.es/ecma262/#sec-symbol.iterator) and [`Symbol.asyncIterator`](https://tc39.es/ecma262/#sec-symbol.asynciterator).

## Synchronous (`for...of`) ## {#sync-iteration}

Each iteration yields the current props object. If the iterator is advanced twice without the [=component=] yielding, the framework throws a runtime error.

## Asynchronous (`for await...of`) ## {#async-iteration}

Each iteration yields the current props object. If new props are not yet available, the iteration awaits until the framework provides them. When a [=component=] enters this mode, the framework switches to a pull-based execution model where children render without [=blocking=] the generator.

# Reconciliation # {#reconciliation}

When the framework diffs children, it walks the new children array against the previous children array and decides for each position whether to reuse, replace, or remove an element.

## Position-Based Matching ## {#position-matching}

By default, children at the same position are compared by tag. If the tags match, the framework reuses the existing element and updates its props. If the tags differ, the framework unmounts the old element and mounts a new one in its place.

<table class="data">
  <thead>
    <tr><th>Old tag<th>New tag<th>Result
  </thead>
  <tbody>
    <tr><td><code>"div"</code><td><code>"div"</code><td>Reuse — update props, diff children.
    <tr><td><code>"div"</code><td><code>"span"</code><td>Replace — unmount old, mount new.
    <tr><td><code>ComponentA</code><td><code>ComponentA</code><td>Reuse — update props, re-execute component.
    <tr><td><code>ComponentA</code><td><code>ComponentB</code><td>Replace — unmount old component, mount new.
    <tr><td><code>"div"</code><td>(removed)<td>Remove — unmount old.
    <tr><td>(none)<td><code>"div"</code><td>Insert — mount new.
  </tbody>
</table>

## Keyed Reconciliation ## {#keyed-reconciliation}

When children have `key` props, the framework matches children by key instead of position. This allows the framework to efficiently reorder, insert, and remove children.

1. The framework walks new children sequentially. For each child, it checks whether the old child at the current position has the same key.
2. If keys match (or both are unkeyed), the framework advances both pointers.
3. On the first key mismatch, the framework builds a map from keys to old children.
4. For each subsequent keyed new child, the framework looks up the old child by key in the map.
5. For each subsequent unkeyed new child, the framework skips over keyed old children to find the next unkeyed one.
6. After processing all new children, any remaining old children not matched by key are unmounted.

Duplicate keys among siblings produce a runtime error. The framework discards the duplicate.

## Element Values ## {#element-values}

Every element in the tree produces an <dfn>element value</dfn> when rendered. For host elements (e.g. `"div"`), the [=element value=] is the node created by the [=renderer=]. For [=components=] and [=Fragments=], the [=element value=] is the node or array of nodes produced by their children.

The [=element value=] is the argument passed to `ref` callbacks, `schedule` callbacks, `after` callbacks, and `cleanup` callbacks. It is also what the [=component context's=] `addEventListener` and `removeEventListener` methods delegate to, and what `yield` evaluates to in generator [=components=] (as `previousResult`).

## Child Normalization ## {#child-normalization}

A <dfn>Child</dfn> is any value that can appear in the element tree. The valid child types are: `Element | string | number | boolean | null | undefined`. Before diffing, the framework normalizes children:

- **Strings** are wrapped in a Text element, producing a text node via the [=renderer=].
- **Numbers** are converted to strings and wrapped in a Text element.
- **`null`** and **`undefined`** produce no output. A [=component=] returning `undefined` renders nothing.
- **Booleans** (`true` and `false`) produce no output. This enables the `{condition && <Element />}` pattern — when the condition is `false`, nothing is rendered.
- **Non-string iterables** (arrays, [generators](https://tc39.es/ecma262/#sec-generator-objects), Sets, etc.) are implicitly wrapped in a [=Fragment=]. Each item in the iterable becomes a [=Child=] at its own position in the element tree. This means [=components=] can return arrays or generators to produce multiple siblings without a wrapper node.
- **Nested arrays** are flattened into the children array.
- **Elements** (objects with a `tag` property) are diffed recursively.

This normalization applies everywhere children appear: the return/yield value of a [=component=], the `children` prop, and the children of host elements.

## Arrangement ## {#arrangement}

After diffing, the framework arranges DOM nodes to reflect the new child order. The renderer receives the parent node and the ordered list of child nodes, and is responsible for inserting, moving, or removing DOM nodes as needed.

# Async Rendering # {#async-rendering}

## Blocking ## {#blocking}

Each [=component=] type has different blocking behavior. To <dfn lt="block|blocks|blocking">block</dfn> means the framework waits for the [=component's=] pending work to settle before accepting its next update.

<table class="data">
  <thead>
    <tr><th>Type<th>Blocks for own execution<th>Blocks for children
  </thead>
  <tbody>
    <tr><td>Function<td>No<td>No
    <tr><td>Generator<td>No (sync)<td>Yes
    <tr><td>Async function<td>Yes<td>No
    <tr><td>Async generator (<code>for...of</code>)<td>Yes<td>Yes
    <tr><td>Async generator (<code>for await...of</code>)<td>Yes<td>No
  </tbody>
</table>

When a [=component=] [=blocks=], the framework separates the block duration (the [=component's=] own execution) from the value duration (the full render including children). The [=enqueue|enqueuing=] algorithm advances based on the block, not the value.

## Enqueuing ## {#enqueuing}

When an async [=component=] is re-rendered while a previous execution is still pending, the framework <dfn lt="enqueue|enqueues|enqueuing">enqueues</dfn> at most one additional execution. The framework maintains two slots per [=component=]: <dfn>inflight</dfn> and <dfn>enqueued</dfn>.

1. If no [=inflight=] execution exists, the framework starts one immediately.
2. If an [=inflight=] execution exists but no [=enqueued=] execution, the framework creates an [=enqueued=] execution that waits for the [=inflight=] to settle, then runs with the latest props.
3. If both [=inflight=] and [=enqueued=] executions exist, the framework updates the stored props but does not create a third execution. The [=enqueued=] execution will use whatever props are current when it starts.

When the [=inflight=] execution settles, the [=enqueued=] execution is promoted to [=inflight=]. This guarantees at most one concurrent execution per [=component=] element, and that the final render always reflects the latest props.

Async generator [=components=] in `for await...of` mode use the same [=enqueue|enqueuing=] algorithm.

## Chasing ## {#chasing}

When different async element trees are rendered into the same [=position-based matching|position=] and settle out of order, the framework ensures that later renders always win. It does this by <dfn lt="chase|chasing">chasing</dfn>: racing each render's child values against the next render's child values using [`Promise.race`](https://tc39.es/ecma262/#sec-promise.race).

This produces a monotonic effect: if an earlier render settles first, its result is displayed until the later render settles. If the later render settles first, the earlier render's result is never displayed. The DOM always reflects the most recently initiated render that has settled.

## Fallbacks ## {#fallbacks}

When a new async element is rendered into a position where a previous element has already committed, the framework preserves the previously rendered content until the new element settles for the first time. This prevents the DOM from going blank while async elements are pending. The <dfn>fallback</dfn> chain is cleared once the element commits.

# Execution Order # {#execution-order}

## Per Update ## {#per-update}

1. The framework sets `isExecuting` to `true`.
2. The framework calls the [=component=] function (for function [=components=]) or `iterator.next(previousResult)` (for generators).
3. The framework sets `isExecuting` to `false`.
4. The framework diffs the yielded/returned children against the previous tree.
5. The framework commits DOM mutations.
6. The framework calls `ref` callbacks and fires `schedule` callbacks (DOM created, not yet inserted).
7. The framework inserts DOM nodes into the document.
8. The framework fires `after` callbacks (DOM live in document).

## On Unmount ## {#on-unmount}

1. The framework fires `cleanup` callbacks. If any return promises, child unmounting is deferred until they resolve.
2. Children are unmounted recursively.
3. For generators: the framework calls `return()` on the iterator. The `finally` block executes as part of the iterator protocol.

## Full Lifecycle ## {#full-lifecycle}

The following diagram traces every path through the framework's component lifecycle, including all callbacks, blocking behavior, and async branching.

<pre highlight="text">
Framework receives element with component tag
│
├─ FIRST RENDER
│   isExecuting = true
│   call component(this, props, ctx)
│   isExecuting = false
│   │
│   ├─ returns Children ─────────────────────── FUNCTION COMPONENT
│   │   diff children
│   │   commit DOM → ref(cb) / schedule(cb) → insert DOM → after(cb)
│   │
│   ├─ returns Iterator ─────────────────────── GENERATOR COMPONENT
│   │   store iterator
│   │   diff children ◀── BLOCKS until children settle
│   │   commit DOM → ref(cb) / schedule(cb) → insert DOM → after(cb)
│   │
│   ├─ returns Promise&lt;Children> ────────────── ASYNC FUNCTION COMPONENT
│   │   ◀── BLOCKS until promise settles (enqueue if re-rendered)
│   │   diff children (does not block)
│   │   commit DOM → ref(cb) / schedule(cb) → insert DOM → after(cb)
│   │
│   └─ returns AsyncIterator ────────────────── ASYNC GENERATOR COMPONENT
│       store async iterator
│       ◀── BLOCKS until first yield/return settles
│       │
│       ├─ enters for...of (sync iteration of ctx)
│       │   diff children ◀── BLOCKS until children settle
│       │   yield evaluates to settled result
│       │   commit DOM → ref(cb) / schedule(cb) → insert DOM → after(cb)
│       │
│       ├─ enters for await...of (async iteration of ctx)
│       │   diff children (does not block, pull-based)
│       │   yield evaluates to Promise&lt;result>
│       │   multiple yields per update → chasing
│       │   commit DOM → ref(cb) / schedule(cb) → insert DOM → after(cb)
│       │   suspends at loop bottom until new props or refresh()
│       │
│       └─ no loop (direct yield)
│           diff children ◀── BLOCKS until children settle
│           commit DOM → ref(cb) / schedule(cb) → insert DOM → after(cb)
│
├─ UPDATE (new props or refresh())
│   │
│   ├─ Function: re-call component(this, props, ctx) → full cycle above
│   │
│   ├─ Generator: iterator.next(previousResult) → diff → commit → callbacks
│   │   ◀── BLOCKS until children settle
│   │
│   ├─ Async function: re-call component(this, props, ctx)
│   │   enqueue if inflight (at most one pending)
│   │   ◀── BLOCKS until own promise settles
│   │   diff → commit → callbacks
│   │
│   └─ Async generator: iterator.next(previousResult)
│       enqueue if inflight (at most one pending)
│       ◀── BLOCKS until own yield settles
│       branching per iteration mode (see above)
│
├─ CHILD ERROR
│   │
│   ├─ Function/Async function: error propagates up
│   │
│   ├─ Generator: iterator.throw(error)
│   │   ├─ caught (try/catch around yield) → yield recovery tree
│   │   └─ uncaught → propagates up (iterator done, finally runs)
│   │
│   └─ Async generator:
│       ├─ yield promise unobserved → iterator.throw(error)
│       └─ yield promise observed → promise rejected → catch via await
│
└─ UNMOUNT
    cleanup(cb) → if promise returned, defer child unmounting
    ├─ Generator/Async generator: iterator.return() → finally block runs
    └─ children unmounted recursively
</pre>

### Callback Timing Reference ### {#callback-timing}

<table class="data">
  <thead>
    <tr><th>Callback<th>When<th>Argument<th>Lifetime<th>Async return
  </thead>
  <tbody>
    <tr><td><code>ref(cb)</code><td>After DOM created, before insertion<td>[=Element value=]<td>Prop<td>Ignored
    <tr><td><code>schedule(cb)</code><td>After DOM created, before insertion<td>[=Element value=]<td>One-shot<td>Defers insertion (initial render only)
    <tr><td><code>after(cb)</code><td>After DOM inserted into document<td>[=Element value=]<td>One-shot<td>Ignored
    <tr><td><code>cleanup(cb)</code><td>On unmount, before children unmount<td>[=Element value=]<td>Persistent<td>Defers child unmounting
    <tr><td><code>refresh(cb)</code><td>Enqueues re-execution<td>None (cb runs before re-exec)<td>One-shot<td>N/A
  </tbody>
</table>

# Error Handling # {#error-handling}

## Error Injection ## {#error-injection}

When a child [=component=] throws during rendering, the framework calls [`throw(error)`](https://tc39.es/ecma262/#sec-iterator-interface) on the nearest ancestor generator's iterator. This causes the `yield` expression in the ancestor to throw the error. If the generator catches the error (via `try`/`catch` around `yield`), it may yield a recovery element tree and rendering continues. If uncaught, the error propagates up the [=component context=] tree to the next ancestor generator.

## Async Error Handling ## {#async-error-handling}

For async generator [=components=] in `for await...of` mode, the framework tracks whether the promise returned by `yield` is being observed (via `.then()` or `.catch()`). If the promise is **unobserved** ("floating") and a child error occurs, the framework injects the error via `throw(error)` on the iterator. If the promise is **observed**, the framework rejects the promise, allowing the [=component=] to catch the error via `await`.

## Generator Return on Error ## {#generator-return-on-error}

If a generator [=component=] does not catch an injected error, the framework does not call `return()` — the iterator is already done because the uncaught `throw()` terminates it. The [`finally`](https://tc39.es/ecma262/#sec-try-statement) block of the generator, if present, still executes as part of the [iterator protocol](https://tc39.es/ecma262/#sec-iteration).

# Events # {#events}

The framework maps `on*` props to [event listeners](https://dom.spec.whatwg.org/#concept-event-listener) on the underlying host nodes. Both lowercase (`onclick`) and camelCase (`onClick`) event prop names are supported; camelCase names are normalized to lowercase before registration.

The `addEventListener` and `removeEventListener` methods on the [=component context=] delegate to the host nodes that the [=component=] produces. When the DOM [=renderer=] is used, calling `this.addEventListener("click", handler)` registers the listener on the DOM node(s) associated with the [=component=]. This allows [=components=] to listen to their own DOM events without requiring a `ref`.

[`dispatchEvent`](https://dom.spec.whatwg.org/#dom-eventtarget-dispatchevent) on a [=component context=] dispatches the event on the [=component context=] itself (as an [`EventTarget`](https://dom.spec.whatwg.org/#interface-eventtarget)) and also invokes the matching `on*` prop on the [=component's=] element, if present.

# DOM Attributes # {#dom-attributes}

Note: This section is specific to the DOM [=renderer=].

The framework passes props directly as [DOM attributes](https://dom.spec.whatwg.org/#concept-element-attribute) using standard [HTML attribute names](https://html.spec.whatwg.org/multipage/indices.html#attributes-3) (`class`, `for`, `innerHTML`, `tabindex`). It does not translate React-style names (`className`, `htmlFor`, `dangerouslySetInnerHTML`).

Style props accept an object with [CSS property names](https://drafts.csswg.org/cssom/#dom-cssstyledeclaration-setproperty). Both kebab-case (`font-size`) and camelCase (`fontSize`) are supported; camelCase names are converted to kebab-case. Numeric values are automatically suffixed with `px` for properties that accept [length units](https://drafts.csswg.org/css-values/#lengths).

# Special Components # {#special-components}

<table class="data">
  <thead>
    <tr><th>Component<th>Tag<th>Behavior
  </thead>
  <tbody>
    <tr><td><code>Fragment</code><td><code>""</code><td>The framework renders children without a wrapper node. Non-string iterables are implicitly wrapped in a <dfn>Fragment</dfn>.
    <tr><td><code>Text</code><td><code><a href="https://tc39.es/ecma262/#sec-symbol.for">Symbol.for</a>("crank.Text")</code><td>The framework creates a text node. Strings and numbers in the children array are implicitly wrapped in a Text element.
    <tr><td><code>Portal</code><td><code><a href="https://tc39.es/ecma262/#sec-symbol.for">Symbol.for</a>("crank.Portal")</code><td>The framework renders children into the DOM node specified by the <code>root</code> prop.
    <tr><td><code>Raw</code><td><code><a href="https://tc39.es/ecma262/#sec-symbol.for">Symbol.for</a>("crank.Raw")</code><td>The framework injects the raw HTML string or DOM node from the <code>value</code> prop.
    <tr><td><code>Copy</code><td><code><a href="https://tc39.es/ecma262/#sec-symbol.for">Symbol.for</a>("crank.Copy")</code><td>The framework preserves the previously rendered content at this position.
  </tbody>
</table>

# Special Props # {#special-props}

<table class="data">
  <thead>
    <tr><th>Prop<th>Type<th>Behavior
  </thead>
  <tbody>
    <tr><td><code>key</code><td><code>any</code><td>The framework uses keys for reconciliation. Keyed children are matched by key, not position. Duplicate keys among siblings produce a runtime error.
    <tr><td><code>ref</code><td><code>(value: TResult) => unknown</code><td>The framework calls this with the [=element value=] after DOM mutations are committed but before DOM nodes are inserted into the document — the same timing as <code>schedule</code> callbacks.
    <tr><td><code>copy</code><td><code>boolean | string</code><td><code>true</code>: the framework preserves the entire subtree. String: the framework selectively copies/excludes props (<code>"class disabled"</code> or <code>"!class"</code>).
    <tr><td><code>hydrate</code><td><code>boolean | string</code><td><code>true</code>: the framework hydrates from existing DOM. String: selective hydration of specific props.
    <tr><td><code>children</code><td><code>unknown</code><td>Child content passed between opening and closing tags.
  </tbody>
</table>

The framework strips all special props before passing the remaining props to the renderer.

# JSX # {#jsx}

[JSX](https://facebook.github.io/jsx/) is an XML-like syntax extension for JavaScript that provides a concise way to write [=element=] trees. A JSX compiler transforms expressions like `<div class="foo">hello</div>` into `createElement("div", {class: "foo"}, "hello")` calls. The framework supports three ways to create [=elements=]: the automatic JSX transform, the classic `createElement` transform, and tagged template literals.

## JSX Import Source ## {#jsx-import-source}

The recommended approach uses the [automatic JSX transform](https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html), where the compiler inserts the `createElement` calls automatically — no import needed. Configure it with a file-level pragma comment:

```
/** @jsxImportSource @b9g/crank */
```

Or project-wide via `tsconfig.json`:

```json
{ "compilerOptions": { "jsx": "react-jsx", "jsxImportSource": "@b9g/crank" } }
```

The framework provides `jsx-runtime` and `jsx-dev-runtime` modules at the `@b9g/crank` package root for use by JSX compilers.

## Classic createElement Transform ## {#create-element-transform}

The classic transform requires an explicit import and a pragma that tells the compiler which function to call:

```
/** @jsxFactory createElement */
import {createElement} from "@b9g/crank";
```

Or project-wide via `tsconfig.json`:

```json
{ "compilerOptions": { "jsx": "react", "jsxFactory": "createElement" } }
```

The `createElement` function is exported from the root `@b9g/crank` module.

## Template Tags ## {#template-tags}

For environments without a JSX compiler, the `jsx` and `html` tagged template literals from `@b9g/crank/standalone` produce [=elements=] using standard JavaScript [tagged template literals](https://tc39.es/ecma262/#sec-tagged-templates). Both names refer to the same function.

The template tag replicates JSX syntax and semantics within template strings. [=Component=] tags must be interpolated as expressions (`<${Component} />`). Closing tags support three forms: symmetric (`</${Component}>`), comment-style (`<//Component>`), and shorthand (`<//>`).

The `@b9g/crank/standalone` module re-exports everything from the root `@b9g/crank` module along with the template tag functions, enabling single-file applications that run directly in browsers without a build step.

# Render Adapter # {#render-adapter}

A [=renderer=] is constructed with an adapter object that implements operations for a specific host environment. The adapter is parameterized by four types:

- <strong><code>TNode</code></strong> — the host node type (e.g. DOM <code>Node</code>)
- <strong><code>TScope</code></strong> — data passed down the tree (e.g. SVG namespace)
- <strong><code>TRoot</code></strong> — the root container type (e.g. DOM <code>Element</code>)
- <strong><code>TResult</code></strong> — the public value type returned by <code>render</code> and exposed to [=components=]

The adapter implements the following operations:

<table class="data">
  <thead>
    <tr><th>Operation<th>Signature<th>Description
  </thead>
  <tbody>
    <tr><td><code>create</code><td><code>(tag: string, props: Record&lt;string, any>, scope: TScope) => TNode</code><td>Create a new host node for a host [=element=].
    <tr><td><code>adopt</code><td><code>(node: TNode, tag: string, props: Record&lt;string, any>, scope: TScope) => TNode</code><td>Adopt an existing node during hydration.
    <tr><td><code>text</code><td><code>(text: string, scope: TScope, oldNode?: TNode) => TNode</code><td>Create or update a text node.
    <tr><td><code>scope</code><td><code>(tag: string, props: Record&lt;string, any>, scope: TScope) => TScope</code><td>Compute scope for child [=elements=] (e.g. SVG namespace propagation).
    <tr><td><code>raw</code><td><code>(value: any, scope: TScope, oldNode?: TNode) => TNode</code><td>Handle raw HTML/node injection for the Raw [=component=].
    <tr><td><code>patch</code><td><code>(node: TNode, tag: string, props: Record&lt;string, any>, oldProps: Record&lt;string, any>, scope: TScope) => void</code><td>Update a node's properties when props change.
    <tr><td><code>arrange</code><td><code>(tag: string, node: TNode | TRoot, children: Array&lt;TNode>) => void</code><td>Position child nodes within a parent.
    <tr><td><code>remove</code><td><code>(node: TNode, tag: string) => void</code><td>Remove a node when unmounted.
    <tr><td><code>read</code><td><code>(node: TNode) => TResult</code><td>Transform internal node values into the public API type.
    <tr><td><code>finalize</code><td><code>(root: TRoot) => void</code><td>Perform final operations after a render cycle.
  </tbody>
</table>
