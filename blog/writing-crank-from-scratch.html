<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><title>Crank.js | Writing Crank from Scratch</title><link href="/static/index-UEEVTAOK.css" rel="stylesheet" type="text/css"><link rel="shortcut icon" href="/static/favicon.ico"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-20910936-4"></script><script>
								window.dataLayer = window.dataLayer || [];
								function gtag(){dataLayer.push(arguments);}
								gtag('js', new Date());

								gtag('config', 'UA-20910936-4');
							</script></head><body><nav id="navbar" class="navbar"><div class="navbar-group"><div class="navbar-item"><a class="navbar-title-link false" href="/"><img class="navbar-logo" src="/static/logo.svg" alt=""><span>Crank.js</span></a></div><div class="navbar-item"><a href="/guides/getting-started">Docs</a></div><div class="navbar-item"><a class="current" href="/blog/">Blog</a></div></div><div class="navbar-group"><div class="navbar-item"><a href="https://github.com/bikeshaving/crank">GitHub</a></div><div class="navbar-item"><a href="http://npm.im/@bikeshaving/crank">NPM</a></div></div></nav><div class="non-footer"><div id="sidebar" class="sidebar"><h3>Recent Posts</h3><div class="sidebar-item"><a href="/blog/writing-crank-from-scratch" class="current">Writing Crank from Scratch</a></div><div class="sidebar-item"><a href="/blog/introducing-crank" class="">Introducing Crank</a></div></div><main class="main"><div class="content"><h1>Writing Crank from Scratch</h1><p>October 13, 2020</p><p>One of my goals when authoring Crank.js was to create a framework which was so simple that any intermediate JavaScript developer could conceivably write it from scratch. What I think makes this uniquely achievable for Crank is that its component model is built on top of JavaScript’s two main control flow abstractions, iterators and promises, allowing developers to write components exclusively with sync and async functions and generator functions.</p><p>The following is an attempt to prove that I’ve met this goal by rewriting the bulk of Crank’s core logic as a series of additive commits, with explanations for what I’m doing at each step.</p><p>Even if you don’t plan on using Crank, this essay may yet prove informative in that it will demonstrate the basics of how virtual DOM libraries work, and show you some advanced techniques for working with iterators and promises. I will also attempt to justify some of the design decisions I made along the way, as I make them. Moreover, the end result won’t just be a toy library, but something which looks very similar to Crank’s actual source code, making the jump from reading this essay to contributing to the project much easier, should you be so inclined.</p><p>At each step, we’ll edit a single file which serves as the Crank module, and present a unified diff of the changes. We’ll also provide a link to the relevant commit and snapshot for each step in <a href="https://github.com/brainkim/crank-from-scratch">this companion repository</a>.</p><p>You can try out the module we create by referencing it from the following HTML file.</p><div class="codeblock" data-code="&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;/&gt;
  &lt;title&gt;Crank from Scratch&lt;/title&gt;
  &lt;script src=&quot;https://unpkg.com/@babel/standalone/babel.min.js&quot;&gt;&lt;/script&gt;
  &lt;script&gt;
Babel.registerPreset(&quot;crank&quot;, {
  presets: [
    [Babel.availablePresets.react, {
      runtime: &quot;classic&quot;,
      pragma: &quot;createElement&quot;,
      pragmaFrag: &quot;&#039;&#039;&quot;,
    }],
  ],
});
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;
  &lt;script type=&quot;text/babel&quot; data-type=&quot;module&quot; data-presets=&quot;crank&quot;&gt;
import {createElement, Renderer} from &quot;./crank.js&quot;;
const renderer = new Renderer();
const app = document.getElementById(&quot;app&quot;);
renderer.render(
  &lt;div&gt;Hello &lt;span style=&quot;color: red;&quot;&gt;world&lt;/span&gt;&lt;/div&gt;,
  app,
);
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;" data-lang="html"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">HTML</span><span class="token punctuation">&gt;</span></span></code><br></div><div><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span></code><br></div><div><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span></code><br></div><div><code>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>utf-8<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span></code><br></div><div><code>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Crank from Scratch<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span></code><br></div><div><code>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>https://unpkg.com/@babel/standalone/babel.min.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></code><br></div><div><code>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span></code><br></div><div><code><span class="token script"><span class="token language-javascript">Babel<span class="token punctuation">.</span><span class="token function">registerPreset</span><span class="token punctuation">(</span><span class="token string">&quot;crank&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span></span></span></code><br></div><div><code><span class="token script"><span class="token language-javascript">  presets<span class="token operator">:</span> <span class="token punctuation">[</span></span></span></code><br></div><div><code><span class="token script"><span class="token language-javascript">    <span class="token punctuation">[</span>Babel<span class="token punctuation">.</span>availablePresets<span class="token punctuation">.</span>react<span class="token punctuation">,</span> <span class="token punctuation">{</span></span></span></code><br></div><div><code><span class="token script"><span class="token language-javascript">      runtime<span class="token operator">:</span> <span class="token string">&quot;classic&quot;</span><span class="token punctuation">,</span></span></span></code><br></div><div><code><span class="token script"><span class="token language-javascript">      pragma<span class="token operator">:</span> <span class="token string">&quot;createElement&quot;</span><span class="token punctuation">,</span></span></span></code><br></div><div><code><span class="token script"><span class="token language-javascript">      pragmaFrag<span class="token operator">:</span> <span class="token string">&quot;&#039;&#039;&quot;</span><span class="token punctuation">,</span></span></span></code><br></div><div><code><span class="token script"><span class="token language-javascript">    <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span></span></span></code><br></div><div><code><span class="token script"><span class="token language-javascript">  <span class="token punctuation">]</span><span class="token punctuation">,</span></span></span></code><br></div><div><code><span class="token script"><span class="token language-javascript"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span></span></code><br></div><div><code><span class="token script"><span class="token language-javascript">  </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></code><br></div><div><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span></code><br></div><div><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span></code><br></div><div><code>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>app<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span></code><br></div><div><code>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>text/babel<span class="token punctuation">&quot;</span></span> <span class="token attr-name">data-type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>module<span class="token punctuation">&quot;</span></span> <span class="token attr-name">data-presets</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>crank<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span></code><br></div><div><code><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> <span class="token punctuation">{</span>createElement<span class="token punctuation">,</span> Renderer<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;./crank.js&quot;</span><span class="token punctuation">;</span></span></span></code><br></div><div><code><span class="token script"><span class="token language-javascript"><span class="token keyword">const</span> renderer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Renderer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span></span></code><br></div><div><code><span class="token script"><span class="token language-javascript"><span class="token keyword">const</span> app <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;app&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span></span></code><br></div><div><code><span class="token script"><span class="token language-javascript">renderer<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span></span></span></code><br></div><div><code><span class="token script"><span class="token language-javascript">  <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>Hello <span class="token operator">&lt;</span>span style<span class="token operator">=</span><span class="token string">&quot;color: red;&quot;</span><span class="token operator">&gt;</span>world<span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token punctuation">,</span></span></span></code><br></div><div><code><span class="token script"><span class="token language-javascript">  app<span class="token punctuation">,</span></span></span></code><br></div><div><code><span class="token script"><span class="token language-javascript"><span class="token punctuation">)</span><span class="token punctuation">;</span></span></span></code><br></div><div><code><span class="token script"><span class="token language-javascript">  </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></code><br></div><div><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span></code><br></div><div><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code><br></div></pre></content-area></div></div><p>This file uses the <a href="https://babeljs.io/docs/en/babel-standalone">Babel standalone transpiler</a> to transpile <a href="https://facebook.github.io/jsx/">JSX</a> on the fly. We don’t transpile modern ECMAScript features, so you will need to open the file from an up-to-date browser. Alternatively, if you don’t want to use JSX, you can use the <a href="https://github.com/developit/htm">HTM template tag</a>, which requires no transpilation. The examples in this essay will use JSX, but you are free to use HTM or any other alternative.</p><div class="codeblock" data-code="&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;/&gt;
  &lt;title&gt;Crank from Scratch&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;
  &lt;script type=&quot;module&quot;&gt;
import htm from &quot;https://unpkg.com/htm?module&quot;;
import {createElement, Renderer} from &quot;./crank.js&quot;;
const html = htm.bind(createElement);
const renderer = new Renderer();
const app = document.getElementById(&quot;app&quot;);
renderer.render(
  html`&lt;div&gt;Hello &lt;span style=&quot;color: red;&quot;&gt;world&lt;/span&gt;&lt;/div&gt;`,
  app,
);
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;" data-lang="html"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">HTML</span><span class="token punctuation">&gt;</span></span></code><br></div><div><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span></code><br></div><div><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span></code><br></div><div><code>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>utf-8<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span></code><br></div><div><code>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Crank from Scratch<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span></code><br></div><div><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span></code><br></div><div><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span></code><br></div><div><code>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>app<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span></code><br></div><div><code>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>module<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span></code><br></div><div><code><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> htm <span class="token keyword">from</span> <span class="token string">&quot;https://unpkg.com/htm?module&quot;</span><span class="token punctuation">;</span></span></span></code><br></div><div><code><span class="token script"><span class="token language-javascript"><span class="token keyword">import</span> <span class="token punctuation">{</span>createElement<span class="token punctuation">,</span> Renderer<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;./crank.js&quot;</span><span class="token punctuation">;</span></span></span></code><br></div><div><code><span class="token script"><span class="token language-javascript"><span class="token keyword">const</span> html <span class="token operator">=</span> <span class="token function">htm</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>createElement<span class="token punctuation">)</span><span class="token punctuation">;</span></span></span></code><br></div><div><code><span class="token script"><span class="token language-javascript"><span class="token keyword">const</span> renderer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Renderer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span></span></code><br></div><div><code><span class="token script"><span class="token language-javascript"><span class="token keyword">const</span> app <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;app&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span></span></code><br></div><div><code><span class="token script"><span class="token language-javascript">renderer<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span></span></span></code><br></div><div><code><span class="token script"><span class="token language-javascript">  html<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div&gt;Hello &lt;span style=&quot;color: red;&quot;&gt;world&lt;/span&gt;&lt;/div&gt;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span></span></span></code><br></div><div><code><span class="token script"><span class="token language-javascript">  app<span class="token punctuation">,</span></span></span></code><br></div><div><code><span class="token script"><span class="token language-javascript"><span class="token punctuation">)</span><span class="token punctuation">;</span></span></span></code><br></div><div><code><span class="token script"><span class="token language-javascript">  </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></code><br></div><div><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span></code><br></div><div><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code><br></div></pre></content-area></div></div><p>This essay assumes an intermediate level of JavaScript experience, as well as some experience with a virtual DOM framework like React.</p><h2>Step 1: Creating DOM Nodes</h2><p>The first thing we’ll need to do is to implement a <code class="inline">createElement()</code> function, so that the module works with JSX. While the React team is <a href="https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html">working on an alterative JSX output</a>, we’ll stick to its original transpilation, where JSX element expressions are transpiled to <code class="inline">createElement()</code> calls, with the <em>tag</em>, <em>props</em> and <em>children</em> of the syntax transpiled to the first, second, and remaining arguments of the <code class="inline">createElement()</code> call respectively.</p><div class="codeblock" data-code="const el = (
  &lt;div id=&quot;greeting&quot;&gt;
    Hello &lt;span style=&quot;color: red;&quot;&gt;World&lt;/span&gt;
  &lt;/div&gt;
);

// transpiles to:

const el = createElement(
  &quot;div&quot;,
  {id: &quot;greeting&quot;},
  &quot;Hello &quot;, createElement(
    &quot;span&quot;,
    {style: &quot;color: red;&quot;},
    &quot;World&quot;,
  ),
);" data-lang="jsx"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token keyword">const</span> el <span class="token operator">=</span> <span class="token punctuation">(</span></code><br></div><div><code>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>greeting<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span></code><br></div><div><code>    Hello <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token value css language-css"><span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span></span><span class="token punctuation">&quot;</span></span></span><span class="token punctuation">&gt;</span></span>World<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span></code><br></div><div><code>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span></code><br></div><div><code><span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code></code><br></div><div><code><span class="token comment">// transpiles to:</span></code><br></div><div><code></code><br></div><div><code><span class="token keyword">const</span> el <span class="token operator">=</span> <span class="token function">createElement</span><span class="token punctuation">(</span></code><br></div><div><code>  <span class="token string">&quot;div&quot;</span><span class="token punctuation">,</span></code><br></div><div><code>  <span class="token punctuation">{</span>id<span class="token operator">:</span> <span class="token string">&quot;greeting&quot;</span><span class="token punctuation">}</span><span class="token punctuation">,</span></code><br></div><div><code>  <span class="token string">&quot;Hello &quot;</span><span class="token punctuation">,</span> <span class="token function">createElement</span><span class="token punctuation">(</span></code><br></div><div><code>    <span class="token string">&quot;span&quot;</span><span class="token punctuation">,</span></code><br></div><div><code>    <span class="token punctuation">{</span>style<span class="token operator">:</span> <span class="token string">&quot;color: red;&quot;</span><span class="token punctuation">}</span><span class="token punctuation">,</span></code><br></div><div><code>    <span class="token string">&quot;World&quot;</span><span class="token punctuation">,</span></code><br></div><div><code>  <span class="token punctuation">)</span><span class="token punctuation">,</span></code><br></div><div><code><span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div></pre></content-area></div></div><p>The other thing we’ll need is a renderer, a JavaScript class which reads element trees and does the actual work of creating and mutating DOM nodes. Importantly, the renderer has a <code class="inline">render()</code> method, which allows us to write code like the following to render a JSX expression into a DOM node.</p><div class="codeblock" data-code="renderer.render(
  &lt;div&gt;Hello &lt;span style=&quot;color: red;&quot;&gt;world&lt;/span&gt;&lt;/div&gt;,
  document.getElementById(&quot;app&quot;),
);" data-lang="jsx"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code>renderer<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span></code><br></div><div><code>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>Hello <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token value css language-css"><span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span></span><span class="token punctuation">&quot;</span></span></span><span class="token punctuation">&gt;</span></span>world<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span></code><br></div><div><code>  document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;app&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span></code><br></div><div><code><span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div></pre></content-area></div></div><h3>Implementation</h3><div class="codeblock" data-code="--- /dev/null
+++ b/crank.js
@@ -0,0 +1,99 @@
+function wrap(value) {
+  return value === undefined ? [] : Array.isArray(value) ? value : [value];
+}
+
+class Element {
+  constructor(tag, props) {
+    this.tag = tag;
+    this.props = props;
+  }
+}
+
+export const Portal = Symbol.for(&quot;crank.Portal&quot;);
+
+export function createElement(tag, props, ...children) {
+  props = Object.assign({}, props);
+  if (children.length === 1) {
+    props.children = children[0];
+  } else if (children.length &gt; 1) {
+    props.children = children;
+  }
+
+  return new Element(tag, props);
+}
+
+export class Renderer {
+  render(children, root) {
+    const portal = createElement(Portal, {root}, children);
+    return update(this, portal);
+  }
+
+  create(el) {
+    return document.createElement(el.tag);
+  }
+
+  patch(el, node) {
+    for (let [name, value] of Object.entries(el.props)) {
+      if (name === &quot;children&quot;) {
+        continue;
+      } else if (name === &quot;class&quot;) {
+        name = &quot;className&quot;;
+      }
+
+      if (name in node) {
+        node[name] = value;
+      } else {
+        node.setAttribute(name, value);
+      }
+    }
+  }
+
+  arrange(el, node, children) {
+    let child = node.firstChild;
+    for (const newChild of children) {
+      if (child === newChild) {
+        child = child.nextSibling;
+      } else if (typeof newChild === &quot;string&quot;) {
+        if (child !== null &amp;&amp; child.nodeType === Node.TEXT_NODE) {
+          child.nodeValue = newChild;
+          child = child.nextSibling;
+        } else {
+          node.insertBefore(document.createTextNode(newChild), child);
+        }
+      } else {
+        node.insertBefore(newChild, child);
+      }
+    }
+
+    while (child !== null) {
+      const nextSibling = child.nextSibling;
+      node.removeChild(child);
+      child = child.nextSibling;
+    }
+  }
+}
+
+function update(renderer, el) {
+  const values = [];
+  for (const child of wrap(el.props.children)) {
+    if (child instanceof Element) {
+      values.push(update(renderer, child));
+    } else if (child) {
+      values.push(child);
+    }
+  }
+
+  return commit(renderer, el, values);
+}
+
+function commit(renderer, el, values) {
+  if (el.tag === Portal) {
+    renderer.arrange(el, el.props.root, values);
+    return undefined;
+  }
+
+  const node = renderer.create(el);
+  renderer.patch(el, node);
+  renderer.arrange(el, node, values);
+  return node;
+}" data-lang="diff"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token coord">--- /dev/null</span></code><br></div><div><code><span class="token coord">+++ b/crank.js</span></code><br></div><div><code><span class="token coord">@@ -0,0 +1,99 @@</span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">function wrap(value) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  return value === undefined ? [] : Array.isArray(value) ? value : [value];</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">}</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">class Element {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  constructor(tag, props) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    this.tag = tag;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    this.props = props;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">}</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">export const Portal = Symbol.for(&quot;crank.Portal&quot;);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">export function createElement(tag, props, ...children) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  props = Object.assign({}, props);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  if (children.length === 1) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    props.children = children[0];</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  } else if (children.length &gt; 1) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    props.children = children;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  return new Element(tag, props);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">}</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">export class Renderer {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  render(children, root) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    const portal = createElement(Portal, {root}, children);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    return update(this, portal);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  create(el) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    return document.createElement(el.tag);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  patch(el, node) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    for (let [name, value] of Object.entries(el.props)) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      if (name === &quot;children&quot;) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        continue;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      } else if (name === &quot;class&quot;) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        name = &quot;className&quot;;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      if (name in node) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        node[name] = value;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      } else {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        node.setAttribute(name, value);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  arrange(el, node, children) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let child = node.firstChild;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    for (const newChild of children) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      if (child === newChild) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        child = child.nextSibling;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      } else if (typeof newChild === &quot;string&quot;) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        if (child !== null &amp;&amp; child.nodeType === Node.TEXT_NODE) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">          child.nodeValue = newChild;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">          child = child.nextSibling;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        } else {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">          node.insertBefore(document.createTextNode(newChild), child);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      } else {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        node.insertBefore(newChild, child);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    while (child !== null) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      const nextSibling = child.nextSibling;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      node.removeChild(child);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      child = child.nextSibling;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">}</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">function update(renderer, el) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  const values = [];</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  for (const child of wrap(el.props.children)) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    if (child instanceof Element) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      values.push(update(renderer, child));</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    } else if (child) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      values.push(child);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  return commit(renderer, el, values);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">}</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">function commit(renderer, el, values) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  if (el.tag === Portal) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    renderer.arrange(el, el.props.root, values);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    return undefined;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  const node = renderer.create(el);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  renderer.patch(el, node);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  renderer.arrange(el, node, values);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  return node;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">}</span></span></code><br></div></pre></content-area></div></div><p><a href="https://github.com/brainkim/crank-from-scratch/commit/80683e84ac529022c898fdaa72c47d6c26a2cef2">Diff</a> <a href="https://github.com/brainkim/crank-from-scratch/blob/80683e84ac529022c898fdaa72c47d6c26a2cef2/crank.js">File</a></p><p>The <code class="inline">createElement()</code> function creates an <code class="inline">Element</code> instance which has two members, <code class="inline">tag</code> and <code class="inline">props</code>. The <code class="inline">createElement()</code> function’s main responsibility is to create an object for the element’s <code class="inline">props</code> if none are passed in, and to collect any remaining arguments under the name “children” on the <code class="inline">props</code> object.</p><p>The <code class="inline">Element</code> class should not be confused with the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element"><code class="inline">Element</code> base class</a> provided by the DOM. It’s an unfortunate name collision, but I also couldn’t bring myself to name the return value of a function named “createElement” anything else. These virtual elements are more or less plain JavaScript objects, and we only use a class to keep track of the element’s properties in one place. When referring to actual DOM nodes, we’ll use the term “node” in identifiers and properties instead.</p><p>As far as rendering goes, we’ve divided the process into the methods <code class="inline">create()</code>, <code class="inline">patch()</code> and <code class="inline">arrange()</code>, and the functions <code class="inline">update()</code> and <code class="inline">commit()</code>. Currently, we could probably inline all of this logic as a single function, but by using the power of hindsight I’ve structured the code so that we’ll mostly add to these functions as we implement more features.</p><p>The <code class="inline">create()</code>, <code class="inline">patch()</code> and <code class="inline">arrange()</code> methods are the only places in the module where we perform actual DOM operations. The <code class="inline">create()</code> method creates DOM nodes, the <code class="inline">patch()</code> method updates their properties and attributes, and the <code class="inline">arrange()</code> method manages the insertion and removal of DOM nodes. These methods are defined on the <code class="inline">Renderer</code> class because it’s possible that we might want to subclass it for custom DOM behavior, or to render to environments besides the DOM.</p><p>On the other hand, while we could have defined the <code class="inline">update()</code> and <code class="inline">commit()</code> functions as renderer methods as well, we make them functions private to the module because there will never be a need to expose them. We’ll see this technique for “method” privacy used more often later.</p><p>The <code class="inline">update()</code> and <code class="inline">commit()</code> functions represent the two phases of walking the element tree to create DOM nodes. The <code class="inline">update()</code> function walks the tree by calling <code class="inline">update()</code> recursively on each element child, collects the results of these calls in a <code class="inline">values</code> array, and calls the <code class="inline">commit()</code> function with this array of values. The <code class="inline">commit()</code> function is where the actual DOM mutations happen in the form of <code class="inline">create()</code>, <code class="inline">patch()</code>, and <code class="inline">arrange()</code> method calls. Finally, the <code class="inline">update()</code> and <code class="inline">commit()</code> functions return the created DOM nodes for each element so the same process can occur higher in the call stack.</p><p><strong>Notes:</strong></p><ol><li>In the <code class="inline">render()</code> method, we create a special <code class="inline">Portal</code> element to serve as the root of the element tree. In Crank, a <code class="inline">Portal</code> is a special element tag which can be used to render into multiple user-provided DOM nodes at the same time. This can be helpful for use-cases such as tooltips or modals, and mirrors a <a href="https://reactjs.org/docs/portals.html">similar API in React</a>. Here, we mainly use it as a way to identify the root element so that we can call the <code class="inline">arrange()</code> method but not the <code class="inline">create()</code> or <code class="inline">patch()</code> methods. The latter two methods wouldn’t make sense at the root.</li><li>In the <code class="inline">createElement()</code> function, we unwrap the children array if it has a length of one, and don’t assign it if it has a length of zero. This is a theme we’ll see throughout the implementation, where we unwrap arrays of length zero or one just before we retain them in memory. The reason we do this is that if you look at a typical JSX tree, most of the elements in the tree will have zero or one children, so by not retaining this extra array we can save on runtime memory costs. When we need to actually iterate over the <code class="inline">children</code> prop, we call the utility function <code class="inline">wrap()</code> to create an array on the fly, so we don’t have to explicitly handle elements with zero or one children.</li></ol><h2>Step 2: Element Diffing</h2><p>Our renderer works, but will recreate every DOM node in the tree for every render. Not only is this inefficient but also incorrect, insofar as the renderer will reset stateful DOM nodes like form or media elements. We need a way to somehow preserve as much of the DOM as possible between renders.</p><p>Thankfully, we can diff entire trees efficiently because of an observation first made by the React authors, which is that for any two element subtrees, different root tags will usually indicate different substructures. For instance, a <code class="inline">table</code> element will almost certainly have different children as compared to a <code class="inline">ul</code> element. Therefore, we use an algorithm which recursively compares element tags at each level of the tree and throws away subtrees whose root tags don’t match.</p><h3>Implementation</h3><div class="codeblock" data-code="--- a/crank.js
+++ b/crank.js
@@ -2,10 +2,20 @@ function wrap(value) {
   return value === undefined ? [] : Array.isArray(value) ? value : [value];
 }

+function unwrap(arr) {
+  return arr.length &lt;= 1 ? arr[0] : arr;
+}
+
 class Element {
   constructor(tag, props) {
     this.tag = tag;
     this.props = props;
+
+    this._node = undefined;
+    this._children = undefined;
+
+    // flags
+    this._isMounted = false;
   }
 }

@@ -22,78 +32,133 @@ export function createElement(tag, props, ...children) {
   return new Element(tag, props);
 }

+function narrow(value) {
+  if (typeof value === &quot;boolean&quot; || value == null) {
+    return undefined;
+  } else if (typeof value === &quot;string&quot; || value instanceof Element) {
+    return value;
+  }
+
+  return value.toString();
+}
+
 export class Renderer {
+  constructor() {
+    this._cache = new WeakMap();
+  }
+
   render(children, root) {
-    const portal = createElement(Portal, {root}, children);
+    let portal = this._cache.get(root);
+    if (portal) {
+      portal.props = {root, children};
+    } else {
+      portal = createElement(Portal, {root, children});
+      this._cache.set(root, portal);
+    }
+
     return update(this, portal);
   }

   create(el) {
     return document.createElement(el.tag);
   }

   patch(el, node) {
     for (let [name, value] of Object.entries(el.props)) {
       if (name === &quot;children&quot;) {
         continue;
       } else if (name === &quot;class&quot;) {
         name = &quot;className&quot;;
       }

       if (name in node) {
         node[name] = value;
       } else {
         node.setAttribute(name, value);
       }
     }
   }

   arrange(el, node, children) {
     let child = node.firstChild;
     for (const newChild of children) {
       if (child === newChild) {
         child = child.nextSibling;
       } else if (typeof newChild === &quot;string&quot;) {
         if (child !== null &amp;&amp; child.nodeType === Node.TEXT_NODE) {
           child.nodeValue = newChild;
           child = child.nextSibling;
         } else {
           node.insertBefore(document.createTextNode(newChild), child);
         }
       } else {
         node.insertBefore(newChild, child);
       }
     }

     while (child !== null) {
       const nextSibling = child.nextSibling;
       node.removeChild(child);
       child = child.nextSibling;
     }
   }
 }

+function diff(renderer, oldChild, newChild) {
+  if (
+    oldChild instanceof Element &amp;&amp;
+    newChild instanceof Element &amp;&amp;
+    oldChild.tag === newChild.tag
+  ) {
+    if (oldChild !== newChild) {
+      oldChild.props = newChild.props;
+      newChild = oldChild;
+    }
+  }
+
+  let value;
+  if (newChild instanceof Element) {
+    value = update(renderer, newChild);
+  } else {
+    value = newChild;
+  }
+
+  return [newChild, value];
+}
+
 function update(renderer, el) {
+  if (el._isMounted) {
+    el = createElement(el, {...el.props});
+  }
+
+  const oldChildren = wrap(el._children);
+  const newChildren = wrap(el.props.children);
+  const children = [];
   const values = [];
-  for (const child of wrap(el.props.children)) {
-    if (child instanceof Element) {
-      values.push(update(renderer, child));
-    } else if (child) {
-      values.push(child);
+  const length = Math.max(oldChildren.length, newChildren.length);
+  for (let i = 0; i &lt; length; i++) {
+    const oldChild = oldChildren[i];
+    const newChild = narrow(newChildren[i]);
+    const [child, value] = diff(renderer, oldChild, newChild);
+    children.push(child);
+    if (value) {
+      values.push(value);
     }
   }

+  el._children = unwrap(children);
   return commit(renderer, el, values);
 }

 function commit(renderer, el, values) {
   if (el.tag === Portal) {
     renderer.arrange(el, el.props.root, values);
     return undefined;
+  } else if (!el._node) {
+    el._node = renderer.create(el);
   }

-  const node = renderer.create(el);
-  renderer.patch(el, node);
-  renderer.arrange(el, node, values);
-  return node;
+  renderer.patch(el, el._node);
+  renderer.arrange(el, el._node, values);
+  return el._node;
 }" data-lang="diff"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token coord">--- a/crank.js</span></code><br></div><div><code><span class="token coord">+++ b/crank.js</span></code><br></div><div><code>@@ -2,10 +2,20 @@ function wrap(value) {</code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  return value === undefined ? [] : Array.isArray(value) ? value : [value];</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">function unwrap(arr) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  return arr.length &lt;= 1 ? arr[0] : arr;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">}</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">class Element {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  constructor(tag, props) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this.tag = tag;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this.props = props;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    this._node = undefined;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    this._children = undefined;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    // flags</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    this._isMounted = false;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code></code><br></div><div><code>@@ -22,78 +32,133 @@ export function createElement(tag, props, ...children) {</code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  return new Element(tag, props);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">function narrow(value) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  if (typeof value === &quot;boolean&quot; || value == null) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    return undefined;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  } else if (typeof value === &quot;string&quot; || value instanceof Element) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    return value;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  return value.toString();</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">}</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">export class Renderer {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  constructor() {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    this._cache = new WeakMap();</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  render(children, root) {</span></span></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    const portal = createElement(Portal, {root}, children);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let portal = this._cache.get(root);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    if (portal) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      portal.props = {root, children};</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    } else {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      portal = createElement(Portal, {root, children});</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      this._cache.set(root, portal);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    return update(this, portal);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  create(el) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    return document.createElement(el.tag);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  patch(el, node) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    for (let [name, value] of Object.entries(el.props)) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      if (name === &quot;children&quot;) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        continue;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      } else if (name === &quot;class&quot;) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        name = &quot;className&quot;;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      if (name in node) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        node[name] = value;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      } else {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        node.setAttribute(name, value);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  arrange(el, node, children) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    let child = node.firstChild;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    for (const newChild of children) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      if (child === newChild) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        child = child.nextSibling;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      } else if (typeof newChild === &quot;string&quot;) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        if (child !== null &amp;&amp; child.nodeType === Node.TEXT_NODE) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">          child.nodeValue = newChild;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">          child = child.nextSibling;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        } else {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">          node.insertBefore(document.createTextNode(newChild), child);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      } else {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        node.insertBefore(newChild, child);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    while (child !== null) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      const nextSibling = child.nextSibling;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      node.removeChild(child);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      child = child.nextSibling;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">function diff(renderer, oldChild, newChild) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  if (</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    oldChild instanceof Element &amp;&amp;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    newChild instanceof Element &amp;&amp;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    oldChild.tag === newChild.tag</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  ) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    if (oldChild !== newChild) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      oldChild.props = newChild.props;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      newChild = oldChild;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  let value;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  if (newChild instanceof Element) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    value = update(renderer, newChild);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  } else {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    value = newChild;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  return [newChild, value];</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">}</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">function update(renderer, el) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  if (el._isMounted) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    el = createElement(el, {...el.props});</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  const oldChildren = wrap(el._children);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  const newChildren = wrap(el.props.children);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  const children = [];</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  const values = [];</span></span></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  for (const child of wrap(el.props.children)) {</span></span></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    if (child instanceof Element) {</span></span></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">      values.push(update(renderer, child));</span></span></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    } else if (child) {</span></span></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">      values.push(child);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  const length = Math.max(oldChildren.length, newChildren.length);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  for (let i = 0; i &lt; length; i++) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    const oldChild = oldChildren[i];</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    const newChild = narrow(newChildren[i]);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    const [child, value] = diff(renderer, oldChild, newChild);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    children.push(child);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    if (value) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      values.push(value);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  el._children = unwrap(children);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  return commit(renderer, el, values);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">function commit(renderer, el, values) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  if (el.tag === Portal) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    renderer.arrange(el, el.props.root, values);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    return undefined;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  } else if (!el._node) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    el._node = renderer.create(el);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  const node = renderer.create(el);</span></span></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  renderer.patch(el, node);</span></span></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  renderer.arrange(el, node, values);</span></span></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  return node;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  renderer.patch(el, el._node);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  renderer.arrange(el, el._node, values);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  return el._node;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div></pre></content-area></div></div><p><a href="https://github.com/brainkim/crank-from-scratch/commit/c5299409736081d37a66de9a91b1db0e2883bc46">Diff</a> <a href="https://github.com/brainkim/crank-from-scratch/blob/c5299409736081d37a66de9a91b1db0e2883bc46/crank.js">File</a></p><p>To diff old and new trees, we need to retain old elements and DOM nodes so that we can make comparisons. At the renderer level, we use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap">a weakmap</a> to store the <code class="inline">Portal</code> elements we created in <code class="inline">render()</code> by the DOM node which we rendered into. At the element level, we store an element’s previously rendered children directly on the element under its <code class="inline">_children</code> property, and an element’s previously created DOM node under its <code class="inline">_node</code> property. We use leading underscores to indicate that these properties should be private to the module.</p><p>The <code class="inline">diff()</code> function compares old and new children by position, and if elements appear in the same position with the same tag, we simply copy the new element’s props over to the old element. Finally, in the <code class="inline">commit()</code> function, we check to see if an element has a DOM node defined on it before creating new ones.</p><p><strong>Notes:</strong></p><ol><li><p>Element trees can contain almost any value: <code class="inline">true</code>, <code class="inline">false</code>, <code class="inline">null</code> and <code class="inline">undefined</code> are erased, while numbers and non-element objects are converted to strings.</p><div class="codeblock" data-code="const el = (
  &lt;div&gt;{&quot;a&quot;}{1 + 1}{true}{false}{null}{undefined}&lt;/div&gt;
);

console.log(el.props.children); // [&quot;a&quot;, 2, true, false, null, undefined]
renderer.render(app);
console.log(app.innerHTML); // &lt;div&gt;a2&lt;/div&gt;" data-lang="jsx"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token keyword">const</span> el <span class="token operator">=</span> <span class="token punctuation">(</span></code><br></div><div><code>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token boolean">false</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token keyword">null</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token keyword">undefined</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span></code><br></div><div><code><span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code></code><br></div><div><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>el<span class="token punctuation">.</span>props<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [&quot;a&quot;, 2, true, false, null, undefined]</span></code><br></div><div><code>renderer<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>app<span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>app<span class="token punctuation">.</span>innerHTML<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &lt;div&gt;a2&lt;/div&gt;</span></code><br></div></pre></content-area></div></div><p>Therefore, we use the helper function <code class="inline">narrow()</code> to reduce the members of element trees to elements, strings, and <code class="inline">undefined</code>. This greatly simplifies the number of cases we need to handle when diffing.</p></li><li><p>You might think mutating virtual elements directly is a little suspicious, as opposed to having some sort of separate internal node data structure. The fact is, most virtual elements which are created are thrown away every render, so retaining and mutating them is both more efficient and easier to implement, especially because any internal node type would have many of the same properties as elements anyways. Additionally, we can use a boolean flag (<code class="inline">_isMounted</code>) to defensively clone elements if we ever detect that they’re being reused.</p></li></ol><h2>Step 3: Function Components</h2><p>The renderer can now efficiently create and mutate DOM nodes. However, we currently have to call the <code class="inline">render()</code> method with a full tree which looks more or less exactly like the HTML we want to render. The feature which makes JSX shine is that we can use the same syntax and diffing algorithm to encapsulate parts of the tree as <em>components.</em> To do this in Crank, we make the tags of elements reference a <em>function</em> rather than a string, and call that function with the element’s props when walking the element tree.</p><div class="codeblock" data-code="function Greeting({color, children}) {
  return (
    &lt;div&gt;
      Hello &lt;span style={`color: ${color};`}&gt;{children}&lt;/span&gt;
    &lt;/div&gt;
  );
}

renderer.render(&lt;Greeting color=&quot;red&quot;&gt;World&lt;/Greeting&gt;, app);" data-lang="jsx"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token keyword">function</span> <span class="token function">Greeting</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>color<span class="token punctuation">,</span> children<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>  <span class="token keyword">return</span> <span class="token punctuation">(</span></code><br></div><div><code>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span></code><br></div><div><code>      Hello <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">style</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">color: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>color<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>children<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span></code><br></div><div><code>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span></code><br></div><div><code>  <span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code><span class="token punctuation">}</span></code><br></div><div><code></code><br></div><div><code>renderer<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Greeting</span></span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>red<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>World<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Greeting</span></span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> app<span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div></pre></content-area></div></div><p>We use PascalCase when defining components because JSX transpilation is determined by the casing of the first letter of the tag: upper-case means the tag is an identifier in the current scope, and lower-case means the tag is a string.</p><h3>Implementation</h3><div class="codeblock" data-code="--- a/crank.js
+++ b/crank.js
@@ -129,36 +129,45 @@ function diff(renderer, oldChild, newChild) {
 function update(renderer, el) {
   if (el._isMounted) {
     el = createElement(el, {...el.props});
   }

   const oldChildren = wrap(el._children);
-  const newChildren = wrap(el.props.children);
+  let newChildren;
+  if (typeof el.tag === &quot;function&quot;) {
+    newChildren = el.tag(el.props);
+  } else {
+    newChildren = el.props.children;
+  }
+
+  newChildren = wrap(newChildren);
   const children = [];
   const values = [];
   const length = Math.max(oldChildren.length, newChildren.length);
   for (let i = 0; i &lt; length; i++) {
     const oldChild = oldChildren[i];
     const newChild = narrow(newChildren[i]);
     const [child, value] = diff(renderer, oldChild, newChild);
     children.push(child);
     if (value) {
       values.push(value);
     }
   }

   el._children = unwrap(children);
   return commit(renderer, el, values);
 }

 function commit(renderer, el, values) {
-  if (el.tag === Portal) {
+  if (typeof el.tag === &quot;function&quot;) {
+    return unwrap(values);
+  } else if (el.tag === Portal) {
     renderer.arrange(el, el.props.root, values);
     return undefined;
   } else if (!el._node) {
     el._node = renderer.create(el);
   }

   renderer.patch(el, el._node);
   renderer.arrange(el, el._node, values);
   return el._node;
 }" data-lang="diff"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token coord">--- a/crank.js</span></code><br></div><div><code><span class="token coord">+++ b/crank.js</span></code><br></div><div><code>@@ -129,36 +129,45 @@ function diff(renderer, oldChild, newChild) {</code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">function update(renderer, el) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  if (el._isMounted) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    el = createElement(el, {...el.props});</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  const oldChildren = wrap(el._children);</span></span></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  const newChildren = wrap(el.props.children);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  let newChildren;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  if (typeof el.tag === &quot;function&quot;) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    newChildren = el.tag(el.props);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  } else {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    newChildren = el.props.children;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  newChildren = wrap(newChildren);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  const children = [];</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  const values = [];</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  const length = Math.max(oldChildren.length, newChildren.length);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  for (let i = 0; i &lt; length; i++) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    const oldChild = oldChildren[i];</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    const newChild = narrow(newChildren[i]);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    const [child, value] = diff(renderer, oldChild, newChild);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    children.push(child);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    if (value) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      values.push(value);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  el._children = unwrap(children);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  return commit(renderer, el, values);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">function commit(renderer, el, values) {</span></span></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  if (el.tag === Portal) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  if (typeof el.tag === &quot;function&quot;) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    return unwrap(values);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  } else if (el.tag === Portal) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    renderer.arrange(el, el.props.root, values);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    return undefined;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  } else if (!el._node) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    el._node = renderer.create(el);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  renderer.patch(el, el._node);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  renderer.arrange(el, el._node, values);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  return el._node;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div></pre></content-area></div></div><p><a href="https://github.com/brainkim/crank-from-scratch/commit/af10d458baf4f504eff9a0b821e05c4b5cebe2fd">Diff</a> <a href="https://github.com/brainkim/crank-from-scratch/blob/af10d458baf4f504eff9a0b821e05c4b5cebe2fd/crank.js">File</a></p><p>As you can see, implementing function components is relatively easy; when encountering tags which are functions, rather than recursing over the element’s <code class="inline">children</code> prop, we invoke the function with the element’s props and use the return value as the element’s children instead. This is why we will often refer to the return value of a function component as the component element’s “children.” As an additional note on terminology, we can now distinguish elements based on the type of their tag: we refer to elements with function tags as <em>component elements</em>, while we refer to elements which correspond to DOM nodes as <em>host elements</em>.</p><p>Using functions as tags meshes nicely with the element diffing algorithm, insofar as different functions are likely to produce different child structures.</p><h2>Step 4: Iterables and Fragments</h2><p>Here, we’ll take a slight detour in our implementation of components to handle iterables in the element tree. Crank allows any collection which implements the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols">iterable interface</a> to be rendered as well. To review, an <em>iterable</em> is any JavaScript object which implements a <code class="inline">[Symbol.iterator]()</code> method. This includes arrays, sets, and any other data structure which you can iterate over using a <code class="inline">for…of</code> statement.</p><p>Currently, our module converts these data structures to strings using their <code class="inline">toString</code> method, but what we really want is to diff and render their contents recursively.</p><div class="codeblock" data-code="const arr = [1, 2, 3];
const set = new Set([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]);
renderer.render(
  &lt;div&gt;{arr} {set}&lt;/div&gt;,
  app,
);

console.log(app.innerHTML);
// Expected: &quot;&lt;div&gt;123 abc&lt;/div&gt;&quot;
// Actual: &quot;&lt;div&gt;1,2,3 [object Set]&lt;/div&gt;&quot;" data-lang="jsx"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code><br></div><div><code><span class="token keyword">const</span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;c&quot;</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>renderer<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span></code><br></div><div><code>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>arr<span class="token punctuation">}</span> <span class="token punctuation">{</span>set<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span></code><br></div><div><code>  app<span class="token punctuation">,</span></code><br></div><div><code><span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code></code><br></div><div><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>app<span class="token punctuation">.</span>innerHTML<span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code><span class="token comment">// Expected: &quot;&lt;div&gt;123 abc&lt;/div&gt;&quot;</span></code><br></div><div><code><span class="token comment">// Actual: &quot;&lt;div&gt;1,2,3 [object Set]&lt;/div&gt;&quot;</span></code><br></div></pre></content-area></div></div><p>Iterables can appear anywhere in the element tree: as the child of a host element, as the return value of a component, or even nested in another iterable. Therefore, the easiest way to implement this feature is to treat every iterable we find in the element tree as though it were an element itself. To achieve this, we define a special element tag <code class="inline">Fragment</code>, and whenever we find an iterable, we wrap it in a <code class="inline">Fragment</code> element using a <code class="inline">createElement</code> call, with the iterable as the element’s children.</p><p>One added benefit of this approach is that we can use the <code class="inline">Fragment</code> tag directly, by referencing the tag like a component, or by using JSX’s special fragment syntax (<code class="inline">&lt;&gt;{children}&lt;/&gt;</code>) with the proper transpiler configuation.</p><div class="codeblock" data-code="// explicit reference
renderer.render(
  &lt;Fragment&gt;
    &lt;div&gt;1&lt;/div&gt;
    &lt;div&gt;2&lt;/div&gt;
  &lt;/Fragment&gt;,
  app,
);
console.log(document.body.innerHTML); // &quot;&lt;div&gt;1&lt;/div&gt;&lt;div&gt;2&lt;/div&gt;&quot;

// JSX fragment syntax
renderer.render(
  &lt;&gt;
    &lt;div&gt;1&lt;/div&gt;
    &lt;div&gt;2&lt;/div&gt;
  &lt;/&gt;,
  app,
);

console.log(document.body.innerHTML); // &quot;&lt;div&gt;1&lt;/div&gt;&lt;div&gt;2&lt;/div&gt;&quot;" data-lang="jsx"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token comment">// explicit reference</span></code><br></div><div><code>renderer<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span></code><br></div><div><code>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Fragment</span></span><span class="token punctuation">&gt;</span></span></code><br></div><div><code>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token number">1</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span></code><br></div><div><code>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token number">2</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span></code><br></div><div><code>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Fragment</span></span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span></code><br></div><div><code>  app<span class="token punctuation">,</span></code><br></div><div><code><span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>innerHTML<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;&lt;div&gt;1&lt;/div&gt;&lt;div&gt;2&lt;/div&gt;&quot;</span></code><br></div><div><code></code><br></div><div><code><span class="token comment">// JSX fragment syntax</span></code><br></div><div><code>renderer<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span></code><br></div><div><code>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span></span><span class="token punctuation">&gt;</span></span></code><br></div><div><code>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token number">1</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span></code><br></div><div><code>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token number">2</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span></code><br></div><div><code>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span></span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span></code><br></div><div><code>  app<span class="token punctuation">,</span></code><br></div><div><code><span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code></code><br></div><div><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>innerHTML<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;&lt;div&gt;1&lt;/div&gt;&lt;div&gt;2&lt;/div&gt;&quot;</span></code><br></div></pre></content-area></div></div><h3>Implementation</h3><div class="codeblock" data-code="--- a/crank.js
+++ b/crank.js
@@ -6,6 +6,14 @@ function unwrap(arr) {
   return arr.length &lt;= 1 ? arr[0] : arr;
 }

+function arrayify(value) {
+  return value == null
+    ? []
+    : typeof value !== &quot;string&quot; &amp;&amp; typeof value[Symbol.iterator] === &quot;function&quot;
+    ? Array.from(value)
+    : [value];
+}
+
 class Element {
   constructor(tag, props) {
     this.tag = tag;
@@ -21,6 +29,8 @@ class Element {

 export const Portal = Symbol.for(&quot;crank.Portal&quot;);

+export const Fragment = &quot;&quot;;
+
 export function createElement(tag, props, ...children) {
   props = Object.assign({}, props);
   if (children.length === 1) {
@@ -35,13 +45,55 @@ export function createElement(tag, props, ...children) {
 function narrow(value) {
   if (typeof value === &quot;boolean&quot; || value == null) {
     return undefined;
   } else if (typeof value === &quot;string&quot; || value instanceof Element) {
     return value;
+  } else if (typeof value[Symbol.iterator] === &quot;function&quot;) {
+    return createElement(Fragment, null, value);
   }

   return value.toString();
 }

+function normalize(values) {
+  const values1 = [];
+  let buffer;
+  for (const value of values) {
+    if (!value) {
+      // pass
+    } else if (typeof value === &quot;string&quot;) {
+      buffer = (buffer || &quot;&quot;) + value;
+    } else if (!Array.isArray(value)) {
+      if (buffer) {
+        values1.push(buffer);
+        buffer = undefined;
+      }
+
+      values1.push(value);
+    } else {
+      for (const value1 of value) {
+        if (!value1) {
+          // pass
+        } else if (typeof value1 === &quot;string&quot;) {
+          buffer = (buffer || &quot;&quot;) + value1;
+        } else {
+          if (buffer) {
+            values1.push(buffer);
+            buffer = undefined;
+          }
+
+          values1.push(value1);
+        }
+      }
+    }
+  }
+
+  if (buffer) {
+    values1.push(buffer);
+  }
+
+  return values1;
+}
+
 export class Renderer {
   constructor() {
     this._cache = new WeakMap();
@@ -129,45 +181,45 @@ function diff(renderer, oldChild, newChild) {
 function update(renderer, el) {
   if (el._isMounted) {
     el = createElement(el, {...el.props});
   }

   const oldChildren = wrap(el._children);
   let newChildren;
   if (typeof el.tag === &quot;function&quot;) {
     newChildren = el.tag(el.props);
   } else {
     newChildren = el.props.children;
   }

-  newChildren = wrap(newChildren);
+  newChildren = arrayify(newChildren);
   const children = [];
   const values = [];
   const length = Math.max(oldChildren.length, newChildren.length);
   for (let i = 0; i &lt; length; i++) {
     const oldChild = oldChildren[i];
-    const newChild = narrow(newChildren[i]);
+    let newChild = narrow(newChildren[i]);
     const [child, value] = diff(renderer, oldChild, newChild);
     children.push(child);
     if (value) {
       values.push(value);
     }
   }

   el._children = unwrap(children);
-  return commit(renderer, el, values);
+  return commit(renderer, el, normalize(values));
 }

 function commit(renderer, el, values) {
-  if (typeof el.tag === &quot;function&quot;) {
+  if (typeof el.tag === &quot;function&quot; || el.tag === Fragment) {
     return unwrap(values);
   } else if (el.tag === Portal) {
     renderer.arrange(el, el.props.root, values);
     return undefined;
   } else if (!el._node) {
     el._node = renderer.create(el);
   }

   renderer.patch(el, el._node);
   renderer.arrange(el, el._node, values);
   return el._node;
 }" data-lang="diff"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token coord">--- a/crank.js</span></code><br></div><div><code><span class="token coord">+++ b/crank.js</span></code><br></div><div><code>@@ -6,6 +6,14 @@ function unwrap(arr) {</code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  return arr.length &lt;= 1 ? arr[0] : arr;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">function arrayify(value) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  return value == null</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    ? []</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    : typeof value !== &quot;string&quot; &amp;&amp; typeof value[Symbol.iterator] === &quot;function&quot;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    ? Array.from(value)</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    : [value];</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">}</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">class Element {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  constructor(tag, props) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this.tag = tag;</span></span></code><br></div><div><code>@@ -21,6 +29,8 @@ class Element {</code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">export const Portal = Symbol.for(&quot;crank.Portal&quot;);</span></span></code><br></div><div><code></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">export const Fragment = &quot;&quot;;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">export function createElement(tag, props, ...children) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  props = Object.assign({}, props);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  if (children.length === 1) {</span></span></code><br></div><div><code>@@ -35,13 +45,55 @@ export function createElement(tag, props, ...children) {</code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">function narrow(value) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  if (typeof value === &quot;boolean&quot; || value == null) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    return undefined;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  } else if (typeof value === &quot;string&quot; || value instanceof Element) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    return value;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  } else if (typeof value[Symbol.iterator] === &quot;function&quot;) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    return createElement(Fragment, null, value);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  return value.toString();</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">function normalize(values) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  const values1 = [];</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  let buffer;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  for (const value of values) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    if (!value) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      // pass</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    } else if (typeof value === &quot;string&quot;) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      buffer = (buffer || &quot;&quot;) + value;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    } else if (!Array.isArray(value)) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      if (buffer) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        values1.push(buffer);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        buffer = undefined;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      values1.push(value);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    } else {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      for (const value1 of value) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        if (!value1) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">          // pass</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        } else if (typeof value1 === &quot;string&quot;) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">          buffer = (buffer || &quot;&quot;) + value1;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        } else {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">          if (buffer) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">            values1.push(buffer);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">            buffer = undefined;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">          }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">          values1.push(value1);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  if (buffer) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    values1.push(buffer);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  return values1;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">}</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">export class Renderer {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  constructor() {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._cache = new WeakMap();</span></span></code><br></div><div><code>@@ -129,45 +181,45 @@ function diff(renderer, oldChild, newChild) {</code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">function update(renderer, el) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  if (el._isMounted) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    el = createElement(el, {...el.props});</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  const oldChildren = wrap(el._children);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  let newChildren;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  if (typeof el.tag === &quot;function&quot;) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    newChildren = el.tag(el.props);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  } else {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    newChildren = el.props.children;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  newChildren = wrap(newChildren);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  newChildren = arrayify(newChildren);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  const children = [];</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  const values = [];</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  const length = Math.max(oldChildren.length, newChildren.length);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  for (let i = 0; i &lt; length; i++) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    const oldChild = oldChildren[i];</span></span></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    const newChild = narrow(newChildren[i]);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let newChild = narrow(newChildren[i]);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    const [child, value] = diff(renderer, oldChild, newChild);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    children.push(child);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    if (value) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      values.push(value);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  el._children = unwrap(children);</span></span></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  return commit(renderer, el, values);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  return commit(renderer, el, normalize(values));</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">function commit(renderer, el, values) {</span></span></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  if (typeof el.tag === &quot;function&quot;) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  if (typeof el.tag === &quot;function&quot; || el.tag === Fragment) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    return unwrap(values);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  } else if (el.tag === Portal) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    renderer.arrange(el, el.props.root, values);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    return undefined;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  } else if (!el._node) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    el._node = renderer.create(el);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  renderer.patch(el, el._node);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  renderer.arrange(el, el._node, values);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  return el._node;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div></pre></content-area></div></div><p><a href="https://github.com/brainkim/crank-from-scratch/commit/90091832ee9558d3eec5f8bbee566c55e82b3e41">Diff</a> <a href="https://github.com/brainkim/crank-from-scratch/blob/90091832ee9558d3eec5f8bbee566c55e82b3e41/crank.js">File</a></p><p>To implement fragments, we adjust the <code class="inline">narrow</code> function so that any time a non-string iterable is detected we wrap it in a <code class="inline">createElement</code> call. We need to be careful to exclude strings from our iterable detection logic. Strings are iterable but we don’t want to iterate over them because we would end up diffing each string found in the element tree character by character, which would be inefficient.</p><p><strong>Notes:</strong></p><ol><li>We define the helper function <code class="inline">normalize()</code>, which is similar to the DOM’s <a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/normalize"><code class="inline">Node.prototype.normalize()</code></a> method. It is called on the <code class="inline">values</code> array in the <code class="inline">update()</code> function, and will shallowly flatten the array, as well as concatenate adjacent strings and remove any <code class="inline">undefined</code> values. This is what allows arrays of values to be returned from the <code class="inline">update()</code> and <code class="inline">commit()</code> functions, as would happen in the case of <code class="inline">Fragment</code> elements. We only need to flatten the array shallowly because <code class="inline">normalize()</code> is called at each level of the element tree.</li><li>We also define another helper function <code class="inline">arrayify()</code>, which basically does the same thing as <code class="inline">wrap()</code> but handles iterables.</li><li>In Crank, the <code class="inline">Fragment</code> tag is actually just the empty string. I believe that every JSX framework/library could make their <code class="inline">Fragment</code> equivalent the empty string without any major changes to their codebase or API. The empty string makes the most sense as the default for JSX fragment syntax, and adopting this convention would lessen configuration overhead for developers.</li></ol><h2>Step 5: Generator Components</h2><p>We now have basic rendering and components, but components need to do more than just group parts of the element tree; nowadays, we expect any component abstraction to be able to encapsulate state, so that we can write components which respond to user input or timers, for instance.</p><p>In Crank, we use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*">generator functions</a> to write stateful components. As a quick review, generator functions are a separate function syntax which adds a star after the <code class="inline">function</code> keyword (<code class="inline">function *</code>). Inside a generator function, you can not only <em>return</em> values but also <em>yield</em> values as well using the <code class="inline">yield</code> operator.</p><div class="codeblock" data-code="function *fibonacci() {
  let current = 0, next = 1;
  while (true) {
    yield current;
    [current, next] = [next, current + next];
  }
}

const iter = fib();
// Nothing happens yet because we haven’t used the iterator.
const arr = [];
for (const n of iter) {
  if (n &gt; 30) {
    break;
  }
  arr.push(n);
}

console.log(arr); // [0, 1, 1, 2, 3, 5, 8, 13, 21]" data-lang="js"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token keyword">function</span> <span class="token operator">*</span><span class="token function">fibonacci</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>  <span class="token keyword">let</span> current <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> next <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></code><br></div><div><code>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>    <span class="token keyword">yield</span> current<span class="token punctuation">;</span></code><br></div><div><code>    <span class="token punctuation">[</span>current<span class="token punctuation">,</span> next<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>next<span class="token punctuation">,</span> current <span class="token operator">+</span> next<span class="token punctuation">]</span><span class="token punctuation">;</span></code><br></div><div><code>  <span class="token punctuation">}</span></code><br></div><div><code><span class="token punctuation">}</span></code><br></div><div><code></code><br></div><div><code><span class="token keyword">const</span> iter <span class="token operator">=</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code><span class="token comment">// Nothing happens yet because we haven’t used the iterator.</span></code><br></div><div><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code><br></div><div><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> n <span class="token keyword">of</span> iter<span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;</span> <span class="token number">30</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>    <span class="token keyword">break</span><span class="token punctuation">;</span></code><br></div><div><code>  <span class="token punctuation">}</span></code><br></div><div><code>  arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code><span class="token punctuation">}</span></code><br></div><div><code></code><br></div><div><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [0, 1, 1, 2, 3, 5, 8, 13, 21]</span></code><br></div></pre></content-area></div></div><p>This example, which defines and calls a <a href="https://en.wikipedia.org/wiki/Fibonacci_number">fibonacci number</a> generator function, demonstrates some important qualities of generator functions.</p><ol><li><p><strong>Generator functions execute lazily.</strong> Calling a generator function does not execute its body; rather, it returns a <em>generator object</em>. Until this object is somehow used, the generator function does not run.</p></li><li><p><strong>Generator functions can model infinite sequences.</strong> If we didn’t include the <code class="inline">break</code> statement in the loop over the generator object, this program would never terminate because the <code class="inline">fibonacci()</code> function never returns.</p></li><li><p><strong>Generator functions can hold internal state.</strong> The <code class="inline">current</code> and <code class="inline">next</code> variables are local to the generator function’s scope, and are preserved between iterations.</p></li></ol><p>Crank takes advantage of all three of these features by allowing components to be written as generator functions which <em>yield</em> element trees. By retaining generator objects just like we retained DOM nodes and children, we can preserve the local scope of the generator for component elements.</p><div class="codeblock" data-code="function *Counter() {
  let i = 0;
  while (true) {
    yield (
      &lt;div&gt;Rendered {i++} time(s)&lt;/div&gt;
    );
  }
}

renderer.render(&lt;Counter /&gt;, app);
renderer.render(&lt;Counter /&gt;, app);
renderer.render(&lt;Counter /&gt;, app);
console.log(app.innerHTML); // &lt;div&gt;Rendered 2 time(s)&lt;/div&gt;" data-lang="jsx"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token keyword">function</span> <span class="token operator">*</span><span class="token function">Counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>  <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></code><br></div><div><code>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>    <span class="token keyword">yield</span> <span class="token punctuation">(</span></code><br></div><div><code>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>Rendered <span class="token punctuation">{</span>i<span class="token operator">++</span><span class="token punctuation">}</span> <span class="token function">time</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span></code><br></div><div><code>    <span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>  <span class="token punctuation">}</span></code><br></div><div><code><span class="token punctuation">}</span></code><br></div><div><code></code><br></div><div><code>renderer<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Counter</span></span> <span class="token punctuation">/&gt;</span></span><span class="token punctuation">,</span> app<span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>renderer<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Counter</span></span> <span class="token punctuation">/&gt;</span></span><span class="token punctuation">,</span> app<span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>renderer<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Counter</span></span> <span class="token punctuation">/&gt;</span></span><span class="token punctuation">,</span> app<span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>app<span class="token punctuation">.</span>innerHTML<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &lt;div&gt;Rendered 2 time(s)&lt;/div&gt;</span></code><br></div></pre></content-area></div></div><h3>Iterables vs Iterators</h3><p>Before we dive into the code, we need to make a distinction between <em>iterables</em> and <em>iterators.</em> As explained previously, an iterable is any object which implements the <code class="inline">[Symbol.iterator]()</code> method. On the other hand, an <em>iterator</em> is any object which implements a <code class="inline">next()</code> method, and optionally <code class="inline">return()</code> and <code class="inline">throw()</code> methods. To conform to the iterator interface, these methods must return <em>iterations</em>, objects which have <code class="inline">value</code> and <code class="inline">done</code> properties, with <code class="inline">done</code> being a boolean which indicates whether the iterator has <em>returned</em>.</p><div class="codeblock" data-code="const iter = fibonacci();
console.log(iter.next()); // {value: 0, done: false}
console.log(iter.next()); // {value: 1, done: false}
console.log(iter.next()); // {value: 1, done: false}
console.log(iter.next()); // {value: 2, done: false}" data-lang="js"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token keyword">const</span> iter <span class="token operator">=</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {value: 0, done: false}</span></code><br></div><div><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {value: 1, done: false}</span></code><br></div><div><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {value: 1, done: false}</span></code><br></div><div><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {value: 2, done: false}</span></code><br></div></pre></content-area></div></div><p>Iterables and iterators are related in that the <code class="inline">[Symbol.iterator]()</code> method must return an iterator. This means that you can trivially make any iterator <em>iterable</em> by adding a <code class="inline">[Symbol.iterator]()</code> method to it which returns <code class="inline">this</code>. The <code class="inline">for…of</code> statement uses the <code class="inline">[Symbol.iterator]()</code> method under the hood, so the following two code snippets are roughly equivalent.</p><div class="codeblock" data-code="for (const n of fibonacci()) {
  if (n &gt; 30) {
    break;
  }

  console.log(n);
}

// is roughly equivalent to:

const iterator = fibonacci()[Symbol.iterator]();
let iteration = iterator.next();
try {
  while (!iteration.done) {
    const n = iteration.value;
    if (n &gt; 30) {
      break;
    }
    console.log(n);
  }
} finally {
  if (!iteration.done &amp;&amp; iterator.return) {
    iterator.return();
  }
}" data-lang="js"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> n <span class="token keyword">of</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;</span> <span class="token number">30</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>    <span class="token keyword">break</span><span class="token punctuation">;</span></code><br></div><div><code>  <span class="token punctuation">}</span></code><br></div><div><code></code><br></div><div><code>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code><span class="token punctuation">}</span></code><br></div><div><code></code><br></div><div><code><span class="token comment">// is roughly equivalent to:</span></code><br></div><div><code></code><br></div><div><code><span class="token keyword">const</span> iterator <span class="token operator">=</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code><span class="token keyword">let</span> iteration <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code><span class="token keyword">try</span> <span class="token punctuation">{</span></code><br></div><div><code>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>iteration<span class="token punctuation">.</span>done<span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>    <span class="token keyword">const</span> n <span class="token operator">=</span> iteration<span class="token punctuation">.</span>value<span class="token punctuation">;</span></code><br></div><div><code>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;</span> <span class="token number">30</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>      <span class="token keyword">break</span><span class="token punctuation">;</span></code><br></div><div><code>    <span class="token punctuation">}</span></code><br></div><div><code>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>  <span class="token punctuation">}</span></code><br></div><div><code><span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span></code><br></div><div><code>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>iteration<span class="token punctuation">.</span>done <span class="token operator">&amp;&amp;</span> iterator<span class="token punctuation">.</span>return<span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>    iterator<span class="token punctuation">.</span><span class="token function">return</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>  <span class="token punctuation">}</span></code><br></div><div><code><span class="token punctuation">}</span></code><br></div></pre></content-area></div></div><p>Generator objects implement both the iterable and iterator interfaces; in other words, generator objects are <em>iterable iterators.</em> This means you can both use generator objects in <code class="inline">for…of</code> loops, and also call the iterator methods directly. We’ll do the latter, because this approach is more flexible.</p><h3>Implementation</h3><div class="codeblock" data-code="--- a/crank.js
+++ b/crank.js
@@ -14,15 +14,20 @@ function arrayify(value) {
     : [value];
 }

+function isIteratorLike(value) {
+  return value != null &amp;&amp; typeof value.next === &quot;function&quot;;
+}
+
 class Element {
   constructor(tag, props) {
     this.tag = tag;
     this.props = props;

     this._node = undefined;
     this._children = undefined;
+    this._ctx = undefined;

     // flags
     this._isMounted = false;
   }
 }
@@ -181,30 +186,35 @@ function diff(renderer, oldChild, newChild) {
 function update(renderer, el) {
   if (el._isMounted) {
     el = createElement(el, {...el.props});
   }

-  const oldChildren = wrap(el._children);
-  let newChildren;
   if (typeof el.tag === &quot;function&quot;) {
-    newChildren = el.tag(el.props);
-  } else {
-    newChildren = el.props.children;
+    if (!el._ctx) {
+      el._ctx = new Context(renderer, el);
+    }
+
+    return updateCtx(el._ctx);
   }

+  return updateChildren(renderer, el, el.props.children);
+}
+
+function updateChildren(renderer, el, newChildren) {
+  const oldChildren = wrap(el._children);
   newChildren = arrayify(newChildren);
   const children = [];
   const values = [];
   const length = Math.max(oldChildren.length, newChildren.length);
   for (let i = 0; i &lt; length; i++) {
     const oldChild = oldChildren[i];
     let newChild = narrow(newChildren[i]);
     const [child, value] = diff(renderer, oldChild, newChild);
     children.push(child);
     if (value) {
       values.push(value);
     }
   }

   el._children = unwrap(children);
   return commit(renderer, el, normalize(values));
 }
@@ -223,3 +233,29 @@ function commit(renderer, el, values) {
   renderer.arrange(el, el._node, values);
   return el._node;
 }
+
+class Context {
+  constructor(renderer, el) {
+    this._renderer = renderer;
+    this._el = el;
+    this._iter = undefined;
+  }
+}
+
+function updateCtx(ctx) {
+  if (!ctx._iter) {
+    const value = ctx._el.tag(ctx._el.props);
+    if (isIteratorLike(value)) {
+      ctx._iter = value;
+    } else {
+      return updateCtxChildren(ctx, value);
+    }
+  }
+
+  const iteration = ctx._iter.next();
+  return updateCtxChildren(ctx, iteration.value);
+}
+
+function updateCtxChildren(ctx, children) {
+  return updateChildren(ctx._renderer, ctx._el, narrow(children));
+}" data-lang="diff"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token coord">--- a/crank.js</span></code><br></div><div><code><span class="token coord">+++ b/crank.js</span></code><br></div><div><code>@@ -14,15 +14,20 @@ function arrayify(value) {</code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    : [value];</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">function isIteratorLike(value) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  return value != null &amp;&amp; typeof value.next === &quot;function&quot;;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">}</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">class Element {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  constructor(tag, props) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this.tag = tag;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this.props = props;</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._node = undefined;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._children = undefined;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    this._ctx = undefined;</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    // flags</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._isMounted = false;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code>@@ -181,30 +186,35 @@ function diff(renderer, oldChild, newChild) {</code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">function update(renderer, el) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  if (el._isMounted) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    el = createElement(el, {...el.props});</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  const oldChildren = wrap(el._children);</span></span></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  let newChildren;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  if (typeof el.tag === &quot;function&quot;) {</span></span></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    newChildren = el.tag(el.props);</span></span></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  } else {</span></span></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    newChildren = el.props.children;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    if (!el._ctx) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      el._ctx = new Context(renderer, el);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    return updateCtx(el._ctx);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  return updateChildren(renderer, el, el.props.children);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">}</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">function updateChildren(renderer, el, newChildren) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  const oldChildren = wrap(el._children);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  newChildren = arrayify(newChildren);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  const children = [];</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  const values = [];</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  const length = Math.max(oldChildren.length, newChildren.length);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  for (let i = 0; i &lt; length; i++) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    const oldChild = oldChildren[i];</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    let newChild = narrow(newChildren[i]);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    const [child, value] = diff(renderer, oldChild, newChild);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    children.push(child);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    if (value) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      values.push(value);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  el._children = unwrap(children);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  return commit(renderer, el, normalize(values));</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code>@@ -223,3 +233,29 @@ function commit(renderer, el, values) {</code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  renderer.arrange(el, el._node, values);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  return el._node;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">class Context {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  constructor(renderer, el) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    this._renderer = renderer;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    this._el = el;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    this._iter = undefined;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">}</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">function updateCtx(ctx) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  if (!ctx._iter) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    const value = ctx._el.tag(ctx._el.props);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    if (isIteratorLike(value)) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      ctx._iter = value;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    } else {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      return updateCtxChildren(ctx, value);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  const iteration = ctx._iter.next();</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  return updateCtxChildren(ctx, iteration.value);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">}</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">function updateCtxChildren(ctx, children) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  return updateChildren(ctx._renderer, ctx._el, narrow(children));</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">}</span></span></code><br></div></pre></content-area></div></div><p><a href="https://github.com/brainkim/crank-from-scratch/commit/d89c229f2492817d26c6b96237bc5087c15bf5e9">Diff</a> <a href="https://github.com/brainkim/crank-from-scratch/blob/d89c229f2492817d26c6b96237bc5087c15bf5e9/crank.js">File</a></p><p>In this step, we’ve encapsulated the execution of components in a helper class called the <code class="inline">Context</code>. This will be where we store all state which is required to execute component functions from now on. So far, we’ve stored the renderer, the element, and any iterator returned by the component, directly on this context class.</p><p>We could also try to retain this state directly on component <em>elements</em>, but by storing them on contexts, we indirectly reduce the size of elements themselves. In a typical application, the number of host elements might exceed the number of component elements by 10:1, so it makes sense to put component-specific data in its own abstraction.</p><p>To detect generator components, we check that the return value of the component is “iterator-like,” which just means that it is an object which defines a <code class="inline">next()</code> method. Although generators are both iterators and iterable, we check for the iterator interface, because, as explained previously, we interpret iterables as fragments wherever they appear in the element tree. If we determined any component which returns an <em>iterable</em> was also a generator component, we would get suprising behavior where the following component renders the strings <code class="inline">&quot;a&quot;</code>, <code class="inline">&quot;b&quot;</code> and <code class="inline">&quot;c&quot;</code> in successive renders, rather than all at once as siblings.</p><div class="codeblock" data-code="function Component() {
  return [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];
}" data-lang="jsx"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>  <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;c&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code><br></div><div><code><span class="token punctuation">}</span></code><br></div></pre></content-area></div></div><p>While there may be ways to distinguish generator functions from normal functions without calling them, doing so is an anti-pattern because it precludes components which return generator objects from being generator components. This theme of inspecting the return values of component functions to determine their type will continue as we implement more component types.</p><p><strong>Notes:</strong></p><ol><li>We divided the <code class="inline">update()</code> function into <code class="inline">update()</code> and <code class="inline">updateChildren()</code>, and created analogous functions <code class="inline">updateCtx()</code> and <code class="inline">updateCtxChildren()</code> for component contexts. These functions use the “private method” pattern described previously. The <code class="inline">updateCtxChildren()</code> function is primarily used so that we can wrap yielded/returned children in a <code class="inline">narrow()</code> call for diffing purposes.</li></ol><h2>Step 6: Refreshing</h2><p>We now have stateful components via generators, but these generator functions only rerender based on top-level <code class="inline">render()</code> calls. To write interactive components, we need a way for components to rerender themselves. In Crank, we pass in the context object we created in the previous step as the <code class="inline">this</code> value of component functions, and implement a <code class="inline">refresh()</code> method on it which re-executes the component. This allows us to write components like the following.</p><div class="codeblock" data-code="function *Counter() {
  let i = 0;
  const onclick = () =&gt; {
    i++;
    this.refresh();
  };

  while (true) {
    yield (
      &lt;button onclick={onclick}&gt;
        Button pressed {i} time(s).
      &lt;/button&gt;
    );
  }
}" data-lang="jsx"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token keyword">function</span> <span class="token operator">*</span><span class="token function">Counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>  <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></code><br></div><div><code>  <span class="token keyword">const</span> <span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></code><br></div><div><code>    i<span class="token operator">++</span><span class="token punctuation">;</span></code><br></div><div><code>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>  <span class="token punctuation">}</span><span class="token punctuation">;</span></code><br></div><div><code></code><br></div><div><code>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>    <span class="token keyword">yield</span> <span class="token punctuation">(</span></code><br></div><div><code>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onclick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>onclick<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span></code><br></div><div><code>        Button pressed <span class="token punctuation">{</span>i<span class="token punctuation">}</span> <span class="token function">time</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">.</span></code><br></div><div><code>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span></code><br></div><div><code>    <span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>  <span class="token punctuation">}</span></code><br></div><div><code><span class="token punctuation">}</span></code><br></div></pre></content-area></div></div><p>We’ve already implemented basic event handling thanks to the DOM’s <a href="https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Event_handlers"><code class="inline">onevent</code> handlers</a> and the logic in the renderer’s <code class="inline">patch()</code> method, so all we need to do is pass the context in as <code class="inline">this</code> using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call"><code class="inline">Function.prototype.call</code></a> and implement the <code class="inline">refresh()</code> method on the context class.</p><h3>Implementation</h3><div class="codeblock" data-code="--- a/crank.js
+++ b/crank.js
@@ -237,21 +237,25 @@ function commit(renderer, el, values) {
 class Context {
   constructor(renderer, el) {
     this._renderer = renderer;
     this._el = el;
     this._iter = undefined;
   }
+
+  refresh() {
+    return updateCtx(this);
+  }
 }

 function updateCtx(ctx) {
   if (!ctx._iter) {
-    const value = ctx._el.tag(ctx._el.props);
+    const value = ctx._el.tag.call(ctx, ctx._el.props);
     if (isIteratorLike(value)) {
       ctx._iter = value;
     } else {
       return updateCtxChildren(ctx, value);
     }
   }

   const iteration = ctx._iter.next();
   return updateCtxChildren(ctx, iteration.value);
 }" data-lang="diff"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token coord">--- a/crank.js</span></code><br></div><div><code><span class="token coord">+++ b/crank.js</span></code><br></div><div><code>@@ -237,21 +237,25 @@ function commit(renderer, el, values) {</code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">class Context {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  constructor(renderer, el) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._renderer = renderer;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._el = el;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._iter = undefined;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  refresh() {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    return updateCtx(this);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">function updateCtx(ctx) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  if (!ctx._iter) {</span></span></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    const value = ctx._el.tag(ctx._el.props);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    const value = ctx._el.tag.call(ctx, ctx._el.props);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    if (isIteratorLike(value)) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      ctx._iter = value;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    } else {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      return updateCtxChildren(ctx, value);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  const iteration = ctx._iter.next();</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  return updateCtxChildren(ctx, iteration.value);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div></pre></content-area></div></div><p><a href="https://github.com/brainkim/crank-from-scratch/commit/cfd60c84ebd38549d3bbf4829c28c0e8f96847ec">Diff</a> <a href="https://github.com/brainkim/crank-from-scratch/blob/cfd60c84ebd38549d3bbf4829c28c0e8f96847ec/crank.js">File</a></p><p>After Crank’s release, multiple people objected to this unusual usage of <code class="inline">this</code>. As an alternative to using <code class="inline">this</code>, some suggested passing the context in directly as a parameter. There are many reasons why I think using <code class="inline">this</code> is the best choice for component API design, and I’ll outline a few of them here.</p><ol><li><p><strong>Using <code class="inline">this</code> makes it harder for developers to call components directly.</strong> As we’ve seen so far, components can either return children or an iterator which yields children. Because both these cases need to be handled, we need to take care to make sure that people don’t call components directly. Additionally, direct calls of components is an anti-pattern even if you know the component is a regular function which returns elements, because as we’ve learned, we use the functions themselves to identify subtrees for our diffing algorithm. Passing contexts in as <code class="inline">this</code> is a natural barrier which prevents developers from attempting to call components directly, insofar as you would need to use the <code class="inline">Function.prototype.call()</code> method.</p></li><li><p><strong>Using <code class="inline">this</code> makes it harder for developers to destructure the context.</strong> If we passed the context in as a parameter, there would always be a chance for developers to destructure the context parameter just as they destructured props.</p><div class="codeblock" data-code="// Destructuring the proposed context parameter.
function *MyComponent({myProp}, {refresh}) {
  /* … */
  const onclick = () =&gt; {
    /* … */
    refresh();
  };
  /* … */
}" data-lang="jsx"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token comment">// Destructuring the proposed context parameter.</span></code><br></div><div><code><span class="token keyword">function</span> <span class="token operator">*</span><span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>myProp<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>refresh<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>  <span class="token comment">/* … */</span></code><br></div><div><code>  <span class="token keyword">const</span> <span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></code><br></div><div><code>    <span class="token comment">/* … */</span></code><br></div><div><code>    <span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>  <span class="token punctuation">}</span><span class="token punctuation">;</span></code><br></div><div><code>  <span class="token comment">/* … */</span></code><br></div><div><code><span class="token punctuation">}</span></code><br></div></pre></content-area></div></div><p>To make this example work, we would either need to eagerly bind the <code class="inline">refresh()</code> method to the context, or alternatively define the <code class="inline">refresh()</code> method as a function which references the context in a closure. In either case, we would need to create a unique <code class="inline">refresh()</code> function for every component instance, which would increase the memory requirements for each component. Even worse, this would have to be done for every single method we wanted to define on the context. Insofar as destructuring <code class="inline">this</code> would require an extra line of code, its usage again provides a natural barrier which prevents developers from destructuring contexts and inadvertently losing method receivers.</p></li><li><p><strong>Components are a special construct which are somewhere between a class and a function.</strong> While all components in Crank are defined with functions, we need a way to define “instance” methods and properties like <code class="inline">refresh()</code> and have them available within component declarations. I like to reference <a href="https://twitter.com/dan_abramov/status/1093694465917751298">this tweet thread</a> by React maintainer Dan Abramov, about components as an abstraction. He writes:</p><blockquote>React is traditionally described either in FP terms (pure functions) or in OOP terms (stateful classes). Both are only approximations … Why are these models insufficient to describe React? “Pure function” model doesn’t describe local state which is an essential React feature. “Class” model doesn’t explain pure-ish render, disawoving inheritance, lack of direct instantiation, and “receiving” props …What is a component? … It’s a thing of its own. A stateful function with effects. Your language just doesn’t have a primitive to express it.</blockquote><p>Abramov goes on to use this observation to justify React hooks, whereas of course, I would use the same line of reasoning to justify the usage of generator functions. Nevertheless, I think the observations he makes are valid, and that neither functions nor classes alone fully capture what we want from a component abstraction.</p><p>Calling component functions with <code class="inline">this</code> set to a framework-provided context object is a great way to model this half-function, half-class quality of components. It provides both the convenience of inheritance and the terseness of function declarations, and captures the uniqueness of component abstractions in a way which is still “just JavaScript.”</p></li></ol><p>There are of course other reasons for and against using the <code class="inline">this</code> value as the context in components. At its root, I believe most arguments <em>against</em> using <code class="inline">this</code> are driven by a desire to define all functions as top-level arrow function assignments (<code class="inline">const MyComponent = (props) =&gt; </code>). While I don’t think I’ll be able to convince people of the benefit of one or the other style of coding in the general case, hopefully I’ve convinced you as to why using <code class="inline">this</code> like we do in Crank might make sense for a component framework.</p><p>A second controversial design decison was the usage of explicit <code class="inline">refresh()</code> calls rather than some kind of “reactive”  <code class="inline">setState()</code>- or proxy-based system. I will probably write another essay at some point explaining why I think explicit, opt-in rerendering is preferable to any other system for a component framework, but for now, note that it’s easier to implement: the <code class="inline">refresh()</code> method is currently a one-liner!</p><h2>Step 7: Rearranging</h2><p>Our generator components have a subtle bug which we need to fix before continuing. Components which render different roots on refresh will not rerender. For instance, the following component should cycle rendering <code class="inline">h1</code> through <code class="inline">h6</code> elements when clicked.</p><div class="codeblock" data-code="function *CyclingHeader({name}) {
  let i = 0;
  const onclick = () =&gt; {
    i = (i + 1) % 6;
    this.refresh();
  };

  while (true) {
    const Header = `h${i + 1}`;
    yield (
      &lt;Header onclick={onclick}&gt;Heading level {i + 1}&lt;/Header&gt;
    );
  }
}

renderer.render(
  &lt;div&gt;
    &lt;CyclingHeader /&gt;
  &lt;/div&gt;,
  app,
);

app.firstChild.click();
app.firstChild.click();
console.log(app.innerHTML);
// Expected: &lt;div&gt;&lt;h3&gt;Heading level 3&lt;/h3&gt;&lt;/div&gt;
// Actual:   &lt;div&gt;&lt;h1&gt;Heading level 1&lt;/h1&gt;&lt;/div&gt;" data-lang="jsx"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token keyword">function</span> <span class="token operator">*</span><span class="token function">CyclingHeader</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>name<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>  <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></code><br></div><div><code>  <span class="token keyword">const</span> <span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></code><br></div><div><code>    i <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">6</span><span class="token punctuation">;</span></code><br></div><div><code>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>  <span class="token punctuation">}</span><span class="token punctuation">;</span></code><br></div><div><code></code><br></div><div><code>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>    <span class="token keyword">const</span> Header <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">h</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span></code><br></div><div><code>    <span class="token keyword">yield</span> <span class="token punctuation">(</span></code><br></div><div><code>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Header</span></span> <span class="token attr-name">onclick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>onclick<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span>Heading level <span class="token punctuation">{</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Header</span></span><span class="token punctuation">&gt;</span></span></code><br></div><div><code>    <span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>  <span class="token punctuation">}</span></code><br></div><div><code><span class="token punctuation">}</span></code><br></div><div><code></code><br></div><div><code>renderer<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span></code><br></div><div><code>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span></code><br></div><div><code>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">CyclingHeader</span></span> <span class="token punctuation">/&gt;</span></span></code><br></div><div><code>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span></code><br></div><div><code>  app<span class="token punctuation">,</span></code><br></div><div><code><span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code></code><br></div><div><code>app<span class="token punctuation">.</span>firstChild<span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>app<span class="token punctuation">.</span>firstChild<span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>app<span class="token punctuation">.</span>innerHTML<span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code><span class="token comment">// Expected: &lt;div&gt;&lt;h3&gt;Heading level 3&lt;/h3&gt;&lt;/div&gt;</span></code><br></div><div><code><span class="token comment">// Actual:   &lt;div&gt;&lt;h1&gt;Heading level 1&lt;/h1&gt;&lt;/div&gt;</span></code><br></div></pre></content-area></div></div><p>If you run this component, you’ll notice that clicking on the header doesn’t actually do anything. The problem is that we haven’t called the <code class="inline">arrange()</code> method on the component’s <em>nearest ancestor host element.</em> We can confirm that this is the cause of the bug by wrapping the component’s yield value in an extra <code class="inline">div</code> element. In that case, rendering would work correctly because <code class="inline">arrange()</code> is called on all of a component’s children for each refresh.</p><h3>Implementation</h3><div class="codeblock" data-code="--- a/crank.js
+++ b/crank.js
@@ -99,167 +99,216 @@ function normalize(values) {
   return values1;
 }

+function getValue(el) {
+  if (el.tag === Portal) {
+    return undefined;
+  } else if (typeof el.tag !== &quot;function&quot; &amp;&amp; el.tag !== Fragment) {
+    return el._node;
+  }
+
+  return unwrap(getChildValues(el));
+}
+
+function getChildValues(el) {
+  const values = [];
+  for (const child of wrap(el._children)) {
+    if (typeof child === &quot;string&quot;) {
+      values.push(child);
+    } else if (typeof child !== &quot;undefined&quot;) {
+      values.push(getValue(child));
+    }
+  }
+
+  return normalize(values);
+}
+
 export class Renderer {
   constructor() {
     this._cache = new WeakMap();
   }

   render(children, root) {
     let portal = this._cache.get(root);
     if (portal) {
       portal.props = {root, children};
     } else {
       portal = createElement(Portal, {root, children});
       this._cache.set(root, portal);
     }

-    return update(this, portal);
+    return update(this, portal, portal);
   }

   create(el) {
     return document.createElement(el.tag);
   }

   patch(el, node) {
     for (let [name, value] of Object.entries(el.props)) {
       if (name === &quot;children&quot;) {
         continue;
       } else if (name === &quot;class&quot;) {
         name = &quot;className&quot;;
       }

       if (name in node) {
         node[name] = value;
       } else {
         node.setAttribute(name, value);
       }
     }
   }

   arrange(el, node, children) {
     let child = node.firstChild;
     for (const newChild of children) {
       if (child === newChild) {
         child = child.nextSibling;
       } else if (typeof newChild === &quot;string&quot;) {
         if (child !== null &amp;&amp; child.nodeType === Node.TEXT_NODE) {
           child.nodeValue = newChild;
           child = child.nextSibling;
         } else {
           node.insertBefore(document.createTextNode(newChild), child);
         }
       } else {
         node.insertBefore(newChild, child);
       }
     }

     while (child !== null) {
       const nextSibling = child.nextSibling;
       node.removeChild(child);
       child = child.nextSibling;
     }
   }
 }

-function diff(renderer, oldChild, newChild) {
+function diff(renderer, host, oldChild, newChild) {
   if (
     oldChild instanceof Element &amp;&amp;
     newChild instanceof Element &amp;&amp;
     oldChild.tag === newChild.tag
   ) {
     if (oldChild !== newChild) {
       oldChild.props = newChild.props;
       newChild = oldChild;
     }
   }

   let value;
   if (newChild instanceof Element) {
-    value = update(renderer, newChild);
+    value = update(renderer, host, newChild);
   } else {
     value = newChild;
   }

   return [newChild, value];
 }

-function update(renderer, el) {
+function update(renderer, host, el) {
   if (el._isMounted) {
     el = createElement(el, {...el.props});
   }

   if (typeof el.tag === &quot;function&quot;) {
     if (!el._ctx) {
-      el._ctx = new Context(renderer, el);
+      el._ctx = new Context(renderer, host, el);
     }

     return updateCtx(el._ctx);
+  } else if (el.tag !== Fragment) {
+    host = el;
   }

-  return updateChildren(renderer, el, el.props.children);
+  return updateChildren(renderer, host, el, el.props.children);
 }

-function updateChildren(renderer, el, newChildren) {
+function updateChildren(renderer, host, el, newChildren) {
   const oldChildren = wrap(el._children);
   newChildren = arrayify(newChildren);
   const children = [];
   const values = [];
   const length = Math.max(oldChildren.length, newChildren.length);
   for (let i = 0; i &lt; length; i++) {
     const oldChild = oldChildren[i];
     let newChild = narrow(newChildren[i]);
-    const [child, value] = diff(renderer, oldChild, newChild);
+    const [child, value] = diff(renderer, host, oldChild, newChild);
     children.push(child);
     if (value) {
       values.push(value);
     }
   }

   el._children = unwrap(children);
   return commit(renderer, el, normalize(values));
 }

 function commit(renderer, el, values) {
-  if (typeof el.tag === &quot;function&quot; || el.tag === Fragment) {
+  if (typeof el.tag === &quot;function&quot;) {
+    return commitCtx(el._ctx, values);
+  } else if (el.tag === Fragment) {
     return unwrap(values);
   } else if (el.tag === Portal) {
     renderer.arrange(el, el.props.root, values);
     return undefined;
   } else if (!el._node) {
     el._node = renderer.create(el);
   }

   renderer.patch(el, el._node);
   renderer.arrange(el, el._node, values);
   return el._node;
 }

 class Context {
-  constructor(renderer, el) {
+  constructor(renderer, host, el) {
     this._renderer = renderer;
+    this._host = host;
     this._el = el;
     this._iter = undefined;
+
+    // flags
+    this._isUpdating = false;
   }

   refresh() {
-    return updateCtx(this);
+    return stepCtx(this);
   }
 }

-function updateCtx(ctx) {
+function stepCtx(ctx) {
   if (!ctx._iter) {
     const value = ctx._el.tag.call(ctx, ctx._el.props);
     if (isIteratorLike(value)) {
       ctx._iter = value;
     } else {
       return updateCtxChildren(ctx, value);
     }
   }

   const iteration = ctx._iter.next();
   return updateCtxChildren(ctx, iteration.value);
 }

+function updateCtx(ctx) {
+  ctx._isUpdating = true;
+  return stepCtx(ctx);
+}
+
 function updateCtxChildren(ctx, children) {
-  return updateChildren(ctx._renderer, ctx._el, narrow(children));
+  return updateChildren(ctx._renderer, ctx._host, ctx._el, narrow(children));
+}
+
+function commitCtx(ctx, values) {
+  if (!ctx._isUpdating) {
+    ctx._renderer.arrange(
+      ctx._host,
+      ctx._host.tag === Portal ? ctx._host.props.root : ctx._host._node,
+      getChildValues(ctx._host),
+    );
+  }
+
+  ctx._isUpdating = false;
+  return unwrap(values);
 }" data-lang="diff"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token coord">--- a/crank.js</span></code><br></div><div><code><span class="token coord">+++ b/crank.js</span></code><br></div><div><code>@@ -99,167 +99,216 @@ function normalize(values) {</code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  return values1;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">function getValue(el) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  if (el.tag === Portal) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    return undefined;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  } else if (typeof el.tag !== &quot;function&quot; &amp;&amp; el.tag !== Fragment) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    return el._node;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  return unwrap(getChildValues(el));</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">}</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">function getChildValues(el) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  const values = [];</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  for (const child of wrap(el._children)) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    if (typeof child === &quot;string&quot;) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      values.push(child);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    } else if (typeof child !== &quot;undefined&quot;) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      values.push(getValue(child));</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  return normalize(values);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">}</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">export class Renderer {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  constructor() {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._cache = new WeakMap();</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  render(children, root) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    let portal = this._cache.get(root);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    if (portal) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      portal.props = {root, children};</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    } else {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      portal = createElement(Portal, {root, children});</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      this._cache.set(root, portal);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    return update(this, portal);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    return update(this, portal, portal);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  create(el) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    return document.createElement(el.tag);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  patch(el, node) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    for (let [name, value] of Object.entries(el.props)) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      if (name === &quot;children&quot;) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        continue;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      } else if (name === &quot;class&quot;) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        name = &quot;className&quot;;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      if (name in node) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        node[name] = value;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      } else {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        node.setAttribute(name, value);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  arrange(el, node, children) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    let child = node.firstChild;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    for (const newChild of children) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      if (child === newChild) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        child = child.nextSibling;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      } else if (typeof newChild === &quot;string&quot;) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        if (child !== null &amp;&amp; child.nodeType === Node.TEXT_NODE) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">          child.nodeValue = newChild;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">          child = child.nextSibling;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        } else {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">          node.insertBefore(document.createTextNode(newChild), child);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      } else {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        node.insertBefore(newChild, child);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    while (child !== null) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      const nextSibling = child.nextSibling;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      node.removeChild(child);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      child = child.nextSibling;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">function diff(renderer, oldChild, newChild) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">function diff(renderer, host, oldChild, newChild) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  if (</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    oldChild instanceof Element &amp;&amp;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    newChild instanceof Element &amp;&amp;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    oldChild.tag === newChild.tag</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  ) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    if (oldChild !== newChild) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      oldChild.props = newChild.props;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      newChild = oldChild;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  let value;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  if (newChild instanceof Element) {</span></span></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    value = update(renderer, newChild);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    value = update(renderer, host, newChild);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  } else {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    value = newChild;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  return [newChild, value];</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">function update(renderer, el) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">function update(renderer, host, el) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  if (el._isMounted) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    el = createElement(el, {...el.props});</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  if (typeof el.tag === &quot;function&quot;) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    if (!el._ctx) {</span></span></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">      el._ctx = new Context(renderer, el);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      el._ctx = new Context(renderer, host, el);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    return updateCtx(el._ctx);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  } else if (el.tag !== Fragment) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    host = el;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  return updateChildren(renderer, el, el.props.children);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  return updateChildren(renderer, host, el, el.props.children);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">function updateChildren(renderer, el, newChildren) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">function updateChildren(renderer, host, el, newChildren) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  const oldChildren = wrap(el._children);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  newChildren = arrayify(newChildren);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  const children = [];</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  const values = [];</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  const length = Math.max(oldChildren.length, newChildren.length);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  for (let i = 0; i &lt; length; i++) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    const oldChild = oldChildren[i];</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    let newChild = narrow(newChildren[i]);</span></span></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    const [child, value] = diff(renderer, oldChild, newChild);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    const [child, value] = diff(renderer, host, oldChild, newChild);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    children.push(child);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    if (value) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      values.push(value);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  el._children = unwrap(children);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  return commit(renderer, el, normalize(values));</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">function commit(renderer, el, values) {</span></span></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  if (typeof el.tag === &quot;function&quot; || el.tag === Fragment) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  if (typeof el.tag === &quot;function&quot;) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    return commitCtx(el._ctx, values);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  } else if (el.tag === Fragment) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    return unwrap(values);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  } else if (el.tag === Portal) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    renderer.arrange(el, el.props.root, values);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    return undefined;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  } else if (!el._node) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    el._node = renderer.create(el);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  renderer.patch(el, el._node);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  renderer.arrange(el, el._node, values);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  return el._node;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">class Context {</span></span></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  constructor(renderer, el) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  constructor(renderer, host, el) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._renderer = renderer;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    this._host = host;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._el = el;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._iter = undefined;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    // flags</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    this._isUpdating = false;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  refresh() {</span></span></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    return updateCtx(this);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    return stepCtx(this);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">function updateCtx(ctx) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">function stepCtx(ctx) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  if (!ctx._iter) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    const value = ctx._el.tag.call(ctx, ctx._el.props);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    if (isIteratorLike(value)) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      ctx._iter = value;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    } else {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      return updateCtxChildren(ctx, value);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  const iteration = ctx._iter.next();</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  return updateCtxChildren(ctx, iteration.value);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">function updateCtx(ctx) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  ctx._isUpdating = true;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  return stepCtx(ctx);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">}</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">function updateCtxChildren(ctx, children) {</span></span></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  return updateChildren(ctx._renderer, ctx._el, narrow(children));</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  return updateChildren(ctx._renderer, ctx._host, ctx._el, narrow(children));</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">}</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">function commitCtx(ctx, values) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  if (!ctx._isUpdating) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    ctx._renderer.arrange(</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      ctx._host,</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      ctx._host.tag === Portal ? ctx._host.props.root : ctx._host._node,</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      getChildValues(ctx._host),</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    );</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  ctx._isUpdating = false;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  return unwrap(values);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div></pre></content-area></div></div><p><a href="https://github.com/brainkim/crank-from-scratch/commit/ce8a6b8a6cbc55e04b761b556c6e10f084fbc555">Diff</a> <a href="https://github.com/brainkim/crank-from-scratch/blob/ce8a6b8a6cbc55e04b761b556c6e10f084fbc555/crank.js">File</a></p><p>This diff is larger because we have to adjust the signatures of many of the recursive renderer functions we’ve defined, adding a parameter for the current host element and passing it down the tree. With this data available, we can now retain it on component contexts, so that it can be accessed by context methods and functions. We also add an <code class="inline">_isUpdating</code> boolean flag to contexts, to help us determine whether a component is being updated by a parent or doing a self-initiated refresh. Finally, we create a <code class="inline">commitCtx()</code> function, analogous to the <code class="inline">commit()</code> renderer function, which calls <code class="inline">arrange()</code> on a component’s nearest ancestor host element if the component is detected as refreshing.</p><p><strong>Notes:</strong></p><ol><li><p>We’ve added the utility functions <code class="inline">getValue()</code> and <code class="inline">getChildValues()</code>. These mutually recursive functions traverse the element tree and find an element’s <em>value</em> or <em>child values</em>. The “value” of an element varies based on its tag; a host element’s value is just the DOM node which we created for it, while a component or fragment element’s value can be <code class="inline">undefined</code>, a string, a DOM node, or array of strings and DOM nodes, depending on the element’s children.</p><p>We were previously using the return values of the <code class="inline">update()</code> and <code class="inline">commit()</code> functions to pass element values upwards, but when we rearrange a host element, we don’t have access to the host element’s child values, because that host element may have other children besides the component which is refreshing. Therefore, we use <code class="inline">getChildValues</code> to compute a host element’s child values on the fly when rearranging to save on memory.</p></li><li><p>We’ve moved most of the logic in the <code class="inline">updateCtx()</code> function to the <code class="inline">stepCtx()</code> function. Both <code class="inline">updateCtx()</code> and the <code class="inline">refresh()</code> method call <code class="inline">stepCtx()</code> , but only <code class="inline">updateCtx()</code> sets the <code class="inline">_isUpdating</code> flag. We could also have named the flag “_isRefreshing” and set it in the <code class="inline">refresh()</code> method, but setting the flag by updates is more convenient for when we deal with concurrent async rendering situations later on.</p></li></ol><h2>Step 8: Returning and Unmounting</h2><p>One of the coolest features of generator functions is that they can be closed at both ends: internally, a return statement may be placed in the generator’s body to end its iteration, and externally, the iterator method <code class="inline">return()</code> can be called on the generator object.</p><p>To review, the <code class="inline">return()</code> method will close a generator execution by replacing the currently suspended <code class="inline">yield</code> with a <code class="inline">return</code> operation. This means that any loops the generator was in would be broken out of, and code which would normally execute after the <code class="inline">yield</code> would never execute.</p><p>We can take advantage of the <code class="inline">return()</code> method by calling it on component iterators when their corresponding elements are removed from the element tree. This in turn allows developers to write cleanup code by wrapping <code class="inline">yield</code> operations in a <code class="inline">try</code>/<code class="inline">finally</code>-statement, as in the following component.</p><div class="codeblock" data-code="function *Timer() {
  let seconds = 0;
  const interval = setInterval(() =&gt; {
    seconds++;
    this.refresh();
  }, 1000);
  try {
    while (true) {
      yield &lt;div&gt;Seconds: {seconds}&lt;/div&gt;;
    }
  } finally {
    clearInterval(interval);
  }
}" data-lang="jsx"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token keyword">function</span> <span class="token operator">*</span><span class="token function">Timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>  <span class="token keyword">let</span> seconds <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></code><br></div><div><code>  <span class="token keyword">const</span> interval <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></code><br></div><div><code>    seconds<span class="token operator">++</span><span class="token punctuation">;</span></code><br></div><div><code>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>  <span class="token keyword">try</span> <span class="token punctuation">{</span></code><br></div><div><code>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>      <span class="token keyword">yield</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>Seconds<span class="token operator">:</span> <span class="token punctuation">{</span>seconds<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span></code><br></div><div><code>    <span class="token punctuation">}</span></code><br></div><div><code>  <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span></code><br></div><div><code>    <span class="token function">clearInterval</span><span class="token punctuation">(</span>interval<span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>  <span class="token punctuation">}</span></code><br></div><div><code><span class="token punctuation">}</span></code><br></div></pre></content-area></div></div><p>Currently, the <code class="inline">clearInterval()</code> call will never be reached, and would cause a memory leak if the component were rendered and removed multiple times.</p><h3>Implementation</h3><div class="codeblock" data-code="--- a/crank.js
+++ b/crank.js
@@ -227,20 +227,30 @@ function update(renderer, host, el) {
 function updateChildren(renderer, host, el, newChildren) {
   const oldChildren = wrap(el._children);
   newChildren = arrayify(newChildren);
   const children = [];
   const values = [];
   const length = Math.max(oldChildren.length, newChildren.length);
   for (let i = 0; i &lt; length; i++) {
     const oldChild = oldChildren[i];
     let newChild = narrow(newChildren[i]);
     const [child, value] = diff(renderer, host, oldChild, newChild);
+    if (oldChild instanceof Element &amp;&amp; child !== oldChild) {
+      unmount(renderer, oldChild);
+    }
+
     children.push(child);
     if (value) {
       values.push(value);
     }
   }

   el._children = unwrap(children);
+  for (const oldChild of oldChildren.slice(length)) {
+    if (oldChild instanceof Element) {
+      unmount(renderer, oldChild);
+    }
+  }
+
   return commit(renderer, el, normalize(values));
 }

@@ -261,33 +271,52 @@ function commit(renderer, el, values) {
   return el._node;
 }

+function unmount(renderer, el) {
+  if (typeof el.tag === &quot;function&quot;) {
+    unmountCtx(el._ctx);
+  }
+
+  for (const child of wrap(el._children)) {
+    if (child instanceof Element) {
+      unmount(renderer, child);
+    }
+  }
+}
+
 class Context {
   constructor(renderer, host, el) {
     this._renderer = renderer;
     this._host = host;
     this._el = el;
     this._iter = undefined;

     // flags
     this._isUpdating = false;
+    this._isDone = false;
   }

   refresh() {
     return stepCtx(this);
   }
 }

 function stepCtx(ctx) {
-  if (!ctx._iter) {
+  if (ctx._isDone) {
+    return getValue(ctx._el);
+  } else if (!ctx._iter) {
     const value = ctx._el.tag.call(ctx, ctx._el.props);
     if (isIteratorLike(value)) {
       ctx._iter = value;
     } else {
       return updateCtxChildren(ctx, value);
     }
   }

   const iteration = ctx._iter.next();
+  if (iteration.done) {
+    ctx._isDone = true;
+  }
+
   return updateCtxChildren(ctx, iteration.value);
 }

@@ -312,3 +341,12 @@ function commitCtx(ctx, values) {
   ctx._isUpdating = false;
   return unwrap(values);
 }
+
+function unmountCtx(ctx) {
+  if (!ctx._isDone) {
+    ctx._isDone = true;
+    if (ctx._iterator &amp;&amp; typeof ctx._iterator.return === &quot;function&quot;) {
+      ctx._iterator.return();
+    }
+  }
+}" data-lang="diff"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token coord">--- a/crank.js</span></code><br></div><div><code><span class="token coord">+++ b/crank.js</span></code><br></div><div><code>@@ -227,20 +227,30 @@ function update(renderer, host, el) {</code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">function updateChildren(renderer, host, el, newChildren) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  const oldChildren = wrap(el._children);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  newChildren = arrayify(newChildren);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  const children = [];</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  const values = [];</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  const length = Math.max(oldChildren.length, newChildren.length);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  for (let i = 0; i &lt; length; i++) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    const oldChild = oldChildren[i];</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    let newChild = narrow(newChildren[i]);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    const [child, value] = diff(renderer, host, oldChild, newChild);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    if (oldChild instanceof Element &amp;&amp; child !== oldChild) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      unmount(renderer, oldChild);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    children.push(child);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    if (value) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      values.push(value);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  el._children = unwrap(children);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  for (const oldChild of oldChildren.slice(length)) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    if (oldChild instanceof Element) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      unmount(renderer, oldChild);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  return commit(renderer, el, normalize(values));</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code></code><br></div><div><code>@@ -261,33 +271,52 @@ function commit(renderer, el, values) {</code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  return el._node;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">function unmount(renderer, el) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  if (typeof el.tag === &quot;function&quot;) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    unmountCtx(el._ctx);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  for (const child of wrap(el._children)) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    if (child instanceof Element) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      unmount(renderer, child);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">}</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">class Context {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  constructor(renderer, host, el) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._renderer = renderer;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._host = host;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._el = el;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._iter = undefined;</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    // flags</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._isUpdating = false;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    this._isDone = false;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  refresh() {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    return stepCtx(this);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">function stepCtx(ctx) {</span></span></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  if (!ctx._iter) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  if (ctx._isDone) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    return getValue(ctx._el);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  } else if (!ctx._iter) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    const value = ctx._el.tag.call(ctx, ctx._el.props);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    if (isIteratorLike(value)) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      ctx._iter = value;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    } else {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      return updateCtxChildren(ctx, value);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  const iteration = ctx._iter.next();</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  if (iteration.done) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    ctx._isDone = true;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  return updateCtxChildren(ctx, iteration.value);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code></code><br></div><div><code>@@ -312,3 +341,12 @@ function commitCtx(ctx, values) {</code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  ctx._isUpdating = false;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  return unwrap(values);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">function unmountCtx(ctx) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  if (!ctx._isDone) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    ctx._isDone = true;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    if (ctx._iterator &amp;&amp; typeof ctx._iterator.return === &quot;function&quot;) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      ctx._iterator.return();</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">}</span></span></code><br></div></pre></content-area></div></div><p><a href="https://github.com/brainkim/crank-from-scratch/commit/274b9142fced2b366bedb62ca668e96a64e7c39a">Diff</a> <a href="https://github.com/brainkim/crank-from-scratch/blob/274b9142fced2b366bedb62ca668e96a64e7c39a/crank.js">File</a></p><p>We’ve added another renderer function, <code class="inline">unmount</code>, along with its analogous context function, <code class="inline">unmountCtx</code>. It is important to make the <code class="inline">unmount</code> function recursive, because there can be component elements deeply nested in the element tree which expect to be returned.</p><p>We’ve also added the flag <code class="inline">_isDone</code> to context objects to keep track of the iterator’s current state. By checking the <code class="inline">done</code> property for each iteration, we can freeze generator components on their final rendered values if they are detected as having returned.</p><div class="codeblock" data-code="function MyComponent() {
  yield 1;
  yield 2;
  return 3;
}

renderer.render(&lt;MyComponent /&gt;, app);
console.log(app.innerHTML); // 1
renderer.render(&lt;MyComponent /&gt;, app);
console.log(app.innerHTML); // 2
renderer.render(&lt;MyComponent /&gt;, app);
console.log(app.innerHTML); // 3
renderer.render(&lt;MyComponent /&gt;, app);
console.log(app.innerHTML); // 3" data-lang="jsx"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token keyword">function</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>  <span class="token keyword">yield</span> <span class="token number">1</span><span class="token punctuation">;</span></code><br></div><div><code>  <span class="token keyword">yield</span> <span class="token number">2</span><span class="token punctuation">;</span></code><br></div><div><code>  <span class="token keyword">return</span> <span class="token number">3</span><span class="token punctuation">;</span></code><br></div><div><code><span class="token punctuation">}</span></code><br></div><div><code></code><br></div><div><code>renderer<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">MyComponent</span></span> <span class="token punctuation">/&gt;</span></span><span class="token punctuation">,</span> app<span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>app<span class="token punctuation">.</span>innerHTML<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span></code><br></div><div><code>renderer<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">MyComponent</span></span> <span class="token punctuation">/&gt;</span></span><span class="token punctuation">,</span> app<span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>app<span class="token punctuation">.</span>innerHTML<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span></code><br></div><div><code>renderer<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">MyComponent</span></span> <span class="token punctuation">/&gt;</span></span><span class="token punctuation">,</span> app<span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>app<span class="token punctuation">.</span>innerHTML<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span></code><br></div><div><code>renderer<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">MyComponent</span></span> <span class="token punctuation">/&gt;</span></span><span class="token punctuation">,</span> app<span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>app<span class="token punctuation">.</span>innerHTML<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span></code><br></div></pre></content-area></div></div><p>When a generator function is returned before it is unmounted, this usually indicates programmer error, so sticking to its final value will make the sitution more obvious to the developer. Thanks to the <code class="inline">getValue</code> function implemented in the previous step, it’s now easy to get the final rendered value of a returned generator component element.</p><h2>Step 9: Props Iterators</h2><p>The generator components we’ve seen so far haven’t referenced the <code class="inline">props</code> parameter in any way; we have exclusively used generator functions which take no parameters and yield elements in a <code class="inline">while (true)</code> loop. Eventually though, we’ll want to write generator functions which use <code class="inline">props</code> just like any other component. However, we cannot simply reference the <code class="inline">props</code> parameter as for regular function components, because for generator functions, the <code class="inline">props</code> parameter may not necessarily reflect the latest <code class="inline">props</code> passed to the component.</p><p>There were potentially many ways to solve this problem. The design I chose for Crank was to make the context object an iterable of the component’s <code class="inline">props</code>, so that you could again destructure props in a <code class="inline">for…of</code> loop over <code class="inline">this</code>.</p><div class="codeblock" data-code="function *StatefulGreeting({color, name}) {
  let prevName;
  for ({color, name} of this) {
    yield (
      &lt;div&gt;
        Hello {prevName === name &amp;&amp; &quot;again, &quot;}
        &lt;span style={`color: ${color};`}&gt;{name}&lt;/span&gt;
      &lt;/div&gt;
    );

    prevName = name;
  }
}" data-lang="jsx"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token keyword">function</span> <span class="token operator">*</span><span class="token function">StatefulGreeting</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>color<span class="token punctuation">,</span> name<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>  <span class="token keyword">let</span> prevName<span class="token punctuation">;</span></code><br></div><div><code>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>color<span class="token punctuation">,</span> name<span class="token punctuation">}</span> <span class="token keyword">of</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>    <span class="token keyword">yield</span> <span class="token punctuation">(</span></code><br></div><div><code>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span></code><br></div><div><code>        Hello <span class="token punctuation">{</span>prevName <span class="token operator">===</span> name <span class="token operator">&amp;&amp;</span> <span class="token string">&quot;again, &quot;</span><span class="token punctuation">}</span></code><br></div><div><code>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">style</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">color: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>color<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>name<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span></code><br></div><div><code>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span></code><br></div><div><code>    <span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code></code><br></div><div><code>    prevName <span class="token operator">=</span> name<span class="token punctuation">;</span></code><br></div><div><code>  <span class="token punctuation">}</span></code><br></div><div><code><span class="token punctuation">}</span></code><br></div></pre></content-area></div></div><p>This was yet another of the more controversial design decisions for Crank, likely because it combines multiple syntaxes and keywords in an unusual way. Seeing <code class="inline">for…of</code>, object destructuring, and <code class="inline">this</code> all in the same line of code might have been too much for some people. Hopefully, by this point, I’ve explained enough of iterators and iterables, as well as why we use <code class="inline">this</code>, that this pattern doesn’t overwhelm you.</p><p>My reasons for choosing this design is that it allows developers to make the common refactoring of stateless function components to stateful generator components in the fewest keystrokes: you copy the props parameter into a <code class="inline">this</code> loop header, move the function body into the loop, and replace <code class="inline">return</code> keywords with <code class="inline">yield</code> keywords. Additionally, because new props are just variable assignments, we can compare old and new props easily, blending the concepts of props and state, as in the above example.</p><p>Ultimately, I didn’t want to diverge too much from the typical function component syntax, where the first parameter is the props of the component, and is usually destructured inline. This syntax makes it easy to understand what props a component expects by having it defined at the top of the function. Furthermore, TypeScript’s JSX type-checking feature for function components continues to work based on the props parameter, even if the function is a generator function.</p><h3>Implementation</h3><div class="codeblock" data-code="--- a/crank.js
+++ b/crank.js
@@ -286,36 +286,49 @@ function unmount(renderer, el) {
 class Context {
   constructor(renderer, host, el) {
     this._renderer = renderer;
     this._host = host;
     this._el = el;
     this._iter = undefined;

     // flags
     this._isUpdating = false;
+    this._isIterating = false;
     this._isDone = false;
   }

   refresh() {
     return stepCtx(this);
   }
+
+  *[Symbol.iterator]() {
+    while (!this._isDone) {
+      if (this._isIterating) {
+        throw new Error(&quot;Context iterated twice without a yield&quot;);
+      }
+
+      this._isIterating = true;
+      yield this._el.props;
+    }
+  }
 }

 function stepCtx(ctx) {
   if (ctx._isDone) {
     return getValue(ctx._el);
   } else if (!ctx._iter) {
     const value = ctx._el.tag.call(ctx, ctx._el.props);
     if (isIteratorLike(value)) {
       ctx._iter = value;
     } else {
       return updateCtxChildren(ctx, value);
     }
   }

   const iteration = ctx._iter.next();
+  ctx._isIterating = false;
   if (iteration.done) {
     ctx._isDone = true;
   }

   return updateCtxChildren(ctx, iteration.value);
 }" data-lang="diff"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token coord">--- a/crank.js</span></code><br></div><div><code><span class="token coord">+++ b/crank.js</span></code><br></div><div><code>@@ -286,36 +286,49 @@ function unmount(renderer, el) {</code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">class Context {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  constructor(renderer, host, el) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._renderer = renderer;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._host = host;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._el = el;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._iter = undefined;</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    // flags</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._isUpdating = false;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    this._isIterating = false;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._isDone = false;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  refresh() {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    return stepCtx(this);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  *[Symbol.iterator]() {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    while (!this._isDone) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      if (this._isIterating) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        throw new Error(&quot;Context iterated twice without a yield&quot;);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      this._isIterating = true;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      yield this._el.props;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">function stepCtx(ctx) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  if (ctx._isDone) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    return getValue(ctx._el);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  } else if (!ctx._iter) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    const value = ctx._el.tag.call(ctx, ctx._el.props);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    if (isIteratorLike(value)) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      ctx._iter = value;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    } else {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      return updateCtxChildren(ctx, value);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  const iteration = ctx._iter.next();</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  ctx._isIterating = false;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  if (iteration.done) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    ctx._isDone = true;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  return updateCtxChildren(ctx, iteration.value);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div></pre></content-area></div></div><p><a href="https://github.com/brainkim/crank-from-scratch/commit/79e12981b3bbb65ffd912cdf3fd4b11b19862da4">Diff</a> <a href="https://github.com/brainkim/crank-from-scratch/blob/79e12981b3bbb65ffd912cdf3fd4b11b19862da4/crank.js">File</a></p><p><strong>Notes:</strong></p><ol><li>The <code class="inline">[Symbol.iterator]()</code> method is a generator method. The syntax is similar to function generators in that we use a star, except now the star appears before the method name. Additionally, we use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Method_definitions#Computed_property_names">computed method syntax</a> (the square brackets) so that we can reference the global <code class="inline">Symbol.iterator</code> symbol.</li><li>We add an <code class="inline">_isIterating</code> flag to contexts to detect when props are pulled multiple times without a yield, so that we can throw an error. This would happen if the developer forgot to yield from within the for loop. Throwing an error provides predictable feedback as opposed to entering an infinite loop.</li></ol><h2>Step 10: Accessing DOM Nodes</h2><p>You may have noticed that the <code class="inline">refresh()</code> method already returns the actual DOM node or nodes which components render. One of the goals of Crank is to be a framework which makes it easy to do raw DOM operations. For many use-cases, it’s just easier to get your hands dirty and mutate the DOM by hand, even if you still want to use components and virtual elements for most situations. To that extent, we’ll add some more ways for users to access DOM nodes.</p><p>First, we’ll take advantage of an advanced feature of generator functions. The <code class="inline">next()</code> method of generator objects can optionally take an argument which will be “passed into” the generator as the result of the <code class="inline">yield</code> operation. For example, we can elaborate on the fibonacci number generator we saw previously by allowing the caller to pass in a truthy value to reset the sequence.</p><div class="codeblock" data-code="function *fibonacci() {
  let current = 0, next = 1;
  while (true) {
    const reset = yield current;
    if (reset) {
      [current, next] = [0, 1];
    } else {
      [current, next] = [next, current + next];
    }
  }
}

const iter = fibonacci();
console.log(iter.next()); // {value: 0, done: false}
console.log(iter.next()); // {value: 1, done: false}
console.log(iter.next()); // {value: 1, done: false}
console.log(iter.next()); // {value: 2, done: false}
console.log(iter.next(true)); // {value: 0, done: false}
console.log(iter.next()); // {value: 1, done: false}" data-lang="js"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token keyword">function</span> <span class="token operator">*</span><span class="token function">fibonacci</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>  <span class="token keyword">let</span> current <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> next <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></code><br></div><div><code>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>    <span class="token keyword">const</span> reset <span class="token operator">=</span> <span class="token keyword">yield</span> current<span class="token punctuation">;</span></code><br></div><div><code>    <span class="token keyword">if</span> <span class="token punctuation">(</span>reset<span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>      <span class="token punctuation">[</span>current<span class="token punctuation">,</span> next<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code><br></div><div><code>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></code><br></div><div><code>      <span class="token punctuation">[</span>current<span class="token punctuation">,</span> next<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>next<span class="token punctuation">,</span> current <span class="token operator">+</span> next<span class="token punctuation">]</span><span class="token punctuation">;</span></code><br></div><div><code>    <span class="token punctuation">}</span></code><br></div><div><code>  <span class="token punctuation">}</span></code><br></div><div><code><span class="token punctuation">}</span></code><br></div><div><code></code><br></div><div><code><span class="token keyword">const</span> iter <span class="token operator">=</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {value: 0, done: false}</span></code><br></div><div><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {value: 1, done: false}</span></code><br></div><div><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {value: 1, done: false}</span></code><br></div><div><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {value: 2, done: false}</span></code><br></div><div><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {value: 0, done: false}</span></code><br></div><div><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {value: 1, done: false}</span></code><br></div></pre></content-area></div></div><p>The <code class="inline">reset</code> variable is set to the yield operation, and we reset the current and next variables if <code class="inline">reset</code> is detected as truthy. This feature of generator functions only works when calling the iterator methods; when using <code class="inline">for…of</code> loops, the yield operation will always resolve to <code class="inline">undefined</code>.</p><p>For Crank, the most natural thing to pass back into generator components is the DOM nodes which were rendered. This gives generator components a “call and response”-like structure, where the generator yields virtual elements and gets their realized equivalents passed back in.</p><div class="codeblock" data-code="function *ImperativeCounter() {
  let i = 0;
  let button;
  for ({} of this) {
    if (button) {
      /* do whatever DOM mutations you please */
      button.style.color = &quot;red&quot;;
    }

    i++;
    button = yield &lt;button&gt;{i}&lt;/button&gt;;
  }
}" data-lang="jsx"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token keyword">function</span> <span class="token operator">*</span><span class="token function">ImperativeCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>  <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></code><br></div><div><code>  <span class="token keyword">let</span> button<span class="token punctuation">;</span></code><br></div><div><code>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">of</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>    <span class="token keyword">if</span> <span class="token punctuation">(</span>button<span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>      <span class="token comment">/* do whatever DOM mutations you please */</span></code><br></div><div><code>      button<span class="token punctuation">.</span>style<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">&quot;red&quot;</span><span class="token punctuation">;</span></code><br></div><div><code>    <span class="token punctuation">}</span></code><br></div><div><code></code><br></div><div><code>    i<span class="token operator">++</span><span class="token punctuation">;</span></code><br></div><div><code>    button <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>i<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span></code><br></div><div><code>  <span class="token punctuation">}</span></code><br></div><div><code><span class="token punctuation">}</span></code><br></div></pre></content-area></div></div><p>This API is intuitive, but doesn’t work too well with sync generator components, insofar as generator functions suspend directly on the <code class="inline">yield</code> keyword. While the yield operation can be assigned to a local variable, the actual timing of the assignment might surprise developers, insofar as it wouldn’t happen until the generator component was rerendered. In this case, any callbacks which expect the variable to have already been assigned would error.</p><div class="codeblock" data-code="function *ImperativeCounter() {
  let i = 0;
  let button;
  const onclick = () =&gt; {
    // button may not be assigned after the first render
    button.style.color = &quot;red&quot;;
    i++;
    this.refresh();
  }
  for ({} of this) {
    button = yield &lt;button&gt;{i}&lt;/button&gt;;
  }
}" data-lang="jsx"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token keyword">function</span> <span class="token operator">*</span><span class="token function">ImperativeCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>  <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></code><br></div><div><code>  <span class="token keyword">let</span> button<span class="token punctuation">;</span></code><br></div><div><code>  <span class="token keyword">const</span> <span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></code><br></div><div><code>    <span class="token comment">// button may not be assigned after the first render</span></code><br></div><div><code>    button<span class="token punctuation">.</span>style<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">&quot;red&quot;</span><span class="token punctuation">;</span></code><br></div><div><code>    i<span class="token operator">++</span><span class="token punctuation">;</span></code><br></div><div><code>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>  <span class="token punctuation">}</span></code><br></div><div><code>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">of</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>    button <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>i<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span></code><br></div><div><code>  <span class="token punctuation">}</span></code><br></div><div><code><span class="token punctuation">}</span></code><br></div></pre></content-area></div></div><p>As we’ll see later, this is less of a problem for async generator components, which resume continuously when mounted, but for sync generator components we’ll implement another context method <code class="inline">schedule()</code> to make yield values more useful. The <code class="inline">schedule()</code> method takes a callback which fires once when the component has committed. It allows us to write components like the following.</p><div class="codeblock" data-code="function *ImperativeCounter() {
  let i = 0;
  let button;
  const onclick = () =&gt; {
    i++;
    button.style.color = &quot;red&quot;;
    this.refresh();
  };
  this.schedule(() =&gt; this.refresh());
  for ({} of this) {
    button = yield &lt;button onclick={onclick}&gt;{i}&lt;/button&gt;;
  }
}" data-lang="jsx"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token keyword">function</span> <span class="token operator">*</span><span class="token function">ImperativeCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>  <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></code><br></div><div><code>  <span class="token keyword">let</span> button<span class="token punctuation">;</span></code><br></div><div><code>  <span class="token keyword">const</span> <span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></code><br></div><div><code>    i<span class="token operator">++</span><span class="token punctuation">;</span></code><br></div><div><code>    button<span class="token punctuation">.</span>style<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">&quot;red&quot;</span><span class="token punctuation">;</span></code><br></div><div><code>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>  <span class="token punctuation">}</span><span class="token punctuation">;</span></code><br></div><div><code>  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">of</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>    button <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onclick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>onclick<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>i<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span></code><br></div><div><code>  <span class="token punctuation">}</span></code><br></div><div><code><span class="token punctuation">}</span></code><br></div></pre></content-area></div></div><p>The schedule method can be used to listen for component commits more generally, but here we use it to trigger a second synchronous execution of the <code class="inline">ImperativeCounter</code> component the first time it is rendered. We do this by pairing it with the <code class="inline">refresh</code> method. In the example, generator resumes a second time synchronously, so the <code class="inline">button</code> variable is always available in the closure of the <code class="inline">onclick</code> callback.</p><p>Second, we’ll also change the return value of the <code class="inline">render()</code> method slightly so that the created <code class="inline">Portal</code> element’s child values are returned, whereas before we returned <code class="inline">undefined</code>. In Crank, the value of a Portal is always <code class="inline">undefined</code>, so that the parents of the portal do not attempt to insert the <code class="inline">Portal</code> element’s root into the DOM in unexpected places. By returning the portal’s child values, we can make the <code class="inline">render()</code> method’s return value a little more useful.</p><h3>Implementation</h3><div class="codeblock" data-code="--- a/crank.js
+++ b/crank.js
@@ -125,61 +125,62 @@ function getChildValues(el) {
 export class Renderer {
   constructor() {
     this._cache = new WeakMap();
   }

   render(children, root) {
     let portal = this._cache.get(root);
     if (portal) {
       portal.props = {root, children};
     } else {
       portal = createElement(Portal, {root, children});
       this._cache.set(root, portal);
     }

-    return update(this, portal, portal);
+    update(this, portal, portal);
+    return getChildValues(portal);
   }

   create(el) {
     return document.createElement(el.tag);
   }

   patch(el, node) {
     for (let [name, value] of Object.entries(el.props)) {
       if (name === &quot;children&quot;) {
         continue;
       } else if (name === &quot;class&quot;) {
         name = &quot;className&quot;;
       }

       if (name in node) {
         node[name] = value;
       } else {
         node.setAttribute(name, value);
       }
     }
   }

   arrange(el, node, children) {
     let child = node.firstChild;
     for (const newChild of children) {
       if (child === newChild) {
         child = child.nextSibling;
       } else if (typeof newChild === &quot;string&quot;) {
         if (child !== null &amp;&amp; child.nodeType === Node.TEXT_NODE) {
           child.nodeValue = newChild;
           child = child.nextSibling;
         } else {
           node.insertBefore(document.createTextNode(newChild), child);
         }
       } else {
         node.insertBefore(newChild, child);
       }
     }

     while (child !== null) {
       const nextSibling = child.nextSibling;
       node.removeChild(child);
       child = child.nextSibling;
     }
   }
 }
@@ -286,49 +287,56 @@ function unmount(renderer, el) {
 class Context {
   constructor(renderer, host, el) {
     this._renderer = renderer;
     this._host = host;
     this._el = el;
     this._iter = undefined;
+    this._schedules = new Set();

     // flags
     this._isUpdating = false;
     this._isIterating = false;
     this._isDone = false;
   }

   refresh() {
     return stepCtx(this);
   }

+  schedule(callback) {
+    this._schedules.add(callback);
+  }
+
   *[Symbol.iterator]() {
     while (!this._isDone) {
       if (this._isIterating) {
         throw new Error(&quot;Context iterated twice without a yield&quot;);
       }

       this._isIterating = true;
       yield this._el.props;
     }
   }
 }

 function stepCtx(ctx) {
+  let initial = !ctx._iter;
   if (ctx._isDone) {
     return getValue(ctx._el);
-  } else if (!ctx._iter) {
+  } else if (initial) {
     const value = ctx._el.tag.call(ctx, ctx._el.props);
     if (isIteratorLike(value)) {
       ctx._iter = value;
     } else {
       return updateCtxChildren(ctx, value);
     }
   }

-  const iteration = ctx._iter.next();
+  const oldValue = initial ? undefined : getValue(ctx._el);
+  const iteration = ctx._iter.next(oldValue);
   ctx._isIterating = false;
   if (iteration.done) {
     ctx._isDone = true;
   }

   return updateCtxChildren(ctx, iteration.value);
 }
@@ -345,14 +353,21 @@ function updateCtxChildren(ctx, children) {
 function commitCtx(ctx, values) {
   if (!ctx._isUpdating) {
     ctx._renderer.arrange(
       ctx._host,
       ctx._host.tag === Portal ? ctx._host.props.root : ctx._host._node,
       getChildValues(ctx._host),
     );
   }

+  const value = unwrap(values);
+  const schedules = Array.from(ctx._schedules);
+  ctx._schedules.clear();
+  for (const schedule of schedules) {
+    schedule(value);
+  }
+
   ctx._isUpdating = false;
-  return unwrap(values);
+  return value;
 }

 function unmountCtx(ctx) {" data-lang="diff"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token coord">--- a/crank.js</span></code><br></div><div><code><span class="token coord">+++ b/crank.js</span></code><br></div><div><code>@@ -125,61 +125,62 @@ function getChildValues(el) {</code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">export class Renderer {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  constructor() {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._cache = new WeakMap();</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  render(children, root) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    let portal = this._cache.get(root);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    if (portal) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      portal.props = {root, children};</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    } else {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      portal = createElement(Portal, {root, children});</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      this._cache.set(root, portal);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    return update(this, portal, portal);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    update(this, portal, portal);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    return getChildValues(portal);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  create(el) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    return document.createElement(el.tag);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  patch(el, node) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    for (let [name, value] of Object.entries(el.props)) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      if (name === &quot;children&quot;) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        continue;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      } else if (name === &quot;class&quot;) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        name = &quot;className&quot;;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      if (name in node) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        node[name] = value;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      } else {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        node.setAttribute(name, value);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  arrange(el, node, children) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    let child = node.firstChild;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    for (const newChild of children) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      if (child === newChild) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        child = child.nextSibling;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      } else if (typeof newChild === &quot;string&quot;) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        if (child !== null &amp;&amp; child.nodeType === Node.TEXT_NODE) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">          child.nodeValue = newChild;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">          child = child.nextSibling;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        } else {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">          node.insertBefore(document.createTextNode(newChild), child);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      } else {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        node.insertBefore(newChild, child);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    while (child !== null) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      const nextSibling = child.nextSibling;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      node.removeChild(child);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      child = child.nextSibling;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code>@@ -286,49 +287,56 @@ function unmount(renderer, el) {</code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">class Context {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  constructor(renderer, host, el) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._renderer = renderer;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._host = host;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._el = el;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._iter = undefined;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    this._schedules = new Set();</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    // flags</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._isUpdating = false;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._isIterating = false;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._isDone = false;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  refresh() {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    return stepCtx(this);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  schedule(callback) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    this._schedules.add(callback);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  *[Symbol.iterator]() {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    while (!this._isDone) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      if (this._isIterating) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        throw new Error(&quot;Context iterated twice without a yield&quot;);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      this._isIterating = true;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      yield this._el.props;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">function stepCtx(ctx) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  let initial = !ctx._iter;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  if (ctx._isDone) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    return getValue(ctx._el);</span></span></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  } else if (!ctx._iter) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  } else if (initial) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    const value = ctx._el.tag.call(ctx, ctx._el.props);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    if (isIteratorLike(value)) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      ctx._iter = value;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    } else {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      return updateCtxChildren(ctx, value);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  const iteration = ctx._iter.next();</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  const oldValue = initial ? undefined : getValue(ctx._el);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  const iteration = ctx._iter.next(oldValue);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  ctx._isIterating = false;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  if (iteration.done) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    ctx._isDone = true;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  return updateCtxChildren(ctx, iteration.value);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code>@@ -345,14 +353,21 @@ function updateCtxChildren(ctx, children) {</code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">function commitCtx(ctx, values) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  if (!ctx._isUpdating) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    ctx._renderer.arrange(</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      ctx._host,</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      ctx._host.tag === Portal ? ctx._host.props.root : ctx._host._node,</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      getChildValues(ctx._host),</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    );</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  const value = unwrap(values);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  const schedules = Array.from(ctx._schedules);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  ctx._schedules.clear();</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  for (const schedule of schedules) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    schedule(value);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  ctx._isUpdating = false;</span></span></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  return unwrap(values);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  return value;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">function unmountCtx(ctx) {</span></span></code><br></div></pre></content-area></div></div><p><a href="https://github.com/brainkim/crank-from-scratch/commit/cb6789ba7bb76966826dee83df2771bfd0e87c30">Diff</a> <a href="https://github.com/brainkim/crank-from-scratch/blob/cb6789ba7bb76966826dee83df2771bfd0e87c30/crank.js">File</a></p><p><strong>Notes:</strong></p><ol><li>The <code class="inline">schedule</code> method also passes the component’s rendered DOM nodes as the first argument of its callback. This is mainly helpful when using the <code class="inline">schedule</code> method in helper functions outside of component bodies. The benefit of using yield results as opposed to the <code class="inline">schedule</code> argument is that using yield results allows us to visualize the rendering and accessing of rendered values in a linear fashion directly within the component.</li></ol><h2>Intermission</h2><p>At this point, we’ve implemented most of the logic for synchronous components in Crank. This is actually enough to write full-fledged applications.</p><p>Nevertheless, we will inevitably start to wonder: if we can use sync generator functions to write components, why can’t we use async functions and async generator functions to define components as well? The next steps will implement async components using these function syntaxes.</p><p>If you were already familiar with iterators, iterables and generators, you probably would not have had too much difficulty understanding the code and techniques we’ve seen so far. However, because we are now diving into concurrent code which makes heavy use of promises, things are about to get a little more difficult. This is a natural place to take a break, or to <a href="https://github.com/brainkim/crank-from-scratch/blob/cb6789ba7bb76966826dee83df2771bfd0e87c30/crank.js">review the code</a> we’ve written so far before continuing.</p><h2>Step 11: Async Function Components</h2><p>Just as Crank leverages generator functions for stateful components, it also provides first-class support for promises, by allowing components to be defined as <em>async</em> functions as well.</p><p>To review, an async function is a special function syntax which prepends <code class="inline">async</code> before the <code class="inline">function</code> keyword (<code class="inline">async function</code>). This allows you to use the <code class="inline">await</code> operator within the function to read promises in a way which looks synchronous. Here is an example of an async function component in Crank.</p><div class="codeblock" data-code="async function DelayedGreeting({name}) {
  await new Promise((resolve) =&gt; setTimeout(resolve, 2000));
  return &lt;div&gt;Hello &lt;span style=&quot;color: red&quot;&gt;{name}&lt;/span&gt;&lt;/div&gt;;
}" data-lang="jsx"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">DelayedGreeting</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>name<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>  <span class="token keyword">await</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>Hello <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token value css language-css"><span class="token property">color</span><span class="token punctuation">:</span> red</span><span class="token punctuation">&quot;</span></span></span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>name<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span></code><br></div><div><code><span class="token punctuation">}</span></code><br></div></pre></content-area></div></div><h3>Implementation</h3><div class="codeblock" data-code="--- a/crank.js
+++ b/crank.js
@@ -18,6 +18,10 @@ function isIteratorLike(value) {
   return value != null &amp;&amp; typeof value.next === &quot;function&quot;;
 }

+function isPromiseLike(value) {
+  return value != null &amp;&amp; typeof value.then === &quot;function&quot;;
+}
+
 class Element {
   constructor(tag, props) {
     this.tag = tag;
@@ -125,62 +129,66 @@ function getChildValues(el) {
 export class Renderer {
   constructor() {
     this._cache = new WeakMap();
   }

   render(children, root) {
     let portal = this._cache.get(root);
     if (portal) {
       portal.props = {root, children};
     } else {
       portal = createElement(Portal, {root, children});
       this._cache.set(root, portal);
     }

-    update(this, portal, portal);
+    const result = update(this, portal, portal);
+    if (isPromiseLike(result)) {
+      return Promise.resolve(result).then(() =&gt; getChildValues(portal));
+    }
+
     return getChildValues(portal);
   }

   create(el) {
     return document.createElement(el.tag);
   }

   patch(el, node) {
     for (let [name, value] of Object.entries(el.props)) {
       if (name === &quot;children&quot;) {
         continue;
       } else if (name === &quot;class&quot;) {
         name = &quot;className&quot;;
       }

       if (name in node) {
         node[name] = value;
       } else {
         node.setAttribute(name, value);
       }
     }
   }

   arrange(el, node, children) {
     let child = node.firstChild;
     for (const newChild of children) {
       if (child === newChild) {
         child = child.nextSibling;
       } else if (typeof newChild === &quot;string&quot;) {
         if (child !== null &amp;&amp; child.nodeType === Node.TEXT_NODE) {
           child.nodeValue = newChild;
           child = child.nextSibling;
         } else {
           node.insertBefore(document.createTextNode(newChild), child);
         }
       } else {
         node.insertBefore(newChild, child);
       }
     }

     while (child !== null) {
       const nextSibling = child.nextSibling;
       node.removeChild(child);
       child = child.nextSibling;
     }
   }
 }
@@ -228,29 +236,41 @@ function update(renderer, host, el) {
 function updateChildren(renderer, host, el, newChildren) {
   const oldChildren = wrap(el._children);
   newChildren = arrayify(newChildren);
   const children = [];
-  const values = [];
+  let values = [];
   const length = Math.max(oldChildren.length, newChildren.length);
   for (let i = 0; i &lt; length; i++) {
     const oldChild = oldChildren[i];
     let newChild = narrow(newChildren[i]);
     const [child, value] = diff(renderer, host, oldChild, newChild);
     if (oldChild instanceof Element &amp;&amp; child !== oldChild) {
       unmount(renderer, oldChild);
     }

     children.push(child);
     if (value) {
       values.push(value);
     }
   }

   el._children = unwrap(children);
+  if (values.some((value) =&gt; isPromiseLike(value))) {
+    values = Promise.all(values).finally(() =&gt; {
+      for (const oldChild of oldChildren.slice(length)) {
+        if (oldChild instanceof Element) {
+          unmount(renderer, oldChild);
+        }
+      }
+    });
+
+    return values.then((values) =&gt; commit(renderer, el, normalize(values)));
+  }
+
   for (const oldChild of oldChildren.slice(length)) {
     if (oldChild instanceof Element) {
       unmount(renderer, oldChild);
     }
   }

   return commit(renderer, el, normalize(values));
 }
@@ -321,22 +341,25 @@ class Context {
 function stepCtx(ctx) {
   let initial = !ctx._iter;
   if (ctx._isDone) {
     return getValue(ctx._el);
   } else if (initial) {
     const value = ctx._el.tag.call(ctx, ctx._el.props);
     if (isIteratorLike(value)) {
       ctx._iter = value;
+    } else if (isPromiseLike(value)) {
+      return Promise.resolve(value)
+        .then((value) =&gt; updateCtxChildren(ctx, value));
     } else {
       return updateCtxChildren(ctx, value);
     }
   }

   const oldValue = initial ? undefined : getValue(ctx._el);
   const iteration = ctx._iter.next(oldValue);
   ctx._isIterating = false;
   if (iteration.done) {
     ctx._isDone = true;
   }

   return updateCtxChildren(ctx, iteration.value);
 }" data-lang="diff"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token coord">--- a/crank.js</span></code><br></div><div><code><span class="token coord">+++ b/crank.js</span></code><br></div><div><code>@@ -18,6 +18,10 @@ function isIteratorLike(value) {</code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  return value != null &amp;&amp; typeof value.next === &quot;function&quot;;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">function isPromiseLike(value) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  return value != null &amp;&amp; typeof value.then === &quot;function&quot;;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">}</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">class Element {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  constructor(tag, props) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this.tag = tag;</span></span></code><br></div><div><code>@@ -125,62 +129,66 @@ function getChildValues(el) {</code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">export class Renderer {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  constructor() {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._cache = new WeakMap();</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  render(children, root) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    let portal = this._cache.get(root);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    if (portal) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      portal.props = {root, children};</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    } else {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      portal = createElement(Portal, {root, children});</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      this._cache.set(root, portal);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    update(this, portal, portal);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    const result = update(this, portal, portal);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    if (isPromiseLike(result)) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      return Promise.resolve(result).then(() =&gt; getChildValues(portal));</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    return getChildValues(portal);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  create(el) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    return document.createElement(el.tag);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  patch(el, node) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    for (let [name, value] of Object.entries(el.props)) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      if (name === &quot;children&quot;) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        continue;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      } else if (name === &quot;class&quot;) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        name = &quot;className&quot;;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      if (name in node) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        node[name] = value;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      } else {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        node.setAttribute(name, value);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  arrange(el, node, children) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    let child = node.firstChild;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    for (const newChild of children) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      if (child === newChild) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        child = child.nextSibling;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      } else if (typeof newChild === &quot;string&quot;) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        if (child !== null &amp;&amp; child.nodeType === Node.TEXT_NODE) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">          child.nodeValue = newChild;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">          child = child.nextSibling;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        } else {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">          node.insertBefore(document.createTextNode(newChild), child);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      } else {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        node.insertBefore(newChild, child);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    while (child !== null) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      const nextSibling = child.nextSibling;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      node.removeChild(child);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      child = child.nextSibling;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code>@@ -228,29 +236,41 @@ function update(renderer, host, el) {</code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">function updateChildren(renderer, host, el, newChildren) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  const oldChildren = wrap(el._children);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  newChildren = arrayify(newChildren);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  const children = [];</span></span></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  const values = [];</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  let values = [];</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  const length = Math.max(oldChildren.length, newChildren.length);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  for (let i = 0; i &lt; length; i++) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    const oldChild = oldChildren[i];</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    let newChild = narrow(newChildren[i]);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    const [child, value] = diff(renderer, host, oldChild, newChild);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    if (oldChild instanceof Element &amp;&amp; child !== oldChild) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      unmount(renderer, oldChild);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    children.push(child);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    if (value) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      values.push(value);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  el._children = unwrap(children);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  if (values.some((value) =&gt; isPromiseLike(value))) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    values = Promise.all(values).finally(() =&gt; {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      for (const oldChild of oldChildren.slice(length)) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        if (oldChild instanceof Element) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">          unmount(renderer, oldChild);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    });</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    return values.then((values) =&gt; commit(renderer, el, normalize(values)));</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  for (const oldChild of oldChildren.slice(length)) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    if (oldChild instanceof Element) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      unmount(renderer, oldChild);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  return commit(renderer, el, normalize(values));</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code>@@ -321,22 +341,25 @@ class Context {</code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">function stepCtx(ctx) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  let initial = !ctx._iter;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  if (ctx._isDone) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    return getValue(ctx._el);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  } else if (initial) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    const value = ctx._el.tag.call(ctx, ctx._el.props);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    if (isIteratorLike(value)) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      ctx._iter = value;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    } else if (isPromiseLike(value)) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      return Promise.resolve(value)</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        .then((value) =&gt; updateCtxChildren(ctx, value));</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    } else {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      return updateCtxChildren(ctx, value);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  const oldValue = initial ? undefined : getValue(ctx._el);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  const iteration = ctx._iter.next(oldValue);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  ctx._isIterating = false;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  if (iteration.done) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    ctx._isDone = true;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  return updateCtxChildren(ctx, iteration.value);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div></pre></content-area></div></div><p><a href="https://github.com/brainkim/crank-from-scratch/commit/72cdc766f14951ccda676df887eac6f5968c5fdc">Diff</a> <a href="https://github.com/brainkim/crank-from-scratch/blob/72cdc766f14951ccda676df887eac6f5968c5fdc/crank.js">File</a></p><p>Just as in the implementation of generator components, we detect async components in <code class="inline">stepCtx()</code> solely by the return value of the component call. While there may be ways to identify async functions without calling them, this would again be an anti-pattern, insofar as it would prevent functions which returned promises but did not use async syntax from being used as async components.</p><p>Async components are “contagious” in that they make ancestor components update and commit asynchronously as well. Additionally, any <code class="inline">refresh()</code> or <code class="inline">render()</code> calls which attempt to render async components will now return promises, and all DOM mutations are deferred until the async components have settled. This logic is implemented in the <code class="inline">updateChildren()</code> function, where we return a promise of the <code class="inline">commit()</code> call if any child values are detected to be promise-like.</p><h2>Step 12: Enqueuing</h2><p>Our async components work, but are problematic in that there can be multiple pending executions of the async component element at the same time. While this might not matter for the previously defined <code class="inline">DelayedGreeting</code> component, which uses a <code class="inline">setTimeout()</code>-based promise, this would be a problem for async components which make network requests or perform other I/O, insofar as your clients might inadvertently make too many concurrent requests over a short period of time. Do this too often and you may receive a sternly-worded email from a backend engineer!</p><div class="codeblock" data-code="async function UserGreeting() {
  const res = await fetch(&quot;/api/whoami&quot;);
  const name = await res.text();
  return &lt;div&gt;Hello &lt;span style=&quot;color: red&quot;&gt;{name}&lt;/span&gt;&lt;/div&gt;;
}

renderer.render(&lt;NetworkedGreeting /&gt;, app);
renderer.render(&lt;NetworkedGreeting /&gt;, app);
renderer.render(&lt;NetworkedGreeting /&gt;, app);
renderer.render(&lt;NetworkedGreeting /&gt;, app);
renderer.render(&lt;NetworkedGreeting /&gt;, app);

// Expected: Fires 1 or 2 network requests.
// Actual: Fires 5 network requests." data-lang="js"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">UserGreeting</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">&quot;/api/whoami&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>  <span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token keyword">await</span> res<span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>  <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>Hello <span class="token operator">&lt;</span>span style<span class="token operator">=</span><span class="token string">&quot;color: red&quot;</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>name<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token punctuation">;</span></code><br></div><div><code><span class="token punctuation">}</span></code><br></div><div><code></code><br></div><div><code>renderer<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>NetworkedGreeting <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> app<span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>renderer<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>NetworkedGreeting <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> app<span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>renderer<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>NetworkedGreeting <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> app<span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>renderer<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>NetworkedGreeting <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> app<span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>renderer<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>NetworkedGreeting <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> app<span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code></code><br></div><div><code><span class="token comment">// Expected: Fires 1 or 2 network requests.</span></code><br></div><div><code><span class="token comment">// Actual: Fires 5 network requests.</span></code><br></div></pre></content-area></div></div><p>What we want is a way to limit the concurrency of async component elements, so that there is at most, one pending call for the component element, at any point in time.</p><p>Before we continue, I’d like to introduce a visual notation for promises which we’ll use for the rest of this essay. This is a promise.</p><p><img src="../static/promise.png" alt="A Promise"></p><p>These diagrams will get more complicated, I <em>promise</em>. But for now, know that the horizontal axis represents time, the left edge represents when the promise was created and the right edge represents when the promise settles.</p><p>Given this notation, we can represent multiple calls to an async function as follows.</p><p><img src="../static/multiple-promises.png" alt="Multiple Promises"></p><p>What we want for async components is a strategy which coalesces these promises so that there is only one pending run of a component element at any point in time. Visually, this would mean that none of these line segments overlap.</p><p>One possible technique we could use is <em>hitching,</em> where we resolve concurrent calls to the currently pending run, if one exists. We call this technique “hitching” because it’s as though concurrent calls are hitching a ride on the pending call rather than creating a new promise.</p><p>This strategy would transform the previous diagram to the following one.</p><p><img src="../static/hitching.png" alt="Hitching"></p><p>The promises <code class="inline">B</code> and <code class="inline">C</code> resolve to the promise <code class="inline">A</code>, because they are created while <code class="inline">A</code> is still pending. We use a dotted line to indicate that these promises don’t actually perform any work, and we use the red trailing edge to indicate that these promises have resolved to some other call. Because <code class="inline">D</code> starts after <code class="inline">A</code> finishes, it is its own independent promise.</p><p>We can demonstrate the algorithm for this strategy by implementing it as a higher-order function which takes an async function and returns a modified function which exhibits this hitching behavior.</p><div class="codeblock" data-code="function hitch(fn) {
  let inflight;

  return function hitchWrapper(...args) {
    if (!inflight) {
      inflight = Promise.resolve(fn(...args)).finally(() =&gt; {
        inflight = undefined;
      });
    }

    return inflight;
  };
}" data-lang="js"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token keyword">function</span> <span class="token function">hitch</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>  <span class="token keyword">let</span> inflight<span class="token punctuation">;</span></code><br></div><div><code></code><br></div><div><code>  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">hitchWrapper</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>inflight<span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>      inflight <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">finally</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></code><br></div><div><code>        inflight <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span></code><br></div><div><code>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>    <span class="token punctuation">}</span></code><br></div><div><code></code><br></div><div><code>    <span class="token keyword">return</span> inflight<span class="token punctuation">;</span></code><br></div><div><code>  <span class="token punctuation">}</span><span class="token punctuation">;</span></code><br></div><div><code><span class="token punctuation">}</span></code><br></div></pre></content-area></div></div><p>The <code class="inline">hitch()</code> function defines an <code class="inline">inflight</code> variable in the closure of the returned wrapper function. When called, the wrapper function checks the inflight variable, and if it is not set, assigns to it a promise which resolves to a call to the original function. The wrapper function returns this inflight promise, regardless of whether or not it was set by the call. Finally, we use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally"><code class="inline">Promise.prototype.finally()</code></a> to clean up the inflight promise when it settles, so that new calls to the original function can be made.</p><p>While this approach reduces the number of concurrent runs of an async function to one, it wouldn’t be correct for our use-case, insofar as by the time all promises settled, we might not yet have had an async run with the latest props for each component. Instead, we need a strategy which <em>enqueues</em> runs of async component functions so that when all promises settle, the element tree and rendered values reflect the latest props and state. We can tweak the <code class="inline">hitch()</code> function above as the alternative higher-order function <code class="inline">enqueue()</code> to demonstrate the logic we want.</p><div class="codeblock" data-code="function enqueue(fn) {
  let inflight;
  let enqueued;
  let latestArgs;
  return function enqueueWrapper(...args) {
    latestArgs = args;
    if (!inflight) {
      inflight = Promise.resolve(fn(...latestArgs)).finally(() =&gt; {
        inflight = enqueued;
        enqueued = undefined;
      });

      return inflight;
    } else if (!enqueued) {
      enqueued = inflight.then(() =&gt; fn(...latestArgs)).finally(() =&gt; {
        inflight = enqueued;
        enqueued = undefined;
      });
    }

    return enqueued;
  };
}" data-lang="js"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token keyword">function</span> <span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>  <span class="token keyword">let</span> inflight<span class="token punctuation">;</span></code><br></div><div><code>  <span class="token keyword">let</span> enqueued<span class="token punctuation">;</span></code><br></div><div><code>  <span class="token keyword">let</span> latestArgs<span class="token punctuation">;</span></code><br></div><div><code>  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">enqueueWrapper</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>    latestArgs <span class="token operator">=</span> args<span class="token punctuation">;</span></code><br></div><div><code>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>inflight<span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>      inflight <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>latestArgs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">finally</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></code><br></div><div><code>        inflight <span class="token operator">=</span> enqueued<span class="token punctuation">;</span></code><br></div><div><code>        enqueued <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span></code><br></div><div><code>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code></code><br></div><div><code>      <span class="token keyword">return</span> inflight<span class="token punctuation">;</span></code><br></div><div><code>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>enqueued<span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>      enqueued <span class="token operator">=</span> inflight<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>latestArgs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">finally</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></code><br></div><div><code>        inflight <span class="token operator">=</span> enqueued<span class="token punctuation">;</span></code><br></div><div><code>        enqueued <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span></code><br></div><div><code>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>    <span class="token punctuation">}</span></code><br></div><div><code></code><br></div><div><code>    <span class="token keyword">return</span> enqueued<span class="token punctuation">;</span></code><br></div><div><code>  <span class="token punctuation">}</span><span class="token punctuation">;</span></code><br></div><div><code><span class="token punctuation">}</span></code><br></div></pre></content-area></div></div><p>We’ve added two more variables to the wrapper function’s scope, <code class="inline">enqueued</code> and <code class="inline">latestArgs</code> . The returned wrapper function first checks if there is an inflight promise, and creates and returns this inflight promise if none exists. If an inflight promise does exist, the wrapper function checks if there is an <em>enqueued</em> promise of the original function, and creates it if it doesn’t exists. This enqueued run first waits for the <code class="inline">inflight</code> run to fulfill before calling the function again, and calls the function with <code class="inline">latestArgs</code>, which we set to the latest call’s arguments whenever the wrapper fuction is called. We return the enqueued promise whether or not the current wrapper call had created it. Finally, we use <code class="inline">Promise.prototype.finally()</code> on both the inflight and enqueued promises to advance and clear the queue.</p><p>This strategy can be expressed as the following promise diagram.</p><p><img src="../static/enqueuing.png" alt="Enqueuing"></p><p>In this diagram, because <code class="inline">B</code> and <code class="inline">C</code> are created while <code class="inline">A</code> is pending, we enqueue another run. However, only <code class="inline">C</code> actually does work, because by the time <code class="inline">A</code> finishes, we only re-invoke the function with <code class="inline">C</code>’s arguments, while <code class="inline">B</code>’s arguments would have been overwritten. This is a useful behavior for async components, because we don’t really care about obsolete props or element trees. Lastly, <code class="inline">D</code> starts while <code class="inline">C</code> is pending, so we schedule another run for <code class="inline">D</code>. Note that the original function is not invoked until the current run settles, so we again have a situation where there is only one concurrent run of the original function at a time.</p><h3>Implementation</h3><p>Here is the implementation of this enqueuing strategy for components.</p><div class="codeblock" data-code="--- a/crank.js
+++ b/crank.js
@@ -307,33 +307,35 @@ function unmount(renderer, el) {
 class Context {
   constructor(renderer, host, el) {
     this._renderer = renderer;
     this._host = host;
     this._el = el;
     this._iter = undefined;
     this._schedules = new Set();
+    this._inflight = undefined;
+    this._enqueued = undefined;

     // flags
     this._isUpdating = false;
     this._isIterating = false;
     this._isDone = false;
   }

   refresh() {
-    return stepCtx(this);
+    return runCtx(this);
   }

   schedule(callback) {
     this._schedules.add(callback);
   }

   *[Symbol.iterator]() {
     while (!this._isDone) {
       if (this._isIterating) {
         throw new Error(&quot;Context iterated twice without a yield&quot;);
       }

       this._isIterating = true;
       yield this._el.props;
     }
   }
 }
@@ -364,9 +366,32 @@ function stepCtx(ctx) {
   return updateCtxChildren(ctx, iteration.value);
 }

+function advanceCtx(ctx) {
+  ctx._inflight = ctx._enqueued;
+  ctx._enqueued = undefined;
+}
+
+function runCtx(ctx) {
+  if (!ctx._inflight) {
+    let value = stepCtx(ctx);
+    if (isPromiseLike(value)) {
+      value = value.finally(() =&gt; advanceCtx(ctx));
+      ctx._inflight = value;
+    }
+
+    return value;
+  } else if (!ctx._enqueued) {
+    ctx._enqueued = ctx._inflight
+      .then(() =&gt; stepCtx(ctx))
+      .finally(() =&gt; advanceCtx(ctx));
+  }
+
+  return ctx._enqueued;
+}
+
 function updateCtx(ctx) {
   ctx._isUpdating = true;
-  return stepCtx(ctx);
+  return runCtx(ctx);
 }

 function updateCtxChildren(ctx, children) {" data-lang="diff"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token coord">--- a/crank.js</span></code><br></div><div><code><span class="token coord">+++ b/crank.js</span></code><br></div><div><code>@@ -307,33 +307,35 @@ function unmount(renderer, el) {</code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">class Context {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  constructor(renderer, host, el) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._renderer = renderer;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._host = host;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._el = el;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._iter = undefined;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._schedules = new Set();</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    this._inflight = undefined;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    this._enqueued = undefined;</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    // flags</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._isUpdating = false;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._isIterating = false;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._isDone = false;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  refresh() {</span></span></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    return stepCtx(this);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    return runCtx(this);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  schedule(callback) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._schedules.add(callback);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  *[Symbol.iterator]() {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    while (!this._isDone) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      if (this._isIterating) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        throw new Error(&quot;Context iterated twice without a yield&quot;);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      this._isIterating = true;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      yield this._el.props;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code>@@ -364,9 +366,32 @@ function stepCtx(ctx) {</code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  return updateCtxChildren(ctx, iteration.value);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">function advanceCtx(ctx) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  ctx._inflight = ctx._enqueued;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  ctx._enqueued = undefined;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">}</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">function runCtx(ctx) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  if (!ctx._inflight) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let value = stepCtx(ctx);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    if (isPromiseLike(value)) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      value = value.finally(() =&gt; advanceCtx(ctx));</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      ctx._inflight = value;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    return value;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  } else if (!ctx._enqueued) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    ctx._enqueued = ctx._inflight</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      .then(() =&gt; stepCtx(ctx))</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      .finally(() =&gt; advanceCtx(ctx));</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  return ctx._enqueued;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">}</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">function updateCtx(ctx) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  ctx._isUpdating = true;</span></span></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  return stepCtx(ctx);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  return runCtx(ctx);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">function updateCtxChildren(ctx, children) {</span></span></code><br></div></pre></content-area></div></div><p><a href="https://github.com/brainkim/crank-from-scratch/commit/66a9459bd2fc11a2a3bd7bae9818394ad3902e67">Diff</a> <a href="https://github.com/brainkim/crank-from-scratch/blob/66a9459bd2fc11a2a3bd7bae9818394ad3902e67/crank.js">File</a></p><p>We define another context function <code class="inline">runCtx()</code>, which is where the enqueuing behavior is implemented, and call this function instead of <code class="inline">stepCtx()</code> in the <code class="inline">refresh()</code> method and the <code class="inline">updateCtx()</code> function. Rather than implementing the enqueuing algorithm with a higher-order function, we store the inflight and enqueued promises directly on component context. We do this because we’ll need to modify the algorithm in various ways for later steps.</p><p>Because the enqueuing state is stored on contexts, enqueuing only happens for components which are rerendered. If a different element is rendered into an old component element’s position, the old context is blown away, so no async enqueuing would occur. This means that element enqueuing happens based on the same element diffing algorithm which governs DOM node re-use and stateful components.</p><h2>Step 13: Async Children</h2><p>Another way to think about the enqueuing behavior in the previous step is that components are “blocked” from updates while they’re pending. However, the enqueuing algorithm we’ve implemented so far might “over-block,” in the sense that components currently block not only for their own async executions, but also for their children’s async executions as well. This enqueuing behavior will, for instance, cause a synchronous function component with async children to block for the duration of its children’s async rendering time, even though there really isn’t a need for sync function components to block at all.</p><p>Therefore, we need a way to distinguish a component’s own execution time from the rendering time of its children, and block the component accordingly. For maximal concurrency, a sync function component should never block for any reason, while an async function component should only block while the async function itself is executing, but not for the rendering of its children.</p><p>On the other hand, the API we created for sync generator components in a previous step, where we pass the rendered value of the generator component back in as its yield result, creates an expectation that sync generator components only resume when the previous children have fully rendered. If we broke this expectation, the value passed back in might be <code class="inline">undefined</code>, as the generator component’s children might still be pending. Therefore, we make sync generator components block while their children are asynchronously rendering.</p><h3>Implementation</h3><p>To implement this behavior, we’ll need to update the <code class="inline">stepCtx()</code> function so that it returns a tuple: the first member is a possible promise which indicates the amount of time the component should “block” for, and the second is the actual value for the current render of the component.</p><div class="codeblock" data-code="--- a/crank.js
+++ b/crank.js
@@ -307,35 +307,37 @@ function unmount(renderer, el) {
 class Context {
   constructor(renderer, host, el) {
     this._renderer = renderer;
     this._host = host;
     this._el = el;
     this._iter = undefined;
     this._schedules = new Set();
-    this._inflight = undefined;
-    this._enqueued = undefined;
+    this._inflightBlock = undefined;
+    this._inflightValue = undefined;
+    this._enqueuedBlock = undefined;
+    this._enqueuedValue = undefined;

     // flags
     this._isUpdating = false;
     this._isIterating = false;
     this._isDone = false;
   }

   refresh() {
     return runCtx(this);
   }

   schedule(callback) {
     this._schedules.add(callback);
   }

   *[Symbol.iterator]() {
     while (!this._isDone) {
       if (this._isIterating) {
         throw new Error(&quot;Context iterated twice without a yield&quot;);
       }

       this._isIterating = true;
       yield this._el.props;
     }
   }
 }
@@ -343,50 +345,66 @@ class Context {
 function stepCtx(ctx) {
   let initial = !ctx._iter;
   if (ctx._isDone) {
     return getValue(ctx._el);
   } else if (initial) {
     const value = ctx._el.tag.call(ctx, ctx._el.props);
     if (isIteratorLike(value)) {
       ctx._iter = value;
     } else if (isPromiseLike(value)) {
-      return Promise.resolve(value)
-        .then((value) =&gt; updateCtxChildren(ctx, value));
+      const block = Promise.resolve(value);
+      return [
+        block,
+        block.then((value) =&gt; updateCtxChildren(ctx, value)),
+      ];
     } else {
-      return updateCtxChildren(ctx, value);
+      return [undefined, updateCtxChildren(ctx, value)];
     }
   }

   const oldValue = initial ? undefined : getValue(ctx._el);
   const iteration = ctx._iter.next(oldValue);
   ctx._isIterating = false;
   if (iteration.done) {
     ctx._isDone = true;
   }

-  return updateCtxChildren(ctx, iteration.value);
+  const value = updateCtxChildren(ctx, iteration.value);
+  return [value, value];
 }

 function advanceCtx(ctx) {
-  ctx._inflight = ctx._enqueued;
-  ctx._enqueued = undefined;
+  ctx._inflightBlock = ctx._enqueuedBlock;
+  ctx._inflightValue = ctx._enqueuedValue;
+  ctx._enqueuedBlock = undefined;
+  ctx._enqueuedValue = undefined;
 }

 function runCtx(ctx) {
-  if (!ctx._inflight) {
-    let value = stepCtx(ctx);
+  if (!ctx._inflightBlock) {
+    let [block, value] = stepCtx(ctx);
+    if (isPromiseLike(block)) {
+      block = block.finally(() =&gt; advanceCtx(ctx));
+      ctx._inflightBlock = block;
+    }
+
     if (isPromiseLike(value)) {
-      value = value.finally(() =&gt; advanceCtx(ctx));
-      ctx._inflight = value;
+      ctx._inflightValue = value;
     }

     return value;
-  } else if (!ctx._enqueued) {
-    ctx._enqueued = ctx._inflight
-      .then(() =&gt; stepCtx(ctx))
+  } else if (!ctx._enqueuedBlock) {
+    let resolve;
+    ctx._enqueuedBlock = ctx._inflightBlock
+      .then(() =&gt; {
+        const [block, value] = stepCtx(ctx);
+        resolve(value);
+        return block;
+      })
       .finally(() =&gt; advanceCtx(ctx));
+    ctx._enqueuedValue = new Promise((resolve1) =&gt; (resolve = resolve1));
   }

-  return ctx._enqueued;
+  return ctx._enqueuedValue;
 }

 function updateCtx(ctx) {" data-lang="diff"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token coord">--- a/crank.js</span></code><br></div><div><code><span class="token coord">+++ b/crank.js</span></code><br></div><div><code>@@ -307,35 +307,37 @@ function unmount(renderer, el) {</code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">class Context {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  constructor(renderer, host, el) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._renderer = renderer;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._host = host;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._el = el;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._iter = undefined;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._schedules = new Set();</span></span></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    this._inflight = undefined;</span></span></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    this._enqueued = undefined;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    this._inflightBlock = undefined;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    this._inflightValue = undefined;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    this._enqueuedBlock = undefined;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    this._enqueuedValue = undefined;</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    // flags</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._isUpdating = false;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._isIterating = false;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._isDone = false;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  refresh() {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    return runCtx(this);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  schedule(callback) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._schedules.add(callback);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  *[Symbol.iterator]() {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    while (!this._isDone) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      if (this._isIterating) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        throw new Error(&quot;Context iterated twice without a yield&quot;);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      this._isIterating = true;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      yield this._el.props;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code>@@ -343,50 +345,66 @@ class Context {</code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">function stepCtx(ctx) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  let initial = !ctx._iter;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  if (ctx._isDone) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    return getValue(ctx._el);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  } else if (initial) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    const value = ctx._el.tag.call(ctx, ctx._el.props);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    if (isIteratorLike(value)) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      ctx._iter = value;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    } else if (isPromiseLike(value)) {</span></span></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">      return Promise.resolve(value)</span></span></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        .then((value) =&gt; updateCtxChildren(ctx, value));</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      const block = Promise.resolve(value);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      return [</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        block,</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        block.then((value) =&gt; updateCtxChildren(ctx, value)),</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      ];</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    } else {</span></span></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">      return updateCtxChildren(ctx, value);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      return [undefined, updateCtxChildren(ctx, value)];</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  const oldValue = initial ? undefined : getValue(ctx._el);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  const iteration = ctx._iter.next(oldValue);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  ctx._isIterating = false;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  if (iteration.done) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    ctx._isDone = true;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  return updateCtxChildren(ctx, iteration.value);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  const value = updateCtxChildren(ctx, iteration.value);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  return [value, value];</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">function advanceCtx(ctx) {</span></span></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  ctx._inflight = ctx._enqueued;</span></span></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  ctx._enqueued = undefined;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  ctx._inflightBlock = ctx._enqueuedBlock;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  ctx._inflightValue = ctx._enqueuedValue;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  ctx._enqueuedBlock = undefined;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  ctx._enqueuedValue = undefined;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">function runCtx(ctx) {</span></span></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  if (!ctx._inflight) {</span></span></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    let value = stepCtx(ctx);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  if (!ctx._inflightBlock) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let [block, value] = stepCtx(ctx);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    if (isPromiseLike(block)) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      block = block.finally(() =&gt; advanceCtx(ctx));</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      ctx._inflightBlock = block;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    if (isPromiseLike(value)) {</span></span></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">      value = value.finally(() =&gt; advanceCtx(ctx));</span></span></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">      ctx._inflight = value;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      ctx._inflightValue = value;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    return value;</span></span></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  } else if (!ctx._enqueued) {</span></span></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    ctx._enqueued = ctx._inflight</span></span></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">      .then(() =&gt; stepCtx(ctx))</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  } else if (!ctx._enqueuedBlock) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let resolve;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    ctx._enqueuedBlock = ctx._inflightBlock</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      .then(() =&gt; {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        const [block, value] = stepCtx(ctx);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        resolve(value);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        return block;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      })</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      .finally(() =&gt; advanceCtx(ctx));</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    ctx._enqueuedValue = new Promise((resolve1) =&gt; (resolve = resolve1));</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  return ctx._enqueued;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  return ctx._enqueuedValue;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">function updateCtx(ctx) {</span></span></code><br></div></pre></content-area></div></div><p><a href="https://github.com/brainkim/crank-from-scratch/commit/caf7632e27d89236b06855a5c63b8e812c060a66">Diff</a> <a href="https://github.com/brainkim/crank-from-scratch/blob/caf7632e27d89236b06855a5c63b8e812c060a66/crank.js">File</a></p><p>We keep the inflight/enqueued pattern from the previous step, except now we advance the queue based on the blocking portion of the render. A promise diagram for this algorithm might look like this.</p><p><img src="../static/partial-enqueuing.png" alt="Partial Enqueuing"></p><p>The blue segments represent the duration for which the component is blocked, while the blue + black segments represent the duration for the entire render. As you can see, this allows for greater concurrency with regard to rendering, while still limiting the number of concurrent runs for each individual async component element to one.</p><h2>Step 14: Chasing</h2><p>Before we continue, we need to deal with a race condition with regard to async rendering. Although we’ve implemented enqueuing logic for when we rerender the <em>same</em> async components, if we were to render different element trees which settled out of order, we might have earlier element trees render after later ones.</p><div class="codeblock" data-code="async function DelayedGreeting({name}) {
  await new Promise((resolve) =&gt; setTimeout(resolve, 2000));
  return &lt;div&gt;Hello &lt;span style=&quot;color: red&quot;&gt;{name}&lt;/span&gt;&lt;/div&gt;;
}

const p = renderer.render(&lt;DelayedGreeting name=&quot;World&quot;/&gt;, app);
renderer.render(&lt;div&gt;Never mind&lt;/div&gt;, app);
console.log(app.innerHTML); // &lt;div&gt;Never mind&lt;/div&gt;
await p;
console.log(app.innerHTML);
// Expected: &lt;div&gt;Never mind&lt;/div&gt;
// Actual: &lt;div&gt;Hello &lt;span style=&quot;color: red&quot;&gt;World&lt;/span&gt;&lt;/div&gt;
" data-lang="jsx"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">DelayedGreeting</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>name<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>  <span class="token keyword">await</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>Hello <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token value css language-css"><span class="token property">color</span><span class="token punctuation">:</span> red</span><span class="token punctuation">&quot;</span></span></span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>name<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span></code><br></div><div><code><span class="token punctuation">}</span></code><br></div><div><code></code><br></div><div><code><span class="token keyword">const</span> p <span class="token operator">=</span> renderer<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">DelayedGreeting</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>World<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span><span class="token punctuation">,</span> app<span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>renderer<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>Never mind<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> app<span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>app<span class="token punctuation">.</span>innerHTML<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &lt;div&gt;Never mind&lt;/div&gt;</span></code><br></div><div><code><span class="token keyword">await</span> p<span class="token punctuation">;</span></code><br></div><div><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>app<span class="token punctuation">.</span>innerHTML<span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code><span class="token comment">// Expected: &lt;div&gt;Never mind&lt;/div&gt;</span></code><br></div><div><code><span class="token comment">// Actual: &lt;div&gt;Hello &lt;span style=&quot;color: red&quot;&gt;World&lt;/span&gt;&lt;/div&gt;</span></code><br></div></pre></content-area></div></div><p>We want rendering to ignore outdated renders just as async component enqueuing ignores outdated props and children. To achieve this, we use another promise technique called <em>chasing.</em> Chasing involves racing the current call of an async function with the next call, for every call. Visually, we can represent chasing like so.</p><p><img src="../static/chasing.png" alt="Chasing"></p><p>In the diagram, the <code class="inline">B</code> promise takes longer to settle than the <code class="inline">C</code> promise, so the <code class="inline">B</code> promise is cut off and made to resolve to the <code class="inline">C</code> promise. We can represent this algorithm as the following higher-order function.</p><div class="codeblock" data-code="function chase(fn) {
  let resolve = () =&gt; {};

  return function chaseWrapper(...args) {
    let resolve1;
    const next = new Promise((resolve2) =&gt; (resolve1 = resolve2));
    const result = Promise.race([fn(...args), next]);
    resolve(result);
    resolve = resolve1;
    return result;
  };
}" data-lang="js"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token keyword">function</span> <span class="token function">chase</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>  <span class="token keyword">let</span> <span class="token function-variable function">resolve</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code><br></div><div><code></code><br></div><div><code>  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">chaseWrapper</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>    <span class="token keyword">let</span> resolve1<span class="token punctuation">;</span></code><br></div><div><code>    <span class="token keyword">const</span> next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve2</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>resolve1 <span class="token operator">=</span> resolve2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>    <span class="token keyword">const</span> result <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">race</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">,</span> next<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>    <span class="token function">resolve</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>    resolve <span class="token operator">=</span> resolve1<span class="token punctuation">;</span></code><br></div><div><code>    <span class="token keyword">return</span> result<span class="token punctuation">;</span></code><br></div><div><code>  <span class="token punctuation">}</span><span class="token punctuation">;</span></code><br></div><div><code><span class="token punctuation">}</span></code><br></div></pre></content-area></div></div><p>The <code class="inline">chase</code> function returns a wrapper function which calls the original function, but races each call with the next. We achieve this by creating a promise with the <code class="inline">Promise</code> constructor for each call, and retaining the <code class="inline">resolve</code> function of this promise in the wrapper function’s closure. We then call the previous <code class="inline">resolve</code> function with the result of the next race, and swap in the next <code class="inline">resolve</code> function for future calls.</p><p>The part of this algorithm that will probably hurt your brain is that we don’t just call the previous <code class="inline">resolve</code> function with the next result, but with a <em>race</em> of the next result and the result after; in effect, this means that all calls are raced not only with their immediate successor, but with every future call as well. This is possible because the <code class="inline">resolve</code> function can be called with a promise, a feature which not many JavaScript developers know about or use.</p><p>The cool part about this strategy is that it chains, so that when any call settles, we know for a fact that <em>all</em> previous calls have settled as well. You can prove this mathematically with a <a href="https://en.wikipedia.org/wiki/Mathematical_induction">proof by induction</a>, or visually with a promise diagram.</p><p><img src="../static/chained-chasing.png" alt="Chained Chasing"></p><p>Proving that this algorithm works to settle all previous promises is as simple as drawing a vertical line upwards from the end of any promise in any promise diagram.</p><h3>Implementation</h3><p>We use this chasing strategy in Crank by chasing the pending child values of an element with future child values for the element. We do this for every element, regardless of whether it is a host or component element.</p><div class="codeblock" data-code="--- a/crank.js
+++ b/crank.js
@@ -25,13 +25,14 @@ function isPromiseLike(value) {
 class Element {
   constructor(tag, props) {
     this.tag = tag;
     this.props = props;

     this._node = undefined;
     this._children = undefined;
     this._ctx = undefined;
+    this._onvalues = undefined;

     // flags
     this._isMounted = false;
   }
 }
@@ -236,42 +237,55 @@ function update(renderer, host, el) {
 function updateChildren(renderer, host, el, newChildren) {
   const oldChildren = wrap(el._children);
   newChildren = arrayify(newChildren);
   const children = [];
   let values = [];
   const length = Math.max(oldChildren.length, newChildren.length);
   for (let i = 0; i &lt; length; i++) {
     const oldChild = oldChildren[i];
     let newChild = narrow(newChildren[i]);
     const [child, value] = diff(renderer, host, oldChild, newChild);
     if (oldChild instanceof Element &amp;&amp; child !== oldChild) {
       unmount(renderer, oldChild);
     }

     children.push(child);
     if (value) {
       values.push(value);
     }
   }

   el._children = unwrap(children);
   if (values.some((value) =&gt; isPromiseLike(value))) {
     values = Promise.all(values).finally(() =&gt; {
       for (const oldChild of oldChildren.slice(length)) {
         if (oldChild instanceof Element) {
           unmount(renderer, oldChild);
         }
       }
     });

+    let onvalues;
+    const nextValues = new Promise((resolve) =&gt; (onvalues = resolve));
+    values = Promise.race([values, nextValues]);
+    if (el._onvalues) {
+      el._onvalues(values);
+    }
+
+    el._onvalues = onvalues;
     return values.then((values) =&gt; commit(renderer, el, normalize(values)));
   }

   for (const oldChild of oldChildren.slice(length)) {
     if (oldChild instanceof Element) {
       unmount(renderer, oldChild);
     }
   }

+  if (el._onvalues) {
+    el._onvalues(values);
+    el._onvalues = undefined;
+  }
+
   return commit(renderer, el, normalize(values));
 }" data-lang="diff"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token coord">--- a/crank.js</span></code><br></div><div><code><span class="token coord">+++ b/crank.js</span></code><br></div><div><code>@@ -25,13 +25,14 @@ function isPromiseLike(value) {</code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">class Element {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  constructor(tag, props) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this.tag = tag;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this.props = props;</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._node = undefined;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._children = undefined;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._ctx = undefined;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    this._onvalues = undefined;</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    // flags</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._isMounted = false;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code>@@ -236,42 +237,55 @@ function update(renderer, host, el) {</code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">function updateChildren(renderer, host, el, newChildren) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  const oldChildren = wrap(el._children);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  newChildren = arrayify(newChildren);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  const children = [];</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  let values = [];</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  const length = Math.max(oldChildren.length, newChildren.length);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  for (let i = 0; i &lt; length; i++) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    const oldChild = oldChildren[i];</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    let newChild = narrow(newChildren[i]);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    const [child, value] = diff(renderer, host, oldChild, newChild);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    if (oldChild instanceof Element &amp;&amp; child !== oldChild) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      unmount(renderer, oldChild);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    children.push(child);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    if (value) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      values.push(value);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  el._children = unwrap(children);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  if (values.some((value) =&gt; isPromiseLike(value))) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    values = Promise.all(values).finally(() =&gt; {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      for (const oldChild of oldChildren.slice(length)) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        if (oldChild instanceof Element) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">          unmount(renderer, oldChild);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    });</span></span></code><br></div><div><code></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let onvalues;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    const nextValues = new Promise((resolve) =&gt; (onvalues = resolve));</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    values = Promise.race([values, nextValues]);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    if (el._onvalues) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      el._onvalues(values);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    el._onvalues = onvalues;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    return values.then((values) =&gt; commit(renderer, el, normalize(values)));</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  for (const oldChild of oldChildren.slice(length)) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    if (oldChild instanceof Element) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      unmount(renderer, oldChild);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  if (el._onvalues) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    el._onvalues(values);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    el._onvalues = undefined;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  return commit(renderer, el, normalize(values));</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div></pre></content-area></div></div><p><a href="https://github.com/brainkim/crank-from-scratch/commit/f4ab9d5a2738026ce52c5bc4b82de3529aad34bc">Diff</a> <a href="https://github.com/brainkim/crank-from-scratch/blob/f4ab9d5a2738026ce52c5bc4b82de3529aad34bc/crank.js">File</a></p><p>Once again we don’t use a higher-order function, but retain the <code class="inline">resolve()</code> function of future child values directly on elements under the property <code class="inline">onvalues</code>. We set <code class="inline">onvalues</code> whenever we detect async rendering to have occurred below the element, and call it whenever the element has new child values.</p><p><strong>Notes:</strong></p><ol><li>Because we don’t cancel earlier renders of an element’s children when later renders fulfill, we may end up calling <code class="inline">commit()</code> with the same values multiple times in the case where a later render fulfills first. This isn’t really an issue because concurrent renderings don’t happen too often, and because the <code class="inline">commit()</code> function is <a href="https://en.wikipedia.org/wiki/Idempotence"><em>idempotent</em></a>, so calling it multiple times with the same element and values will have no effect.</li></ol><h2>Step 15: Async Generator Components</h2><p>The examples of concurrent rendering which we’ve seen so far have all worked based on top-level <code class="inline">render</code> calls. Furthermore, the behavior of sync generator components, which block based on their children’s async rendering time, means that we can’t call <code class="inline">refresh()</code> from a sync generator component to perform concurrent renderings. Therefore, we’ll use <em>async generator functions</em> as a final component type to allow components to concurrently render multiple element trees in the same position.</p><p>To review, an async generator function is another function syntax which combines both the <code class="inline">*</code> token from generator functions, and the <code class="inline">async</code> keyword from async functions (<code class="inline">async function *</code>). This allows us to both <code class="inline">yield</code> and <code class="inline">await</code> in the same function. Async generators also come with async equivalents of iterators, iterables and <code class="inline">for…of</code> syntax. Async generators are <em>async iterators</em> in that they implement the <code class="inline">next()</code>, <code class="inline">return()</code> and <code class="inline">throw()</code> methods, except instead of returning iterations as with sync iterators, these methods now return promises which resolve to iterations. Additionally, async generators are <em>async iterable</em> insofar as it implements the <code class="inline">[Symbol.asyncIterator]()</code> method. Finally, async iterables can be iterated using <code class="inline">for await…of</code>, a special for loop syntax which awaits each iteration of an async iterator. This syntax may only be used in async functions, just like <code class="inline">await</code>.</p><p>By writing async generator functions which yield element trees, we can combine both the statefulness of generator functions and the convenience of async/await in the same component. Additionally, we’ll make component contexts <em>async iterables</em> of props, so that async generator components can respond to updates asynchronously with a <code class="inline">for await…of</code> loops. Importantly, this allows us to resume async generator components continuously, so that rather than suspending on each yield, we can write code both before and after the yields of element trees.</p><div class="codeblock" data-code="async function* ContinuousGreeting({name}) {
  for await ({} of this) {
    console.log(&quot;Before render&quot;);
    const div = yield &lt;div&gt;Hello &lt;span style=&quot;color: red&quot;&gt;{name}&lt;/span&gt;&lt;/div&gt;;
    console.log(&quot;After render&quot;, div);
  }
}" data-lang="jsx"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token keyword">async</span> <span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">ContinuousGreeting</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>name<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>  <span class="token keyword">for</span> <span class="token keyword">await</span> <span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">of</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Before render&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>    <span class="token keyword">const</span> div <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>Hello <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token value css language-css"><span class="token property">color</span><span class="token punctuation">:</span> red</span><span class="token punctuation">&quot;</span></span></span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>name<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span></code><br></div><div><code>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;After render&quot;</span><span class="token punctuation">,</span> div<span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>  <span class="token punctuation">}</span></code><br></div><div><code><span class="token punctuation">}</span></code><br></div></pre></content-area></div></div><p>For each render of <code class="inline">ContinuousGreeting</code>, both the pre- and post- <code class="inline"> console.log</code> calls execute. Note that assigning the yield operation (here to the variable <code class="inline">div</code>) becomes more useful than it was for sync generator components. The <code class="inline">for await ({} of this)</code> is how we can have the async generator continuously resume but still suspend when there are no new updates or refreshes.</p><p>Async generator components are the most powerful component syntax, because they can await promises, respond to updates as async values themselves, and even yield multiple element trees concurrently. This allows us to write code like the following.</p><div class="codeblock" data-code="async function LoadingIndicator() {
  await new Promise((resolve) =&gt; setTimeout(resolve, 1000));
  return &lt;div&gt;Loading…&lt;/div&gt;;
}

async function RandomDelayGreeting({name}) {
  await new Promise((resolve) =&gt; setTimeout(resolve, Math.random() * 4000));
  return &lt;div&gt;Hello &lt;span style=&quot;color: red&quot;&gt;{name}&lt;/span&gt;&lt;/div&gt;;
}

async function *LoadingGreeting({name}) {
  for await ({name} of this) {
    yield &lt;LoadingIndicator /&gt;;
    yield &lt;RandomDelayGreeting name={name} /&gt;;
  }
}" data-lang="jsx"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">LoadingIndicator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>  <span class="token keyword">await</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>Loading…<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span></code><br></div><div><code><span class="token punctuation">}</span></code><br></div><div><code></code><br></div><div><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">RandomDelayGreeting</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>name<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>  <span class="token keyword">await</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">4000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>Hello <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token value css language-css"><span class="token property">color</span><span class="token punctuation">:</span> red</span><span class="token punctuation">&quot;</span></span></span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>name<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span></code><br></div><div><code><span class="token punctuation">}</span></code><br></div><div><code></code><br></div><div><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token operator">*</span><span class="token function">LoadingGreeting</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>name<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>  <span class="token keyword">for</span> <span class="token keyword">await</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>name<span class="token punctuation">}</span> <span class="token keyword">of</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>    <span class="token keyword">yield</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">LoadingIndicator</span></span> <span class="token punctuation">/&gt;</span></span><span class="token punctuation">;</span></code><br></div><div><code>    <span class="token keyword">yield</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">RandomDelayGreeting</span></span> <span class="token attr-name">name</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>name<span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span><span class="token punctuation">;</span></code><br></div><div><code>  <span class="token punctuation">}</span></code><br></div><div><code><span class="token punctuation">}</span></code><br></div></pre></content-area></div></div><p>Because this async generator component resumes continuously, it will concurrently attempt to render both the <code class="inline">LoadingIndicator</code> component, which fulfills after one second, and the <code class="inline">RandomDelayGreeting</code> component, which fulfills randomly between zero and four seconds, as its children. If the <code class="inline">RandomDelayGreeting</code> component takes longer than a second, we’ll see the loading indicator after a second, and if it takes less than a second, we’ll never see the loading indicator. This is because of the chasing behavior of elements which we defined in the previous step.</p><h3>Implementation</h3><div class="codeblock" data-code="--- a/crank.js
+++ b/crank.js
@@ -321,67 +321,109 @@ function unmount(renderer, el) {
 class Context {
   constructor(renderer, host, el) {
     this._renderer = renderer;
     this._host = host;
     this._el = el;
     this._iter = undefined;
     this._schedules = new Set();
+    this._onavailable = undefined;
     this._inflightBlock = undefined;
     this._inflightValue = undefined;
     this._enqueuedBlock = undefined;
     this._enqueuedValue = undefined;

     // flags
     this._isUpdating = false;
     this._isIterating = false;
     this._isDone = false;
+    this._isAvailable = false;
+    this._isAsyncIterator = false;
   }

   refresh() {
+    resumeCtx(this);
     return runCtx(this);
   }

   schedule(callback) {
     this._schedules.add(callback);
   }

   *[Symbol.iterator]() {
     while (!this._isDone) {
       if (this._isIterating) {
         throw new Error(&quot;Context iterated twice without a yield&quot;);
       }

       this._isIterating = true;
       yield this._el.props;
     }
   }
+
+  async *[Symbol.asyncIterator]() {
+    do {
+      if (this._isIterating) {
+        throw new Error(&quot;Context iterated twice without a yield&quot;);
+      }
+
+      this._isIterating = true;
+      if (this._isAvailable) {
+        this._isAvailable = false;
+      } else {
+        await new Promise((resolve) =&gt; (this._onavailable = resolve));
+        if (this._unmounted) {
+          break;
+        }
+      }
+
+      yield this._el.props;
+    } while (!this._isUnmounted);
+  }
 }

 function stepCtx(ctx) {
   let initial = !ctx._iter;
   if (ctx._isDone) {
     return getValue(ctx._el);
   } else if (initial) {
     const value = ctx._el.tag.call(ctx, ctx._el.props);
     if (isIteratorLike(value)) {
       ctx._iter = value;
     } else if (isPromiseLike(value)) {
       const block = Promise.resolve(value);
       return [
         block,
         block.then((value) =&gt; updateCtxChildren(ctx, value)),
       ];
     } else {
       return [undefined, updateCtxChildren(ctx, value)];
     }
   }

   const oldValue = initial ? undefined : getValue(ctx._el);
   const iteration = ctx._iter.next(oldValue);
+  if (isPromiseLike(iteration)) {
+    if (initial) {
+      ctx._isAsyncIterator = true;
+    }
+
+    const block = iteration;
+    const value = iteration.then((iteration) =&gt; {
+      ctx._isIterating = false;
+      if (iteration.done) {
+        ctx._done = true;
+      }
+
+      return updateCtxChildren(ctx, iteration.value);
+    });
+
+    return [block, value];
+  }
+
   ctx._isIterating = false;
   if (iteration.done) {
     ctx._isDone = true;
   }

   const value = updateCtxChildren(ctx, iteration.value);
   return [value, value];
 }
@@ -389,40 +431,55 @@ function stepCtx(ctx) {
 function advanceCtx(ctx) {
   ctx._inflightBlock = ctx._enqueuedBlock;
   ctx._inflightValue = ctx._enqueuedValue;
   ctx._enqueuedBlock = undefined;
   ctx._enqueuedValue = undefined;
+  if (ctx._isAsyncIterator) {
+    runCtx(ctx);
+  }
 }

 function runCtx(ctx) {
   if (!ctx._inflightBlock) {
     let [block, value] = stepCtx(ctx);
     if (isPromiseLike(block)) {
       block = block.finally(() =&gt; advanceCtx(ctx));
       ctx._inflightBlock = block;
     }

     if (isPromiseLike(value)) {
       ctx._inflightValue = value;
     }

     return value;
+  } else if (ctx._isAsyncIterator) {
+    return ctx._inflightValue;
   } else if (!ctx._enqueuedBlock) {
     let resolve;
     ctx._enqueuedBlock = ctx._inflightBlock
       .then(() =&gt; {
         const [block, value] = stepCtx(ctx);
         resolve(value);
         return block;
       })
       .finally(() =&gt; advanceCtx(ctx));
     ctx._enqueuedValue = new Promise((resolve1) =&gt; (resolve = resolve1));
   }

   return ctx._enqueuedValue;
 }

+function resumeCtx(ctx) {
+  if (ctx._onavailable) {
+    ctx._onavailable();
+    ctx._onavailable = undefined;
+  } else if (!ctx._isAvailable) {
+    ctx._isAvailable = true;
+  }
+}
+
 function updateCtx(ctx) {
   ctx._isUpdating = true;
+  resumeCtx(ctx);
   return runCtx(ctx);
 }

@@ -453,8 +510,9 @@ function commitCtx(ctx, values) {
 function unmountCtx(ctx) {
   if (!ctx._isDone) {
     ctx._isDone = true;
+    resumeCtx(ctx);
     if (ctx._iterator &amp;&amp; typeof ctx._iterator.return === &quot;function&quot;) {
       ctx._iterator.return();
     }
   }
 }" data-lang="diff"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token coord">--- a/crank.js</span></code><br></div><div><code><span class="token coord">+++ b/crank.js</span></code><br></div><div><code>@@ -321,67 +321,109 @@ function unmount(renderer, el) {</code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">class Context {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  constructor(renderer, host, el) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._renderer = renderer;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._host = host;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._el = el;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._iter = undefined;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._schedules = new Set();</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    this._onavailable = undefined;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._inflightBlock = undefined;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._inflightValue = undefined;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._enqueuedBlock = undefined;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._enqueuedValue = undefined;</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    // flags</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._isUpdating = false;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._isIterating = false;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._isDone = false;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    this._isAvailable = false;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    this._isAsyncIterator = false;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  refresh() {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    resumeCtx(this);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    return runCtx(this);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  schedule(callback) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._schedules.add(callback);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  *[Symbol.iterator]() {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    while (!this._isDone) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      if (this._isIterating) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        throw new Error(&quot;Context iterated twice without a yield&quot;);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      this._isIterating = true;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      yield this._el.props;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  async *[Symbol.asyncIterator]() {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    do {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      if (this._isIterating) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        throw new Error(&quot;Context iterated twice without a yield&quot;);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      this._isIterating = true;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      if (this._isAvailable) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        this._isAvailable = false;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      } else {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        await new Promise((resolve) =&gt; (this._onavailable = resolve));</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        if (this._unmounted) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">          break;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      yield this._el.props;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    } while (!this._isUnmounted);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">function stepCtx(ctx) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  let initial = !ctx._iter;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  if (ctx._isDone) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    return getValue(ctx._el);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  } else if (initial) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    const value = ctx._el.tag.call(ctx, ctx._el.props);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    if (isIteratorLike(value)) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      ctx._iter = value;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    } else if (isPromiseLike(value)) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      const block = Promise.resolve(value);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      return [</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        block,</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        block.then((value) =&gt; updateCtxChildren(ctx, value)),</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      ];</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    } else {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      return [undefined, updateCtxChildren(ctx, value)];</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  const oldValue = initial ? undefined : getValue(ctx._el);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  const iteration = ctx._iter.next(oldValue);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  if (isPromiseLike(iteration)) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    if (initial) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      ctx._isAsyncIterator = true;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    const block = iteration;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    const value = iteration.then((iteration) =&gt; {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      ctx._isIterating = false;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      if (iteration.done) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        ctx._done = true;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      return updateCtxChildren(ctx, iteration.value);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    });</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    return [block, value];</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  ctx._isIterating = false;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  if (iteration.done) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    ctx._isDone = true;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  const value = updateCtxChildren(ctx, iteration.value);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  return [value, value];</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code>@@ -389,40 +431,55 @@ function stepCtx(ctx) {</code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">function advanceCtx(ctx) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  ctx._inflightBlock = ctx._enqueuedBlock;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  ctx._inflightValue = ctx._enqueuedValue;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  ctx._enqueuedBlock = undefined;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  ctx._enqueuedValue = undefined;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  if (ctx._isAsyncIterator) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    runCtx(ctx);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">function runCtx(ctx) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  if (!ctx._inflightBlock) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    let [block, value] = stepCtx(ctx);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    if (isPromiseLike(block)) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      block = block.finally(() =&gt; advanceCtx(ctx));</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      ctx._inflightBlock = block;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    if (isPromiseLike(value)) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      ctx._inflightValue = value;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    return value;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  } else if (ctx._isAsyncIterator) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    return ctx._inflightValue;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  } else if (!ctx._enqueuedBlock) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    let resolve;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    ctx._enqueuedBlock = ctx._inflightBlock</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      .then(() =&gt; {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        const [block, value] = stepCtx(ctx);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        resolve(value);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        return block;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      })</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      .finally(() =&gt; advanceCtx(ctx));</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    ctx._enqueuedValue = new Promise((resolve1) =&gt; (resolve = resolve1));</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  return ctx._enqueuedValue;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">function resumeCtx(ctx) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  if (ctx._onavailable) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    ctx._onavailable();</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    ctx._onavailable = undefined;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  } else if (!ctx._isAvailable) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    ctx._isAvailable = true;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">}</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">function updateCtx(ctx) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  ctx._isUpdating = true;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  resumeCtx(ctx);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  return runCtx(ctx);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code></code><br></div><div><code>@@ -453,8 +510,9 @@ function commitCtx(ctx, values) {</code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">function unmountCtx(ctx) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  if (!ctx._isDone) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    ctx._isDone = true;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    resumeCtx(ctx);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    if (ctx._iterator &amp;&amp; typeof ctx._iterator.return === &quot;function&quot;) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      ctx._iterator.return();</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div></pre></content-area></div></div><p><a href="https://github.com/brainkim/crank-from-scratch/commit/208a71ff2d82fd202c6a4331d85b1493f8a09605">Diff</a> <a href="https://github.com/brainkim/crank-from-scratch/blob/208a71ff2d82fd202c6a4331d85b1493f8a09605/crank.js">File</a></p><p>To implement the continuous resuming behavior of async generator components, we call <code class="inline">runCtx()</code> in the <code class="inline">advanceCtx()</code> function. This continuous resuming behavior does not mesh well with the standard enqueuing behavior in <code class="inline">runCtx()</code>, so we use the hitching strategy described previously rather than the enqueuing strategy for async generator components.</p><p>To implement the context’s props async iterator, we define a  <code class="inline">resumeCtx()</code> function and a <code class="inline">[Symbol.asyncIterator]()</code> async generator method. The <code class="inline">resumeCtx()</code> function is called by both <code class="inline">refresh()</code> and <code class="inline">updateCtx()</code> to ensure the <code class="inline">for await…of</code> loop over <code class="inline">this</code> resumes when the component is ready to rerender. It’s important to note that if there are concurrent renderings of an async generator component, earlier props will be overwritten, just as with regular async function components. The context async iterator always yields the latest props available.</p><p>We again distinguish async generator components from other components by return types exclusively. An async generator component can be determined by the fact that the function returns an iterator, and can furthermore be distinguished from sync generator components by the fact that calls to the iterator’s <code class="inline">next()</code> method returns a promise.</p><h2>Step 16: Async Values and Fallbacks</h2><p>Before we conclude, we’ll fix two tricky bugs related to async components and concurrent rendering.</p><p>First, we need to deal with async generator components which have async children. Because they resume continuously, an async generator component which yields async children may have <code class="inline">undefined</code> passed back into the generator. This feels incorrect, and the most natural behavior in this situation would be for a promise to be passed back in which resolves to the rendered DOM nodes. This would allow async generator components to await the rendering of their own children just like any other promise.</p><div class="codeblock" data-code="async function DelayedGreeting({name}) {
  await new Promise((resolve) =&gt; setTimeout(resolve, 2000));
  return &lt;div&gt;Hello &lt;span style=&quot;color: red&quot;&gt;{name}&lt;/span&gt;&lt;/div&gt;;
}

async function *ImperativeGreeting({name}) {
  for await ({name} of this) {
    const div = await (yield &lt;DelayedGreeting name={name} /&gt;);
    console.log(div);
    // Expected: an HTMLDivElement
    // Actual: undefined
  }
}" data-lang="jsx"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">DelayedGreeting</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>name<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>  <span class="token keyword">await</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>Hello <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token value css language-css"><span class="token property">color</span><span class="token punctuation">:</span> red</span><span class="token punctuation">&quot;</span></span></span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>name<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span></code><br></div><div><code><span class="token punctuation">}</span></code><br></div><div><code></code><br></div><div><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token operator">*</span><span class="token function">ImperativeGreeting</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>name<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>  <span class="token keyword">for</span> <span class="token keyword">await</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>name<span class="token punctuation">}</span> <span class="token keyword">of</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>    <span class="token keyword">const</span> div <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token punctuation">(</span><span class="token keyword">yield</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">DelayedGreeting</span></span> <span class="token attr-name">name</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>name<span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>div<span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>    <span class="token comment">// Expected: an HTMLDivElement</span></code><br></div><div><code>    <span class="token comment">// Actual: undefined</span></code><br></div><div><code>  <span class="token punctuation">}</span></code><br></div><div><code><span class="token punctuation">}</span></code><br></div></pre></content-area></div></div><p>Second, we have to make concurrent renderings work with the rearranging logic we defined in a previous step. Currently, DOM nodes may end up disappearing because the <code class="inline">getValues()</code>/<code class="inline">getChildValues()</code> functions read pending async elements which have never rendered as <code class="inline">undefined</code>. This means that if we refresh a component which has pending children, the <code class="inline">arrange()</code> method will be called on the nearest ancestor host element and the previously rendered children will be erased. This bug is difficult to demonstrate, and will only manifest as rendered DOM nodes briefly disappearing from the DOM when <code class="inline">refresh</code> is called in certain situations.</p><div class="codeblock" data-code="async function *LoadingGreeting({name}) {
  // Calling this.refresh called after LoadingIndicator settles
  // but before DelayedGreeting settles.
  setTimeout(async () =&gt; {
    await this.refresh();
    console.log(app.innerHTML);
    // Expected: &quot;&lt;div&gt;Loading…&lt;/div&gt;&quot;
    // Actual: &quot;&quot;
  }, 1500);
  for await ({name} of this) {
    yield &lt;LoadingIndicator /&gt;;
    yield &lt;DelayedGreeting name={name} /&gt;;
  }
}" data-lang="jsx"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token operator">*</span><span class="token function">LoadingGreeting</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>name<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>  <span class="token comment">// Calling this.refresh called after LoadingIndicator settles</span></code><br></div><div><code>  <span class="token comment">// but before DelayedGreeting settles.</span></code><br></div><div><code>  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></code><br></div><div><code>    <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>app<span class="token punctuation">.</span>innerHTML<span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>    <span class="token comment">// Expected: &quot;&lt;div&gt;Loading…&lt;/div&gt;&quot;</span></code><br></div><div><code>    <span class="token comment">// Actual: &quot;&quot;</span></code><br></div><div><code>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1500</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>  <span class="token keyword">for</span> <span class="token keyword">await</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>name<span class="token punctuation">}</span> <span class="token keyword">of</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>    <span class="token keyword">yield</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">LoadingIndicator</span></span> <span class="token punctuation">/&gt;</span></span><span class="token punctuation">;</span></code><br></div><div><code>    <span class="token keyword">yield</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">DelayedGreeting</span></span> <span class="token attr-name">name</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>name<span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span><span class="token punctuation">;</span></code><br></div><div><code>  <span class="token punctuation">}</span></code><br></div><div><code><span class="token punctuation">}</span></code><br></div></pre></content-area></div></div><p>What we want is for whatever was previously rendered in a pending async element’s position to continue to be rendered until the element has rendered at least once.</p><h3>Implementation</h3><div class="codeblock" data-code="--- a/crank.js
+++ b/crank.js
@@ -25,14 +25,15 @@ function isPromiseLike(value) {
 class Element {
   constructor(tag, props) {
     this.tag = tag;
     this.props = props;

     this._node = undefined;
     this._children = undefined;
     this._ctx = undefined;
     this._onvalues = undefined;
+    this._fallback = undefined;

     // flags
     this._isMounted = false;
   }
 }
@@ -105,11 +106,17 @@ function normalize(values) {
 }

 function getValue(el) {
-  if (el.tag === Portal) {
+  if (el._fallback) {
+    if (el._fallback instanceof Element) {
+      return getValue(el._fallback);
+    }
+
+    return el._fallback;
+  } else if (el.tag === Portal) {
     return undefined;
   } else if (typeof el.tag !== &quot;function&quot; &amp;&amp; el.tag !== Fragment) {
     return el._node;
   }

   return unwrap(getChildValues(el));
 }
@@ -197,21 +204,25 @@ export class Renderer {
 function diff(renderer, host, oldChild, newChild) {
   if (
     oldChild instanceof Element &amp;&amp;
     newChild instanceof Element &amp;&amp;
     oldChild.tag === newChild.tag
   ) {
     if (oldChild !== newChild) {
       oldChild.props = newChild.props;
       newChild = oldChild;
     }
   }

   let value;
   if (newChild instanceof Element) {
+    const initial = !newChild._isMounted;
     value = update(renderer, host, newChild);
+    if (initial &amp;&amp; isPromiseLike(value)) {
+      newChild._fallback = oldChild;
+    }
   } else {
     value = newChild;
   }

   return [newChild, value];
 }
@@ -290,18 +301,19 @@ function updateChildren(renderer, host, el, newChildren) {
 }

 function commit(renderer, el, values) {
+  el._fallback = undefined;
   if (typeof el.tag === &quot;function&quot;) {
     return commitCtx(el._ctx, values);
   } else if (el.tag === Fragment) {
     return unwrap(values);
   } else if (el.tag === Portal) {
     renderer.arrange(el, el.props.root, values);
     return undefined;
   } else if (!el._node) {
     el._node = renderer.create(el);
   }

   renderer.patch(el, el._node);
   renderer.arrange(el, el._node, values);
   return el._node;
 }
@@ -321,61 +333,62 @@ function unmount(renderer, el) {
 class Context {
   constructor(renderer, host, el) {
     this._renderer = renderer;
     this._host = host;
     this._el = el;
     this._iter = undefined;
     this._schedules = new Set();
     this._onavailable = undefined;
     this._inflightBlock = undefined;
     this._inflightValue = undefined;
     this._enqueuedBlock = undefined;
     this._enqueuedValue = undefined;
+    this._previousValue = undefined;

     // flags
     this._isUpdating = false;
     this._isIterating = false;
     this._isDone = false;
     this._isAvailable = false;
     this._isAsyncIterator = false;
   }

   refresh() {
     resumeCtx(this);
     return runCtx(this);
   }

   schedule(callback) {
     this._schedules.add(callback);
   }

   *[Symbol.iterator]() {
     while (!this._isDone) {
       if (this._isIterating) {
         throw new Error(&quot;Context iterated twice without a yield&quot;);
       }

       this._isIterating = true;
       yield this._el.props;
     }
   }

   async *[Symbol.asyncIterator]() {
     do {
       if (this._isIterating) {
         throw new Error(&quot;Context iterated twice without a yield&quot;);
       }

       this._isIterating = true;
       if (this._isAvailable) {
         this._isAvailable = false;
       } else {
         await new Promise((resolve) =&gt; (this._onavailable = resolve));
         if (this._unmounted) {
           break;
         }
       }

       yield this._el.props;
     } while (!this._isUnmounted);
   }
 }
@@ -383,47 +396,55 @@ class Context {
 function stepCtx(ctx) {
   let initial = !ctx._iter;
   if (ctx._isDone) {
     return getValue(ctx._el);
   } else if (initial) {
     const value = ctx._el.tag.call(ctx, ctx._el.props);
     if (isIteratorLike(value)) {
       ctx._iter = value;
     } else if (isPromiseLike(value)) {
       const block = Promise.resolve(value);
       return [
         block,
         block.then((value) =&gt; updateCtxChildren(ctx, value)),
       ];
     } else {
       return [undefined, updateCtxChildren(ctx, value)];
     }
   }

-  const oldValue = initial ? undefined : getValue(ctx._el);
+  let oldValue;
+  if (initial) {
+    // pass
+  } else if (ctx._isAsyncIterator &amp;&amp; ctx._previousValue) {
+    oldValue = ctx._previousValue;
+  } else {
+    oldValue = getValue(ctx._el);
+  }
+
   const iteration = ctx._iter.next(oldValue);
   if (isPromiseLike(iteration)) {
     if (initial) {
       ctx._isAsyncIterator = true;
     }

     const block = iteration;
     const value = iteration.then((iteration) =&gt; {
       ctx._isIterating = false;
       if (iteration.done) {
         ctx._done = true;
       }

       return updateCtxChildren(ctx, iteration.value);
     });

     return [block, value];
   }

   ctx._isIterating = false;
   if (iteration.done) {
     ctx._isDone = true;
   }

   const value = updateCtxChildren(ctx, iteration.value);
   return [value, value];
 }
@@ -441,29 +462,34 @@ function advanceCtx(ctx) {
 function runCtx(ctx) {
   if (!ctx._inflightBlock) {
     let [block, value] = stepCtx(ctx);
     if (isPromiseLike(block)) {
       block = block.finally(() =&gt; advanceCtx(ctx));
       ctx._inflightBlock = block;
     }

     if (isPromiseLike(value)) {
       ctx._inflightValue = value;
+      ctx._previousValue = value;
     }

     return value;
   } else if (ctx._isAsyncIterator) {
     return ctx._inflightValue;
   } else if (!ctx._enqueuedBlock) {
     let resolve;
     ctx._enqueuedBlock = ctx._inflightBlock
       .then(() =&gt; {
         const [block, value] = stepCtx(ctx);
         resolve(value);
+        if (isPromiseLike(value)) {
+          ctx._previousValue = value;
+        }
+
         return block;
       })
       .finally(() =&gt; advanceCtx(ctx));
     ctx._enqueuedValue = new Promise((resolve1) =&gt; (resolve = resolve1));
   }

   return ctx._enqueuedValue;
 }
@@ -488,21 +514,22 @@ function updateCtxChildren(ctx, children) {
 }

 function commitCtx(ctx, values) {
+  ctx._previousValue = undefined;
   if (!ctx._isUpdating) {
     ctx._renderer.arrange(
       ctx._host,
       ctx._host.tag === Portal ? ctx._host.props.root : ctx._host._node,
       getChildValues(ctx._host),
     );
   }

   const value = unwrap(values);
   const schedules = Array.from(ctx._schedules);
   ctx._schedules.clear();
   for (const schedule of schedules) {
     schedule(value);
   }

   ctx._isUpdating = false;
   return value;
 }" data-lang="diff"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token coord">--- a/crank.js</span></code><br></div><div><code><span class="token coord">+++ b/crank.js</span></code><br></div><div><code>@@ -25,14 +25,15 @@ function isPromiseLike(value) {</code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">class Element {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  constructor(tag, props) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this.tag = tag;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this.props = props;</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._node = undefined;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._children = undefined;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._ctx = undefined;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._onvalues = undefined;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    this._fallback = undefined;</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    // flags</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._isMounted = false;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code>@@ -105,11 +106,17 @@ function normalize(values) {</code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">function getValue(el) {</span></span></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  if (el.tag === Portal) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  if (el._fallback) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    if (el._fallback instanceof Element) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      return getValue(el._fallback);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    return el._fallback;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  } else if (el.tag === Portal) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    return undefined;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  } else if (typeof el.tag !== &quot;function&quot; &amp;&amp; el.tag !== Fragment) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    return el._node;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  return unwrap(getChildValues(el));</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code>@@ -197,21 +204,25 @@ export class Renderer {</code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">function diff(renderer, host, oldChild, newChild) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  if (</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    oldChild instanceof Element &amp;&amp;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    newChild instanceof Element &amp;&amp;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    oldChild.tag === newChild.tag</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  ) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    if (oldChild !== newChild) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      oldChild.props = newChild.props;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      newChild = oldChild;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  let value;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  if (newChild instanceof Element) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    const initial = !newChild._isMounted;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    value = update(renderer, host, newChild);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    if (initial &amp;&amp; isPromiseLike(value)) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      newChild._fallback = oldChild;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  } else {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    value = newChild;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  return [newChild, value];</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code>@@ -290,18 +301,19 @@ function updateChildren(renderer, host, el, newChildren) {</code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">function commit(renderer, el, values) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  el._fallback = undefined;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  if (typeof el.tag === &quot;function&quot;) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    return commitCtx(el._ctx, values);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  } else if (el.tag === Fragment) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    return unwrap(values);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  } else if (el.tag === Portal) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    renderer.arrange(el, el.props.root, values);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    return undefined;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  } else if (!el._node) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    el._node = renderer.create(el);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  renderer.patch(el, el._node);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  renderer.arrange(el, el._node, values);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  return el._node;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code>@@ -321,61 +333,62 @@ function unmount(renderer, el) {</code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">class Context {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  constructor(renderer, host, el) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._renderer = renderer;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._host = host;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._el = el;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._iter = undefined;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._schedules = new Set();</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._onavailable = undefined;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._inflightBlock = undefined;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._inflightValue = undefined;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._enqueuedBlock = undefined;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._enqueuedValue = undefined;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    this._previousValue = undefined;</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    // flags</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._isUpdating = false;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._isIterating = false;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._isDone = false;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._isAvailable = false;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._isAsyncIterator = false;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  refresh() {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    resumeCtx(this);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    return runCtx(this);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  schedule(callback) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    this._schedules.add(callback);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  *[Symbol.iterator]() {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    while (!this._isDone) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      if (this._isIterating) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        throw new Error(&quot;Context iterated twice without a yield&quot;);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      this._isIterating = true;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      yield this._el.props;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  async *[Symbol.asyncIterator]() {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    do {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      if (this._isIterating) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        throw new Error(&quot;Context iterated twice without a yield&quot;);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      this._isIterating = true;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      if (this._isAvailable) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        this._isAvailable = false;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      } else {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        await new Promise((resolve) =&gt; (this._onavailable = resolve));</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        if (this._unmounted) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">          break;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      yield this._el.props;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    } while (!this._isUnmounted);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code>@@ -383,47 +396,55 @@ class Context {</code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">function stepCtx(ctx) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  let initial = !ctx._iter;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  if (ctx._isDone) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    return getValue(ctx._el);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  } else if (initial) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    const value = ctx._el.tag.call(ctx, ctx._el.props);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    if (isIteratorLike(value)) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      ctx._iter = value;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    } else if (isPromiseLike(value)) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      const block = Promise.resolve(value);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      return [</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        block,</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        block.then((value) =&gt; updateCtxChildren(ctx, value)),</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      ];</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    } else {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      return [undefined, updateCtxChildren(ctx, value)];</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  const oldValue = initial ? undefined : getValue(ctx._el);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  let oldValue;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  if (initial) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    // pass</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  } else if (ctx._isAsyncIterator &amp;&amp; ctx._previousValue) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    oldValue = ctx._previousValue;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  } else {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    oldValue = getValue(ctx._el);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  const iteration = ctx._iter.next(oldValue);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  if (isPromiseLike(iteration)) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    if (initial) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      ctx._isAsyncIterator = true;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    const block = iteration;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    const value = iteration.then((iteration) =&gt; {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      ctx._isIterating = false;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      if (iteration.done) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        ctx._done = true;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      return updateCtxChildren(ctx, iteration.value);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    });</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    return [block, value];</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  ctx._isIterating = false;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  if (iteration.done) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    ctx._isDone = true;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  const value = updateCtxChildren(ctx, iteration.value);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  return [value, value];</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code>@@ -441,29 +462,34 @@ function advanceCtx(ctx) {</code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">function runCtx(ctx) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  if (!ctx._inflightBlock) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    let [block, value] = stepCtx(ctx);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    if (isPromiseLike(block)) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      block = block.finally(() =&gt; advanceCtx(ctx));</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      ctx._inflightBlock = block;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    if (isPromiseLike(value)) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      ctx._inflightValue = value;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      ctx._previousValue = value;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    return value;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  } else if (ctx._isAsyncIterator) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    return ctx._inflightValue;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  } else if (!ctx._enqueuedBlock) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    let resolve;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    ctx._enqueuedBlock = ctx._inflightBlock</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      .then(() =&gt; {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        const [block, value] = stepCtx(ctx);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        resolve(value);</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        if (isPromiseLike(value)) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">          ctx._previousValue = value;</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        }</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">        return block;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      })</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      .finally(() =&gt; advanceCtx(ctx));</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    ctx._enqueuedValue = new Promise((resolve1) =&gt; (resolve = resolve1));</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  return ctx._enqueuedValue;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code>@@ -488,21 +514,22 @@ function updateCtxChildren(ctx, children) {</code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">function commitCtx(ctx, values) {</span></span></code><br></div><div><code><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  ctx._previousValue = undefined;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  if (!ctx._isUpdating) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    ctx._renderer.arrange(</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      ctx._host,</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      ctx._host.tag === Portal ? ctx._host.props.root : ctx._host._node,</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">      getChildValues(ctx._host),</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    );</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  const value = unwrap(values);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  const schedules = Array.from(ctx._schedules);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  ctx._schedules.clear();</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  for (const schedule of schedules) {</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">    schedule(value);</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  }</span></span></code><br></div><div><code></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  ctx._isUpdating = false;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">  return value;</span></span></code><br></div><div><code><span class="token unchanged "><span class="token prefix unchanged"> </span><span class="token line">}</span></span></code><br></div></pre></content-area></div></div><p><a href="https://github.com/brainkim/crank-from-scratch/commit/567363adbb546d69e6726de7360595b910960ef2">Diff</a> <a href="https://github.com/brainkim/crank-from-scratch/blob/567363adbb546d69e6726de7360595b910960ef2/crank.js">File</a></p><p><strong>Notes:</strong></p><ol><li>We define the property <code class="inline">_previousValue</code> on contexts, assign it in <code class="inline">runCtx()</code> whenever async runs are detected, and unassign it in <code class="inline">commitCtx()</code>. We can’t use <code class="inline">_inflightValue</code> for this purpose because it gets assigned/unassigned at different points of the rendering process. In the actual Crank.js implementation we move this promise to elements for some advanced use-cases.</li><li>We define the property <code class="inline">_fallback</code> on elements, and assign it in the <code class="inline">diff()</code> function whenever a new element is detected as rendering asynchronously. If multiple asynchronous element trees were rendered in the same position, the elements would form a linked list via the <code class="inline">_fallback</code> property. We unset any element’s <code class="inline">_fallback</code> in the <code class="inline">commit()</code> function, breaking any fallback chains and making <code class="inline">getValue()</code> work as expected once the element has rendered.</li></ol><h2>Conclusion</h2><p>If you’ve made it this far, congratulations! You can now call yourself a framework author. You should be able to understand every line of <a href="https://github.com/brainkim/crank-from-scratch/blob/567363adbb546d69e6726de7360595b910960ef2/crank.js">the final version of the module we created</a>.</p><p>Of course, the actual Crank.js codebase implements a few more features which we haven’t had a chance to get to; for instance, the real Crank framework implements SVG elements, server-side rendering, error handling, <code class="inline">Copy</code> elements, an additional <code class="inline">EventTarget</code>-based event system, and keyed element diffing. However, we’ve still implemented and explained a lot of the hard stuff, and I think at this point you’re in a great position to read through <a href="https://github.com/bikeshaving/crank/tree/master/src">the actual Crank source code</a> to see how these features are implemented for yourself.</p><p>If you were on the fence about using Crank, I can tell you from personal experience that it is deeply satisfying to know how your web framework works, down to the level of DOM mutations. It means that your mental model for how your code executes is not just some story which you were told in some documentation or by a more experienced developer, but something which you can reason through and confirm for yourself.</p><p>The last couple of years, a common theme in web framework development has been the idea that somehow, the JavaScript runtime on its own is not enough to express a component framework. For example, both <a href="https://overreacted.io/react-as-a-ui-runtime/">React</a> and <a href="https://gist.github.com/Rich-Harris/0f910048478c2a6505d1c32185b61934">Svelte</a> maintainers have expressed some version of this idea. This idea is then used to justify the great lengths these frameworks go to add what they consider the missing parts. What I hope to have shown in this essay is that JavaScript already provides some powerful primitives, namely async and generator functions. By combining these primitives with basic virtual DOM techniques, we can create a component framework which is easy to implement on your own.</p><p>If you have any questions, feel free to reach out via GitHub or email. I will make an effort to update this essay based on feedback about what people found unclear. Thank you for reading.</p></div></main></div><script src="/static/index-FZKVRLRI.js"></script></body></html>