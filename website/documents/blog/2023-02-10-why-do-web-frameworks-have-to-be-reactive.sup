\title Why do Web Frameworks Need to be Reactive?

\begin document
When I first announced Crank at the start of the pandemic, almost three years ago now, I was surprised by its warm reception. I had assumed that the experience of being a new framework author would involve a lot more shouting into the void, standing on a street and wearing a sandwich board reading “Use My Framework” as passersby gawked, whispered “Ah, another soul lost to ‘Not Invented Here.’” Surprisingly, I found the JavaScript community and even fellow framework authors to be supportive of the effort.

Unfortunately, what happened afterwards is a great case-study in how to squander a JavaScript hype cycle. Infrequent updates caused Crank to wane into obscurity — crucially, before the sticky point where people build important things with it.

I have wonderful excuses. To my chagrin, the fantastic but unsparing \link{JS framework benchmark} revealed performance issues in early versions of Crank, and I found myself in the unfortunate position of having to solve difficult, unGoogleable problems which only I would be interested in solving. At the same time, some of the feedback that I read online, that I was being too toxic in my criticisms of React, had a chilling effect. What if I didn’t really know what I was talking about? Was I ignoring the people behind the screens?

Nevertheless, for reasons of pride, or perhaps insanity, I persisted, refactoring the codebase numerous times, and refining its API. Today, I’m happy to say that, according to the same benchmark, Crank is comparable in performance to popular production-ready frameworks like Svelte and Vue, though some of the improvements just seem to be Chrome getting faster.

Moreover, many of the opinions I had originally expressed in the introductory essay have been vindicated. For instance, React is now considering allowing the usage of async functions for components (though only on the server for some reason), a feature that has been a part of Crank since day one. \comment{if you want to make a claim about React’s declining popularity, then fucking cite it}

With this in mind, as I try to write about Crank again, I find myself again faced with a problem which I have caused and perhaps only I am motivated to solve. I have to convince web developers to use Crank, despite the fact that it is a “non-reactive” web framework, perhaps the only one out there.

Reactivity has many definitions. In the context of JavaScript and user interfaces (UIs), it refers to the ability of a framework to automatically update the UI in response to changes to the underlying data. As demonstration of how Crank is “non-reactive,” here’s what a simple counter component is defined:

\code|||
function *Counter() {
  let count = 0;
  const onclick = () => {
    count++;
    this.refresh();
  };

  for ({} of this) {
    yield (
      <button onclick={onclick}>
        Clicked {count} {count === 1 ? "time" : "times"}
      </button>
    );
  }
}
|||

Unlike other frameworks, Crank has no knowledge of what constitutes a component’s local state, or when it might change. For instance, in the preceding example, you have to both increment the \${count} variable and call \${this.refresh()}; updating the count variable on its own will not cause the DOM to update.

Many developers saw examples like this and balked. “Isn’t the need for an explicit \${refresh()} here a ‘pitfall’ or a ‘footgun,’ in the sense that you could theoretically increment the count variable without refreshing the component?” I found in multiple places people describing this aspect of Crank’s design as “a disappointment” or “a step backward.”

To be honest, this was not a difficult design decision for me. I had had enough of the pains of “reactivity” in the past, and I was delighted to discover that I could represent state as merely local variables thanks to generator functions. It felt like an obvious win.

Nevertheless, I should have anticipated that this decision would be a cause for controversy, if only because by not providing any sort of “reactive” solution, I was going against the grain. Why did I feel okay shirking the responsibilities of reactivity by making rerendering explicit, when almost all other framework authors seem to find it necessary to automate this task on behalf of their users?

My goal for the rest of this essay is to convince you that Crank being non-reactive is actually a strength in its design, and not some oversight on the part of an inexperienced framework author.

\section Under-rendering is better than over-rendering

Here’s one way to think about it. As I mentioned earlier, one of the main objections to explicit refreshes is that it’s a potential “footgun,” a design flaw which results in bugs, because having to explicitly rerender components with a \${refresh()} call means it is possible to forget to update the view.

I have definitely caused this, just forgetting to call \${this.refresh()}. Especially when coming from working on reactive frameworks to Crank, and muscle memory doesn’t kick in.

It may seem odd that to you that I don’t find this a damning indictment of Crank. To understand why I don’t mind “shooting” myself in the foot like this every so often, we need to do an analysis of this kind of bug in terms of its actual cost: its effects on software quality and developer productivity.

Two questions we can ask when evaluating the severity of potential bugs are 1. “Is the bug easy to spot?” and 2. “Is the bug easy to fix?” My answers to both these question is “yes.” When you forget to call ${this.refresh()} after updating the local state, the result is almost always immediately noticed by the developer in the course of development. You add a click handler to a button, click it, and see that the UI hasn’t changed. So the bug is easy to stop. Is the bug easy to fix? Yes, because rerendering in Crank is explicit, the way to fix this bug is usually equally obvious, a single line change.

So this type of bug is both easy to spot and fix, but your next question is probably, why we should tolerate this type of bug at all, if we can use reactive solutions to prevent them? To understand, we need to analyze what happens when frameworks attempt to prevent this kind of bug by going the other way, by rerendering for you when they detect changes to “state.”

We can broadly describe bugs where the view does not update to match state as cases of “under-rendering,” in the sense that less code is executed than expected. Logically then, if there is such a thing as “under-rendering,” then there must also be a thing called “over-rendering,” where the view executes and renders more code than is necessary. While not exactly a bug in the sense that users wouldn’t describe over-rendered applications as being obviously incorrect, over-rendering can still manifest as a problem in the sense that it can lead to performance issues.

If you have ever investigated the performance of large JavaScript applications, you’ll probably agree with the following statement: most frameworks, and especially React, are pathologically over-rendered. We know this is true because there are popular developer tool extensions which are dedicated to identifying instances of over-rendering like \link{#TK}{why-did-you-render}. And the worst part is, unlike under-rendering, over-rendering is both difficult to detect and difficult to fix.

\image{#TODO}{Under- and over-rendering as a number line}

To visualize, you can imagine all possible situations of under-rendering and over-rendering as existing on a line, with under-rendering on the left and over-rendering on the right. Ideally, your framework should place developers at the imaginary point of “exactly rendered,” where just enough code executes that the UI reflects your data, with maximum efficiency.

Crank differs from its contemporaries in that it aims to undershoot, rather than overshoot by default. By contrast, most frameworks imagine the “pit of success” to lie somewhere a little past the point of exactly rendered. The trick is to then argue with each other over how little they overshot the mark, how efficient their reactive solutions are.

Crank aims to undershoot because that’s where I think the “pit of success” actually is, because to over-render by default betrays a misunderstanding of the lay of the land. As illustration, we can imagine the points on the preceding line as having an elevation, in the sense that it takes energy to go from one point on the line to another. Like I described earlier, it’s easy to go from under-rendered to exactly rendered, at least in Crank, insofar as it really is just adding a call to \${this.refresh()} here and there. This is just the process of normal development. On the other hand, it gets increasingly difficult to go from over-rendered to exactly rendered.

\image{#TODO}{The cost of moving along the rendering line}

The reason for this difficulty is that over-execution is due to the framework, and not necessarily anything with your own code. In other words, over-rendering does not exist as a single bottleneck which you can discover and optimize, but applies to all your code. Compounding this problem is the fact that you don’t over-rendered until it’s already too late, because on a superficial level, every point on the line from exactly rendered to infinitely over-rendered looks exactly the same to the end user, just progressively degraded.

React is the worst offender in terms of over-execution. Most React developers are aware of the problem of over-rendering at least implicitly, but the psychology of the React developer is to believe that they will be saved by some technique or optimization. I regret to inform you that none of caching, memoization, \${shouldComponentUpdate()} or immutable data structures will save you. On the contrary, each of these techniques are \link{hotly debated}{https://kentcdodds.com/blog/usememo-and-usecallback} and must be \link{https://news.ycombinator.com/item?id=14418054}{selectively applied}.

The reasons these optimizations are many, but specifically, they don’t do much most of the time because many make the poor trade in JavaScript of CPU time for memory, where what you gain in reduced execution time is lost to additional garbage collection pauses, and because fundamentally, they don’t solve the root cause of the problem of over-execution; you’re in essence trying to execute less code by executing some other code instead.

The root cause isn’t that you’re not using one of these techniques, it’s that React is rendering too much, and there is no lever you can pull to get it to stop. This is a consequence of years of de-emphasizing the idea that execution matters. It started with the idea that creating and rendering virtual DOM nodes was cheaper than rendering actual DOM nodes, and for the most part this is true. If you have the functions which read props and state and return virtual DOM elements, the actual execution of these functions is typically negligible compared to actual DOM mutations. At some point however, this was corrupted by overzealous functional programmers who said the cost of execution of these virtual DOM returning functions was negligible or even “free.”

This is, of course, obviously false, no execution is ever really free insofar as it consumes CPU and memory, but this idea gripped the React team, such that successive features only make sense when they are considered in the context that executing these “render” functions is somehow negligible or free. Rerender to align a \${useEffect()} callback in a hook with its closure, rerender when a context is updated, rerender both to throw a promise for suspense and once again when that promise resolves. Each time, the virtual DOM producing functions are imagined to execute for free but the resulting effect when you scale an application is that those little bits of execution add up.

The most perplexing aspect is that advancements in web frameworks in recent years have made it much simpler to render applications in a declarative manner. Most contemporary frameworks these days have some form of “immediate mode” rendering, where you simply declare what the DOM will look like via JSX or templates, and the framework uses techniques like virtual DOM diffing or compilation to make the actual DOM look like what you declared, regardless of what it looked like before. Essentially, we can make changes to the DOM with a snap of the fingers, so why is it that we still insist that this finger snapping be automated.

\section Two different transparencies

Here’s a slightly more theoretical way to look at it. Let’s say you aren’t convinced by appeals to performance and that you haven’t really noticed over-rendering in your applications. The thing is, over-execution of code isn’t just a performance problem: it impacts your ability to understand your code. While discussions of code complexity are often reduced to subjective measures, like “familiarity” or “experience,” there are several objective measures as well.

For instance, there’s the cyclomatic complexity of a program: this is measured by the number of independent paths which can be taken through a program’s source code. The more control-flow branches there are in a specific function (if, else, for, while, etc. statements), the more difficult it will be to understand what the code is meant to do, or if it is correct. Similarly, we can indirectly measure the complexity of code by checking if a function or program exhibits certain properties, like \i{referential transparency}. A function or program is referentially transparent if it returns the same output given the same input, and does not produce side-effects.

I bring up referential transparency because this is brought up as a way to mitigate overe-execution. Insofar as, for instance, React components allow you take inputs and return declarative templates, you should not care about how many times said component runs. In other words, 

By contrast, executional transparency is the measure of 

The fallacy behind this line of reasoning is that 

Because reactive systems re-execute code when things change, however that’s defined, they by necessity reduce the executional tranparency of the resulting code.

\section Consent-driven development

Here’s another way to look at it.

\section The frontier of web development


And the code has gotten monstrously complex to support features like hydration and async generator lifecycles. Maybe someday I will come back and refactor it to be nice and pretty, or maybe someone else could do it for me? Pretty please? Isn’t that open source or whatever.
