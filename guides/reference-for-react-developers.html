<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><title>Crank.js | Reference for React Developers</title><link href="/static/index-UEEVTAOK.css" rel="stylesheet" type="text/css"><link rel="shortcut icon" href="/static/favicon.ico"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-20910936-4"></script><script>
								window.dataLayer = window.dataLayer || [];
								function gtag(){dataLayer.push(arguments);}
								gtag('js', new Date());

								gtag('config', 'UA-20910936-4');
							</script></head><body><nav id="navbar" class="navbar"><div class="navbar-group"><div class="navbar-item"><a class="navbar-title-link false" href="/"><img class="navbar-logo" src="/static/logo.svg" alt=""><span>Crank.js</span></a></div><div class="navbar-item"><a class="current" href="/guides/getting-started">Docs</a></div><div class="navbar-item"><a href="/blog/">Blog</a></div></div><div class="navbar-group"><div class="navbar-item"><a href="https://github.com/bikeshaving/crank">GitHub</a></div><div class="navbar-item"><a href="http://npm.im/@bikeshaving/crank">NPM</a></div></div></nav><div class="non-footer"><div id="sidebar" class="sidebar"><h3>Guides</h3><div class="sidebar-item"><a href="/guides/getting-started" class="">Getting Started</a></div><div class="sidebar-item"><a href="/guides/elements" class="">JSX, Elements and Renderers</a></div><div class="sidebar-item"><a href="/guides/components" class="">Components</a></div><div class="sidebar-item"><a href="/guides/handling-events" class="">Handling Events</a></div><div class="sidebar-item"><a href="/guides/async-components" class="">Async Components</a></div><div class="sidebar-item"><a href="/guides/special-props-and-tags" class="">Special Props and Tags</a></div><div class="sidebar-item"><a href="/guides/lifecycles" class="">Lifecycles</a></div><div class="sidebar-item"><a href="/guides/reusable-logic" class="">Reusable Logic</a></div><div class="sidebar-item"><a href="/guides/working-with-typescript" class="">Working with TypeScript</a></div><div class="sidebar-item"><a href="/guides/reference-for-react-developers" class="current">Reference for React Developers</a></div><div class="sidebar-item"><a href="/guides/api-reference" class="">API Reference</a></div></div><main class="main"><div class="content"><h1>Reference for React Developers</h1><p>Though Crank is inspired by React, compatibility is a non-goal, and certain concepts may be implemented using different, non-compatible APIs. The following is a reference for React developers to help them map React concepts and APIs to their equivalents in Crank.</p><h2>Class-based Components</h2><p>Crank uses functions exclusively for components; it does not provide a class-based component API. You can emulate most of React’s class API with the natural lifecycle of generator functions.</p><div class="codeblock" data-code="async function *ReactComponent(props) {
  let state = componentWillMount(props);
  let ref = yield render(props, state);
  state = componentDidMount(props, state, ref);
  try {
    for await (const newProps of this) {
      if (shouldComponentUpdate(props, newProps, state, ref)) {
        state = componentWillUpdate(props, newProps, state, ref);
        ref = yield render(props, state);
        state = componentDidUpdate(props, newProps, state, ref);
        props = newProps;
      } else {
        yield &lt;Copy /&gt;;
      }
    }
  } catch (err) {
    componentDidCatch(err);
  } finally {
    componentWillUnmount(ref);
  }
}" data-lang="jsx"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token operator">*</span><span class="token function">ReactComponent</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>  <span class="token keyword">let</span> state <span class="token operator">=</span> <span class="token function">componentWillMount</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>  <span class="token keyword">let</span> ref <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">render</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>  state <span class="token operator">=</span> <span class="token function">componentDidMount</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> state<span class="token punctuation">,</span> ref<span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>  <span class="token keyword">try</span> <span class="token punctuation">{</span></code><br></div><div><code>    <span class="token keyword">for</span> <span class="token keyword">await</span> <span class="token punctuation">(</span><span class="token keyword">const</span> newProps <span class="token keyword">of</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> newProps<span class="token punctuation">,</span> state<span class="token punctuation">,</span> ref<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>        state <span class="token operator">=</span> <span class="token function">componentWillUpdate</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> newProps<span class="token punctuation">,</span> state<span class="token punctuation">,</span> ref<span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>        ref <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">render</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>        state <span class="token operator">=</span> <span class="token function">componentDidUpdate</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> newProps<span class="token punctuation">,</span> state<span class="token punctuation">,</span> ref<span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>        props <span class="token operator">=</span> newProps<span class="token punctuation">;</span></code><br></div><div><code>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></code><br></div><div><code>        <span class="token keyword">yield</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Copy</span></span> <span class="token punctuation">/&gt;</span></span><span class="token punctuation">;</span></code><br></div><div><code>      <span class="token punctuation">}</span></code><br></div><div><code>    <span class="token punctuation">}</span></code><br></div><div><code>  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span></code><br></div><div><code>    <span class="token function">componentDidCatch</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>  <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span></code><br></div><div><code>    <span class="token function">componentWillUnmount</span><span class="token punctuation">(</span>ref<span class="token punctuation">)</span><span class="token punctuation">;</span></code><br></div><div><code>  <span class="token punctuation">}</span></code><br></div><div><code><span class="token punctuation">}</span></code><br></div></pre></content-area></div></div><p>This example is pseudocode which demonstrates where React’s class methods would be called relative to an async generator component. Refer to the <a href="./lifecycles">guide on lifecycles</a> for more information on using generator functions.</p><p>The following are specific equivalents for React methods.</p><h3>setState and forceUpdate</h3><p>Crank uses generator functions and local variables for local state. Refer to <a href="./guides/components#stateful-components">the section on stateful components</a>.</p><p>Crank is not “reactive” in the same sense as React, in that it does not track your component’s local state and rerender when it detects a change. You can either use the context’s <code class="inline">refresh</code> to manually refresh the component, similar to React’s <code class="inline">forceUpdate</code> method, or you can use async generator components, which refresh automatically whenever the returned async generator yields.</p><h3>defaultProps</h3><p>Crank doesn’t have a <code class="inline">defaultProps</code> implementation. Instead, you can provide default values when destructuring props. <a href="./components#default-props">See the guide on default props</a>.</p><h3>componentWillMount and componentDidMount</h3><p>Setup code for components can be written at the top of generator components. It will not execute until the component is mounted in the tree.</p><h3>shouldComponentUpdate</h3><p>As an alternative to React’s <code class="inline">shouldComponentUpdate</code> method, you can use <code class="inline">Copy</code> elements to prevent the rerendering of a specific subtree. Refer to <a href="./special-props-and-tags#copy">the description of <code class="inline">Copy</code> elements</a> for more information.</p><h3>getDerivedStateFromProps, componentWillUpdate and getSnapshotBeforeUpdate</h3><p>Code which compares old and new props or state can be written directly in your components. See the section on <a href="./components#comparing-old-and-new-props">prop updates</a> for an example of a component which compares old and new props.</p><h3>componentDidUpdate</h3><p>To execute code after rendering, you can use async generator components or <a href="./api-reference#schedule">the <code class="inline">schedule</code> method</a>. See <a href="./lifecycles#accessing-rendered-values">the guide on accessing rendered values</a> for more information.</p><h3>componentWillUnmount</h3><p>You can use a <code class="inline">try</code>/<code class="inline">finally</code> block to run code when a component is unmounted. You can also use <a href="./api-reference#cleanup">the <code class="inline">cleanup</code> method</a> if you’re writing extensions which don’t run in the main execution of the component.</p><h3>componentDidCatch</h3><p>To catch errors which occur in child components, you can use generator components and wrap <code class="inline">yield</code> operations in a <code class="inline">try</code>/<code class="inline">catch</code> block. Refer to <a href="./lifecycles#catching-errors">the relevant guide on catching errors</a>.</p><h2>Hooks</h2><p>Crank does not implement any APIs similar to React Hooks. The main appeal of hooks for library authors is that you can encapsulate entire APIs in one or two hooks. Refer to <a href="./reusable-logic#strategies-for-reusing-logic">the guide on reusable logic</a> for a description of strategies you can use to reuse logic and write library wrappers in Crank.</p><p>The following are alternatives to specific hooks.</p><h3>useState and useReducer</h3><p>Crank uses generator functions and local variables for local state. Refer to <a href="./components#stateful-components">the section on stateful components</a>.</p><h3>useEffect and useLayoutEffect</h3><p>Crank does not have any requirements that rendering should be “pure.” In other words, you can trigger side-effects directly while rendering because Crank does not execute components more times than you might expect. Refer to <a href="./lifecycles#accessing-rendered-values">the guide on accessing rendered values</a> for more information on code which executes after rendering.</p><h3>useMemo and useCallback</h3><p>Because the execution of generator components is preserved, there is no need to “memoize” or “cache” callbacks or other values. You can simply assign them to a constant variable.</p><h3>useImperativeHandle</h3><p>Crank does not have a way to access component instances, and parent components should not access child components directly. A web component wrapper for defining custom elements with imperative APIs is planned.</p><h2>Suspense and Concurrent Mode</h2><p>Crank uses async functions and promises for scheduling and coordinating async processes. See the <a href="./async-components">guide on async components</a> for an introduction to async components, as well as a demonstration of how you can implement the <code class="inline">Suspense</code> component directly in user space.</p><h2>PropTypes</h2><p>Crank is written in TypeScript, and you can add type checking to components by typing the props parameter of the component function. See <a href="./working-with-typescript">the guide on TypeScript</a> for detailed instructions on how to type components.</p><h2>Array Children</h2><p>Crank does not restrict children in JSX elements to just arrays. You can interpolate ES6 maps, sets or any other iterable into your Crank elements. Additionally, Crank does not warn you if elements in the iterable are unkeyed.</p><h2>Fragments</h2><p>The <a href="./special-props-and-tags#fragment"><code class="inline">Fragment</code> element</a> works almost exactly as it does in React, except that in Crank you can also use a callback ref to access its contents.</p><h2>React.cloneElement</h2><p>You can clone elements using <a href="./api-reference#cloneelement">the <code class="inline">cloneElement</code> function</a>.</p><h2>ReactDOM.createPortal</h2><p>The <code class="inline">createPortal</code> function is replaced by the special <code class="inline">Portal</code> element, whose behavior and expected props varies according to the target rendering environment. Refer to <a href="./special-props-and-tags#portal">the guide on the <code class="inline">Portal</code> element</a> for more information.</p><h2>React.memo</h2><p>See <a href="./special-props-and-tags#copy">the guide on <code class="inline">Copy</code> tags</a> for a demonstration of how you can use <code class="inline">Copy</code> elements to implement <code class="inline">React.memo</code> in user space.</p><h2>DOM element props</h2><p>The following are a list of the differences in props APIs for DOM elements.</p><h3>className and htmlFor</h3><p>Crank prefers attribute names rather than the JS property DOM equivalents when these names are mismatched.</p><div class="codeblock" data-code="&lt;label class=&quot;my-label&quot; for=&quot;my-id&quot;&gt;Label&lt;/label&gt;" data-lang="jsx"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>my-label<span class="token punctuation">&quot;</span></span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>my-id<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>Label<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">&gt;</span></span></code><br></div></pre></content-area></div></div><p>In short, Crank is optimized for easy copy-pasting, which using props like <code class="inline">className</code> and <code class="inline">htmlFor</code> does not encourage. See <a href="./special-props-and-tags#prop-naming-conventions">the section on prop naming conventions</a> for more information.</p><h3>style</h3><p>The <code class="inline">style</code> prop can be an object of CSS declarations. However, unlike React, CSS property names match the case of their CSS equivalents, and we do not add units to numbers. Additionally, Crank allows the style prop to be a CSS string as well.</p><div class="codeblock" data-code="  &lt;div style=&quot;color: red&quot;&gt;&lt;span style={{&quot;font-size&quot;: &quot;16px&quot;}}&gt;Hello&lt;/span&gt;&lt;/div&gt;" data-lang="jsx"><div class="playground"><content-area><pre class="editable" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"><div><code>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token value css language-css"><span class="token property">color</span><span class="token punctuation">:</span> red</span><span class="token punctuation">&quot;</span></span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">style</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">&quot;font-size&quot;</span><span class="token operator">:</span> <span class="token string">&quot;16px&quot;</span><span class="token punctuation">}</span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span>Hello<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span></code><br></div></pre></content-area></div></div><p>Refer to the guide on <a href="./special-props-and-tags#style">the style prop</a> for more information.</p><h3>Event props</h3><p>Host elements can be listened to using <code class="inline">onevent</code> props, but the prop name will be all lowercase. Crank also provides an <code class="inline">EventTarget</code> API for components to add and remove event listeners from the top-level node or nodes of each component. In both cases, Crank does not use a synthetic event system or polyfill events in any way. Refer to <a href="./handling-events">the guide on event handling</a> for a longer explanation of event handling in Crank.</p><h3>Controlled and Uncontrolled Props</h3><p>Crank does not have a concept of controlled or uncontrolled props, and does not provide <code class="inline">defaultValue</code>-style props for DOM elements. See <a href="./handling-events#form-elements">the section on form elements</a> for a detailed description of how Crank handles stateful form elements.</p><h3>dangerouslySetInnerHTML</h3><p>Host DOM elements accept an <code class="inline">innerHTML</code> prop; Crank does not provide the <code class="inline">dangerouslySetInnerHTML={{__html}}</code> API like React. Alternatively, you can use the special <code class="inline">Raw</code> tag to insert HTML strings or even DOM nodes directly into an element tree without a parent. Refer to the sections <a href="./special-props-and-tags#innerhtml">on the <code class="inline">innerHTML</code> prop</a> and <a href="./special-props-and-tags#raw">on the <code class="inline">Raw</code> tag</a> for more information.</p><h2>Keys</h2><p>Crank provides keyed rendering via the special <code class="inline">crank-key</code> prop. The prop was renamed because “key” is a common word and because the prop is not erased from the props object passed into components.</p><p>Keys work similarly to the way they do in React. The main difference is that Crank does not warn about unkeyed elements which appear in arrays or iterables.</p><h2>Refs</h2><p>Crank provides the callback-style ref API from React via the <code class="inline">crank-ref</code> prop. Unlike React, all elements can be read using the <code class="inline">crank-ref</code> prop, including Fragment elements. See the <a href="./special-props-and-tags#crank-ref">guide on the <code class="inline">crank-ref</code> prop</a>.</p><p>You can also access rendered values in many other ways. Refer to <a href="./lifecycles#accessing-rendered-values">this section</a> for more information.</p><h2>React Contexts</h2><p>Because we refer to the <code class="inline">this</code> keyword of components as “the component’s context” (“controller” would have been three more characters), we refer to the equivalent concept of <a href="https://reactjs.org/docs/context.html">React’s Context API</a> as “provisions” instead. We use the context methods <code class="inline">provide</code> and <code class="inline">consume</code> to define provisions between ancestor and descendant components. See <a href="./reusable-logic#provisions">the guide on provisions</a> for more information.</p></div></main></div><script src="/static/index-FZKVRLRI.js"></script></body></html>