{
  "version": 3,
  "sources": ["../node_modules/@esbuild-plugins/node-globals-polyfill/process.js", "../node_modules/@esbuild-plugins/node-globals-polyfill/Buffer.js", "../node_modules/@b9g/src/event-target.ts", "../node_modules/@b9g/crank/_utils.js", "../node_modules/@b9g/src/crank.ts"],
  "sourcesContent": ["// shim for using process in browser\n// based off https://github.com/defunctzombie/node-process/blob/master/browser.js\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined')\n}\nfunction defaultClearTimeout() {\n    throw new Error('clearTimeout has not been defined')\n}\nvar cachedSetTimeout = defaultSetTimout\nvar cachedClearTimeout = defaultClearTimeout\nif (typeof global.setTimeout === 'function') {\n    cachedSetTimeout = setTimeout\n}\nif (typeof global.clearTimeout === 'function') {\n    cachedClearTimeout = clearTimeout\n}\n\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0)\n    }\n    // if setTimeout wasn't available but was latter defined\n    if (\n        (cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) &&\n        setTimeout\n    ) {\n        cachedSetTimeout = setTimeout\n        return setTimeout(fun, 0)\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0)\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0)\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0)\n        }\n    }\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker)\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if (\n        (cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) &&\n        clearTimeout\n    ) {\n        cachedClearTimeout = clearTimeout\n        return clearTimeout(marker)\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker)\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker)\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker)\n        }\n    }\n}\nvar queue = []\nvar draining = false\nvar currentQueue\nvar queueIndex = -1\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return\n    }\n    draining = false\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue)\n    } else {\n        queueIndex = -1\n    }\n    if (queue.length) {\n        drainQueue()\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return\n    }\n    var timeout = runTimeout(cleanUpNextTick)\n    draining = true\n\n    var len = queue.length\n    while (len) {\n        currentQueue = queue\n        queue = []\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run()\n            }\n        }\n        queueIndex = -1\n        len = queue.length\n    }\n    currentQueue = null\n    draining = false\n    runClearTimeout(timeout)\n}\nfunction nextTick(fun) {\n    var args = new Array(arguments.length - 1)\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i]\n        }\n    }\n    queue.push(new Item(fun, args))\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue)\n    }\n}\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun\n    this.array = array\n}\nItem.prototype.run = function() {\n    this.fun.apply(null, this.array)\n}\nvar title = 'browser'\nvar platform = 'browser'\nvar browser = true\nvar env = {}\nvar argv = []\nvar version = '' // empty string to avoid regexp issues\nvar versions = {}\nvar release = {}\nvar config = {}\n\nfunction noop() {}\n\nvar on = noop\nvar addListener = noop\nvar once = noop\nvar off = noop\nvar removeListener = noop\nvar removeAllListeners = noop\nvar emit = noop\n\nfunction binding(name) {\n    throw new Error('process.binding is not supported')\n}\n\nfunction cwd() {\n    return '/'\n}\nfunction chdir(dir) {\n    throw new Error('process.chdir is not supported')\n}\nfunction umask() {\n    return 0\n}\n\n// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js\nvar performance = global.performance || {}\nvar performanceNow =\n    performance.now ||\n    performance.mozNow ||\n    performance.msNow ||\n    performance.oNow ||\n    performance.webkitNow ||\n    function() {\n        return new Date().getTime()\n    }\n\n// generate timestamp or delta\n// see http://nodejs.org/api/process.html#process_process_hrtime\nfunction hrtime(previousTimestamp) {\n    var clocktime = performanceNow.call(performance) * 1e-3\n    var seconds = Math.floor(clocktime)\n    var nanoseconds = Math.floor((clocktime % 1) * 1e9)\n    if (previousTimestamp) {\n        seconds = seconds - previousTimestamp[0]\n        nanoseconds = nanoseconds - previousTimestamp[1]\n        if (nanoseconds < 0) {\n            seconds--\n            nanoseconds += 1e9\n        }\n    }\n    return [seconds, nanoseconds]\n}\n\nvar startTime = new Date()\nfunction uptime() {\n    var currentTime = new Date()\n    var dif = currentTime - startTime\n    return dif / 1000\n}\n\nexport var process = {\n    nextTick: nextTick,\n    title: title,\n    browser: browser,\n    env: env,\n    argv: argv,\n    version: version,\n    versions: versions,\n    on: on,\n    addListener: addListener,\n    once: once,\n    off: off,\n    removeListener: removeListener,\n    removeAllListeners: removeAllListeners,\n    emit: emit,\n    binding: binding,\n    cwd: cwd,\n    chdir: chdir,\n    umask: umask,\n    hrtime: hrtime,\n    platform: platform,\n    release: release,\n    config: config,\n    uptime: uptime,\n}\n\n// replace process.env.VAR with define\n\nconst defines = {}\nObject.keys(defines).forEach((key) => {\n    const segs = key.split('.')\n    let target = process\n    for (let i = 0; i < segs.length; i++) {\n        const seg = segs[i]\n        if (i === segs.length - 1) {\n            target[seg] = defines[key]\n        } else {\n            target = target[seg] || (target[seg] = {})\n        }\n    }\n})\n", "// taken from https://github.com/calvinmetcalf/buffer-es6\n\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\nvar inited = false\nfunction init() {\n    inited = true\n    var code =\n        'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n    for (var i = 0, len = code.length; i < len; ++i) {\n        lookup[i] = code[i]\n        revLookup[code.charCodeAt(i)] = i\n    }\n\n    revLookup['-'.charCodeAt(0)] = 62\n    revLookup['_'.charCodeAt(0)] = 63\n}\n\nfunction base64toByteArray(b64) {\n    if (!inited) {\n        init()\n    }\n    var i, j, l, tmp, placeHolders, arr\n    var len = b64.length\n\n    if (len % 4 > 0) {\n        throw new Error('Invalid string. Length must be a multiple of 4')\n    }\n\n    // the number of equal signs (place holders)\n    // if there are two placeholders, than the two characters before it\n    // represent one byte\n    // if there is only one, then the three characters before it represent 2 bytes\n    // this is just a cheap hack to not do indexOf twice\n    placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n\n    // base64 is 4/3 + up to two characters of the original data\n    arr = new Arr((len * 3) / 4 - placeHolders)\n\n    // if there are placeholders, only get up to the last complete 4 chars\n    l = placeHolders > 0 ? len - 4 : len\n\n    var L = 0\n\n    for (i = 0, j = 0; i < l; i += 4, j += 3) {\n        tmp =\n            (revLookup[b64.charCodeAt(i)] << 18) |\n            (revLookup[b64.charCodeAt(i + 1)] << 12) |\n            (revLookup[b64.charCodeAt(i + 2)] << 6) |\n            revLookup[b64.charCodeAt(i + 3)]\n        arr[L++] = (tmp >> 16) & 0xff\n        arr[L++] = (tmp >> 8) & 0xff\n        arr[L++] = tmp & 0xff\n    }\n\n    if (placeHolders === 2) {\n        tmp =\n            (revLookup[b64.charCodeAt(i)] << 2) |\n            (revLookup[b64.charCodeAt(i + 1)] >> 4)\n        arr[L++] = tmp & 0xff\n    } else if (placeHolders === 1) {\n        tmp =\n            (revLookup[b64.charCodeAt(i)] << 10) |\n            (revLookup[b64.charCodeAt(i + 1)] << 4) |\n            (revLookup[b64.charCodeAt(i + 2)] >> 2)\n        arr[L++] = (tmp >> 8) & 0xff\n        arr[L++] = tmp & 0xff\n    }\n\n    return arr\n}\n\nfunction tripletToBase64(num) {\n    return (\n        lookup[(num >> 18) & 0x3f] +\n        lookup[(num >> 12) & 0x3f] +\n        lookup[(num >> 6) & 0x3f] +\n        lookup[num & 0x3f]\n    )\n}\n\nfunction encodeChunk(uint8, start, end) {\n    var tmp\n    var output = []\n    for (var i = start; i < end; i += 3) {\n        tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2]\n        output.push(tripletToBase64(tmp))\n    }\n    return output.join('')\n}\n\nfunction base64fromByteArray(uint8) {\n    if (!inited) {\n        init()\n    }\n    var tmp\n    var len = uint8.length\n    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n    var output = ''\n    var parts = []\n    var maxChunkLength = 16383 // must be multiple of 3\n\n    // go through the array every three bytes, we'll deal with trailing stuff later\n    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n        parts.push(\n            encodeChunk(\n                uint8,\n                i,\n                i + maxChunkLength > len2 ? len2 : i + maxChunkLength,\n            ),\n        )\n    }\n\n    // pad the end with zeros, but make sure to not forget the extra bytes\n    if (extraBytes === 1) {\n        tmp = uint8[len - 1]\n        output += lookup[tmp >> 2]\n        output += lookup[(tmp << 4) & 0x3f]\n        output += '=='\n    } else if (extraBytes === 2) {\n        tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n        output += lookup[tmp >> 10]\n        output += lookup[(tmp >> 4) & 0x3f]\n        output += lookup[(tmp << 2) & 0x3f]\n        output += '='\n    }\n\n    parts.push(output)\n\n    return parts.join('')\n}\n\nvar INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT =\n    global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : true\n\nfunction kMaxLength() {\n    return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff\n}\n\nfunction createBuffer(that, length) {\n    if (kMaxLength() < length) {\n        throw new RangeError('Invalid typed array length')\n    }\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        // Return an augmented `Uint8Array` instance, for best performance\n        that = new Uint8Array(length)\n        that.__proto__ = Buffer.prototype\n    } else {\n        // Fallback: Return an object instance of the Buffer class\n        if (that === null) {\n            that = new Buffer(length)\n        }\n        that.length = length\n    }\n\n    return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nexport function Buffer(arg, encodingOrOffset, length) {\n    if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n        return new Buffer(arg, encodingOrOffset, length)\n    }\n\n    // Common case.\n    if (typeof arg === 'number') {\n        if (typeof encodingOrOffset === 'string') {\n            throw new Error(\n                'If encoding is specified then the first argument must be a string',\n            )\n        }\n        return allocUnsafe(this, arg)\n    }\n    return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function(arr) {\n    arr.__proto__ = Buffer.prototype\n    return arr\n}\n\nfunction from(that, value, encodingOrOffset, length) {\n    if (typeof value === 'number') {\n        throw new TypeError('\"value\" argument must not be a number')\n    }\n\n    if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n        return fromArrayBuffer(that, value, encodingOrOffset, length)\n    }\n\n    if (typeof value === 'string') {\n        return fromString(that, value, encodingOrOffset)\n    }\n\n    return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function(value, encodingOrOffset, length) {\n    return from(null, value, encodingOrOffset, length)\n}\n\nBuffer.kMaxLength = kMaxLength()\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n    Buffer.prototype.__proto__ = Uint8Array.prototype\n    Buffer.__proto__ = Uint8Array\n    if (\n        typeof Symbol !== 'undefined' &&\n        Symbol.species &&\n        Buffer[Symbol.species] === Buffer\n    ) {\n        // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n        // Object.defineProperty(Buffer, Symbol.species, {\n        //   value: null,\n        //   configurable: true\n        // })\n    }\n}\n\nfunction assertSize(size) {\n    if (typeof size !== 'number') {\n        throw new TypeError('\"size\" argument must be a number')\n    } else if (size < 0) {\n        throw new RangeError('\"size\" argument must not be negative')\n    }\n}\n\nfunction alloc(that, size, fill, encoding) {\n    assertSize(size)\n    if (size <= 0) {\n        return createBuffer(that, size)\n    }\n    if (fill !== undefined) {\n        // Only pay attention to encoding if it's a string. This\n        // prevents accidentally sending in a number that would\n        // be interpretted as a start offset.\n        return typeof encoding === 'string'\n            ? createBuffer(that, size).fill(fill, encoding)\n            : createBuffer(that, size).fill(fill)\n    }\n    return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function(size, fill, encoding) {\n    return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe(that, size) {\n    assertSize(size)\n    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n    if (!Buffer.TYPED_ARRAY_SUPPORT) {\n        for (var i = 0; i < size; ++i) {\n            that[i] = 0\n        }\n    }\n    return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function(size) {\n    return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function(size) {\n    return allocUnsafe(null, size)\n}\n\nfunction fromString(that, string, encoding) {\n    if (typeof encoding !== 'string' || encoding === '') {\n        encoding = 'utf8'\n    }\n\n    if (!Buffer.isEncoding(encoding)) {\n        throw new TypeError('\"encoding\" must be a valid string encoding')\n    }\n\n    var length = byteLength(string, encoding) | 0\n    that = createBuffer(that, length)\n\n    var actual = that.write(string, encoding)\n\n    if (actual !== length) {\n        // Writing a hex string, for example, that contains invalid characters will\n        // cause everything after the first invalid character to be ignored. (e.g.\n        // 'abxxcd' will be treated as 'ab')\n        that = that.slice(0, actual)\n    }\n\n    return that\n}\n\nfunction fromArrayLike(that, array) {\n    var length = array.length < 0 ? 0 : checked(array.length) | 0\n    that = createBuffer(that, length)\n    for (var i = 0; i < length; i += 1) {\n        that[i] = array[i] & 255\n    }\n    return that\n}\n\nfunction fromArrayBuffer(that, array, byteOffset, length) {\n    array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n    if (byteOffset < 0 || array.byteLength < byteOffset) {\n        throw new RangeError(\"'offset' is out of bounds\")\n    }\n\n    if (array.byteLength < byteOffset + (length || 0)) {\n        throw new RangeError(\"'length' is out of bounds\")\n    }\n\n    if (byteOffset === undefined && length === undefined) {\n        array = new Uint8Array(array)\n    } else if (length === undefined) {\n        array = new Uint8Array(array, byteOffset)\n    } else {\n        array = new Uint8Array(array, byteOffset, length)\n    }\n\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        // Return an augmented `Uint8Array` instance, for best performance\n        that = array\n        that.__proto__ = Buffer.prototype\n    } else {\n        // Fallback: Return an object instance of the Buffer class\n        that = fromArrayLike(that, array)\n    }\n    return that\n}\n\nfunction fromObject(that, obj) {\n    if (internalIsBuffer(obj)) {\n        var len = checked(obj.length) | 0\n        that = createBuffer(that, len)\n\n        if (that.length === 0) {\n            return that\n        }\n\n        obj.copy(that, 0, 0, len)\n        return that\n    }\n\n    if (obj) {\n        if (\n            (typeof ArrayBuffer !== 'undefined' &&\n                obj.buffer instanceof ArrayBuffer) ||\n            'length' in obj\n        ) {\n            if (typeof obj.length !== 'number' || isnan(obj.length)) {\n                return createBuffer(that, 0)\n            }\n            return fromArrayLike(that, obj)\n        }\n\n        if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n            return fromArrayLike(that, obj.data)\n        }\n    }\n\n    throw new TypeError(\n        'First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.',\n    )\n}\n\nfunction checked(length) {\n    // Note: cannot use `length < kMaxLength()` here because that fails when\n    // length is NaN (which is otherwise coerced to zero.)\n    if (length >= kMaxLength()) {\n        throw new RangeError(\n            'Attempt to allocate Buffer larger than maximum ' +\n                'size: 0x' +\n                kMaxLength().toString(16) +\n                ' bytes',\n        )\n    }\n    return length | 0\n}\n\nexport function SlowBuffer(length) {\n    if (+length != length) {\n        // eslint-disable-line eqeqeq\n        length = 0\n    }\n    return Buffer.alloc(+length)\n}\nBuffer.isBuffer = isBuffer\nfunction internalIsBuffer(b) {\n    return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare(a, b) {\n    if (!internalIsBuffer(a) || !internalIsBuffer(b)) {\n        throw new TypeError('Arguments must be Buffers')\n    }\n\n    if (a === b) return 0\n\n    var x = a.length\n    var y = b.length\n\n    for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n        if (a[i] !== b[i]) {\n            x = a[i]\n            y = b[i]\n            break\n        }\n    }\n\n    if (x < y) return -1\n    if (y < x) return 1\n    return 0\n}\n\nBuffer.isEncoding = function isEncoding(encoding) {\n    switch (String(encoding).toLowerCase()) {\n        case 'hex':\n        case 'utf8':\n        case 'utf-8':\n        case 'ascii':\n        case 'latin1':\n        case 'binary':\n        case 'base64':\n        case 'ucs2':\n        case 'ucs-2':\n        case 'utf16le':\n        case 'utf-16le':\n            return true\n        default:\n            return false\n    }\n}\n\nBuffer.concat = function concat(list, length) {\n    if (!Array.isArray(list)) {\n        throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n\n    if (list.length === 0) {\n        return Buffer.alloc(0)\n    }\n\n    var i\n    if (length === undefined) {\n        length = 0\n        for (i = 0; i < list.length; ++i) {\n            length += list[i].length\n        }\n    }\n\n    var buffer = Buffer.allocUnsafe(length)\n    var pos = 0\n    for (i = 0; i < list.length; ++i) {\n        var buf = list[i]\n        if (!internalIsBuffer(buf)) {\n            throw new TypeError('\"list\" argument must be an Array of Buffers')\n        }\n        buf.copy(buffer, pos)\n        pos += buf.length\n    }\n    return buffer\n}\n\nfunction byteLength(string, encoding) {\n    if (internalIsBuffer(string)) {\n        return string.length\n    }\n    if (\n        typeof ArrayBuffer !== 'undefined' &&\n        typeof ArrayBuffer.isView === 'function' &&\n        (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)\n    ) {\n        return string.byteLength\n    }\n    if (typeof string !== 'string') {\n        string = '' + string\n    }\n\n    var len = string.length\n    if (len === 0) return 0\n\n    // Use a for loop to avoid recursion\n    var loweredCase = false\n    for (;;) {\n        switch (encoding) {\n            case 'ascii':\n            case 'latin1':\n            case 'binary':\n                return len\n            case 'utf8':\n            case 'utf-8':\n            case undefined:\n                return utf8ToBytes(string).length\n            case 'ucs2':\n            case 'ucs-2':\n            case 'utf16le':\n            case 'utf-16le':\n                return len * 2\n            case 'hex':\n                return len >>> 1\n            case 'base64':\n                return base64ToBytes(string).length\n            default:\n                if (loweredCase) return utf8ToBytes(string).length // assume utf8\n                encoding = ('' + encoding).toLowerCase()\n                loweredCase = true\n        }\n    }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString(encoding, start, end) {\n    var loweredCase = false\n\n    // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n    // property of a typed array.\n\n    // This behaves neither like String nor Uint8Array in that we set start/end\n    // to their upper/lower bounds if the value passed is out of range.\n    // undefined is handled specially as per ECMA-262 6th Edition,\n    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n    if (start === undefined || start < 0) {\n        start = 0\n    }\n    // Return early if start > this.length. Done here to prevent potential uint32\n    // coercion fail below.\n    if (start > this.length) {\n        return ''\n    }\n\n    if (end === undefined || end > this.length) {\n        end = this.length\n    }\n\n    if (end <= 0) {\n        return ''\n    }\n\n    // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n    end >>>= 0\n    start >>>= 0\n\n    if (end <= start) {\n        return ''\n    }\n\n    if (!encoding) encoding = 'utf8'\n\n    while (true) {\n        switch (encoding) {\n            case 'hex':\n                return hexSlice(this, start, end)\n\n            case 'utf8':\n            case 'utf-8':\n                return utf8Slice(this, start, end)\n\n            case 'ascii':\n                return asciiSlice(this, start, end)\n\n            case 'latin1':\n            case 'binary':\n                return latin1Slice(this, start, end)\n\n            case 'base64':\n                return base64Slice(this, start, end)\n\n            case 'ucs2':\n            case 'ucs-2':\n            case 'utf16le':\n            case 'utf-16le':\n                return utf16leSlice(this, start, end)\n\n            default:\n                if (loweredCase)\n                    throw new TypeError('Unknown encoding: ' + encoding)\n                encoding = (encoding + '').toLowerCase()\n                loweredCase = true\n        }\n    }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap(b, n, m) {\n    var i = b[n]\n    b[n] = b[m]\n    b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16() {\n    var len = this.length\n    if (len % 2 !== 0) {\n        throw new RangeError('Buffer size must be a multiple of 16-bits')\n    }\n    for (var i = 0; i < len; i += 2) {\n        swap(this, i, i + 1)\n    }\n    return this\n}\n\nBuffer.prototype.swap32 = function swap32() {\n    var len = this.length\n    if (len % 4 !== 0) {\n        throw new RangeError('Buffer size must be a multiple of 32-bits')\n    }\n    for (var i = 0; i < len; i += 4) {\n        swap(this, i, i + 3)\n        swap(this, i + 1, i + 2)\n    }\n    return this\n}\n\nBuffer.prototype.swap64 = function swap64() {\n    var len = this.length\n    if (len % 8 !== 0) {\n        throw new RangeError('Buffer size must be a multiple of 64-bits')\n    }\n    for (var i = 0; i < len; i += 8) {\n        swap(this, i, i + 7)\n        swap(this, i + 1, i + 6)\n        swap(this, i + 2, i + 5)\n        swap(this, i + 3, i + 4)\n    }\n    return this\n}\n\nBuffer.prototype.toString = function toString() {\n    var length = this.length | 0\n    if (length === 0) return ''\n    if (arguments.length === 0) return utf8Slice(this, 0, length)\n    return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals(b) {\n    if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')\n    if (this === b) return true\n    return Buffer.compare(this, b) === 0\n}\n\n\nBuffer.prototype.compare = function compare(\n    target,\n    start,\n    end,\n    thisStart,\n    thisEnd,\n) {\n    if (!internalIsBuffer(target)) {\n        throw new TypeError('Argument must be a Buffer')\n    }\n\n    if (start === undefined) {\n        start = 0\n    }\n    if (end === undefined) {\n        end = target ? target.length : 0\n    }\n    if (thisStart === undefined) {\n        thisStart = 0\n    }\n    if (thisEnd === undefined) {\n        thisEnd = this.length\n    }\n\n    if (\n        start < 0 ||\n        end > target.length ||\n        thisStart < 0 ||\n        thisEnd > this.length\n    ) {\n        throw new RangeError('out of range index')\n    }\n\n    if (thisStart >= thisEnd && start >= end) {\n        return 0\n    }\n    if (thisStart >= thisEnd) {\n        return -1\n    }\n    if (start >= end) {\n        return 1\n    }\n\n    start >>>= 0\n    end >>>= 0\n    thisStart >>>= 0\n    thisEnd >>>= 0\n\n    if (this === target) return 0\n\n    var x = thisEnd - thisStart\n    var y = end - start\n    var len = Math.min(x, y)\n\n    var thisCopy = this.slice(thisStart, thisEnd)\n    var targetCopy = target.slice(start, end)\n\n    for (var i = 0; i < len; ++i) {\n        if (thisCopy[i] !== targetCopy[i]) {\n            x = thisCopy[i]\n            y = targetCopy[i]\n            break\n        }\n    }\n\n    if (x < y) return -1\n    if (y < x) return 1\n    return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n    // Empty buffer means no match\n    if (buffer.length === 0) return -1\n\n    // Normalize byteOffset\n    if (typeof byteOffset === 'string') {\n        encoding = byteOffset\n        byteOffset = 0\n    } else if (byteOffset > 0x7fffffff) {\n        byteOffset = 0x7fffffff\n    } else if (byteOffset < -0x80000000) {\n        byteOffset = -0x80000000\n    }\n    byteOffset = +byteOffset // Coerce to Number.\n    if (isNaN(byteOffset)) {\n        // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n        byteOffset = dir ? 0 : buffer.length - 1\n    }\n\n    // Normalize byteOffset: negative offsets start from the end of the buffer\n    if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n    if (byteOffset >= buffer.length) {\n        if (dir) return -1\n        else byteOffset = buffer.length - 1\n    } else if (byteOffset < 0) {\n        if (dir) byteOffset = 0\n        else return -1\n    }\n\n    // Normalize val\n    if (typeof val === 'string') {\n        val = Buffer.from(val, encoding)\n    }\n\n    // Finally, search either indexOf (if dir is true) or lastIndexOf\n    if (internalIsBuffer(val)) {\n        // Special case: looking for empty string/buffer always fails\n        if (val.length === 0) {\n            return -1\n        }\n        return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n    } else if (typeof val === 'number') {\n        val = val & 0xff // Search for a byte value [0-255]\n        if (\n            Buffer.TYPED_ARRAY_SUPPORT &&\n            typeof Uint8Array.prototype.indexOf === 'function'\n        ) {\n            if (dir) {\n                return Uint8Array.prototype.indexOf.call(\n                    buffer,\n                    val,\n                    byteOffset,\n                )\n            } else {\n                return Uint8Array.prototype.lastIndexOf.call(\n                    buffer,\n                    val,\n                    byteOffset,\n                )\n            }\n        }\n        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n    }\n\n    throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n    var indexSize = 1\n    var arrLength = arr.length\n    var valLength = val.length\n\n    if (encoding !== undefined) {\n        encoding = String(encoding).toLowerCase()\n        if (\n            encoding === 'ucs2' ||\n            encoding === 'ucs-2' ||\n            encoding === 'utf16le' ||\n            encoding === 'utf-16le'\n        ) {\n            if (arr.length < 2 || val.length < 2) {\n                return -1\n            }\n            indexSize = 2\n            arrLength /= 2\n            valLength /= 2\n            byteOffset /= 2\n        }\n    }\n\n    function read(buf, i) {\n        if (indexSize === 1) {\n            return buf[i]\n        } else {\n            return buf.readUInt16BE(i * indexSize)\n        }\n    }\n\n    var i\n    if (dir) {\n        var foundIndex = -1\n        for (i = byteOffset; i < arrLength; i++) {\n            if (\n                read(arr, i) ===\n                read(val, foundIndex === -1 ? 0 : i - foundIndex)\n            ) {\n                if (foundIndex === -1) foundIndex = i\n                if (i - foundIndex + 1 === valLength)\n                    return foundIndex * indexSize\n            } else {\n                if (foundIndex !== -1) i -= i - foundIndex\n                foundIndex = -1\n            }\n        }\n    } else {\n        if (byteOffset + valLength > arrLength)\n            byteOffset = arrLength - valLength\n        for (i = byteOffset; i >= 0; i--) {\n            var found = true\n            for (var j = 0; j < valLength; j++) {\n                if (read(arr, i + j) !== read(val, j)) {\n                    found = false\n                    break\n                }\n            }\n            if (found) return i\n        }\n    }\n\n    return -1\n}\n\nBuffer.prototype.includes = function includes(val, byteOffset, encoding) {\n    return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n    return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n    return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite(buf, string, offset, length) {\n    offset = Number(offset) || 0\n    var remaining = buf.length - offset\n    if (!length) {\n        length = remaining\n    } else {\n        length = Number(length)\n        if (length > remaining) {\n            length = remaining\n        }\n    }\n\n    // must be an even number of digits\n    var strLen = string.length\n    if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n    if (length > strLen / 2) {\n        length = strLen / 2\n    }\n    for (var i = 0; i < length; ++i) {\n        var parsed = parseInt(string.substr(i * 2, 2), 16)\n        if (isNaN(parsed)) return i\n        buf[offset + i] = parsed\n    }\n    return i\n}\n\nfunction utf8Write(buf, string, offset, length) {\n    return blitBuffer(\n        utf8ToBytes(string, buf.length - offset),\n        buf,\n        offset,\n        length,\n    )\n}\n\nfunction asciiWrite(buf, string, offset, length) {\n    return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write(buf, string, offset, length) {\n    return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write(buf, string, offset, length) {\n    return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write(buf, string, offset, length) {\n    return blitBuffer(\n        utf16leToBytes(string, buf.length - offset),\n        buf,\n        offset,\n        length,\n    )\n}\n\nBuffer.prototype.write = function write(string, offset, length, encoding) {\n    // Buffer#write(string)\n    if (offset === undefined) {\n        encoding = 'utf8'\n        length = this.length\n        offset = 0\n        // Buffer#write(string, encoding)\n    } else if (length === undefined && typeof offset === 'string') {\n        encoding = offset\n        length = this.length\n        offset = 0\n        // Buffer#write(string, offset[, length][, encoding])\n    } else if (isFinite(offset)) {\n        offset = offset | 0\n        if (isFinite(length)) {\n            length = length | 0\n            if (encoding === undefined) encoding = 'utf8'\n        } else {\n            encoding = length\n            length = undefined\n        }\n        // legacy write(string, encoding, offset, length) - remove in v0.13\n    } else {\n        throw new Error(\n            'Buffer.write(string, encoding, offset[, length]) is no longer supported',\n        )\n    }\n\n    var remaining = this.length - offset\n    if (length === undefined || length > remaining) length = remaining\n\n    if (\n        (string.length > 0 && (length < 0 || offset < 0)) ||\n        offset > this.length\n    ) {\n        throw new RangeError('Attempt to write outside buffer bounds')\n    }\n\n    if (!encoding) encoding = 'utf8'\n\n    var loweredCase = false\n    for (;;) {\n        switch (encoding) {\n            case 'hex':\n                return hexWrite(this, string, offset, length)\n\n            case 'utf8':\n            case 'utf-8':\n                return utf8Write(this, string, offset, length)\n\n            case 'ascii':\n                return asciiWrite(this, string, offset, length)\n\n            case 'latin1':\n            case 'binary':\n                return latin1Write(this, string, offset, length)\n\n            case 'base64':\n                // Warning: maxLength not taken into account in base64Write\n                return base64Write(this, string, offset, length)\n\n            case 'ucs2':\n            case 'ucs-2':\n            case 'utf16le':\n            case 'utf-16le':\n                return ucs2Write(this, string, offset, length)\n\n            default:\n                if (loweredCase)\n                    throw new TypeError('Unknown encoding: ' + encoding)\n                encoding = ('' + encoding).toLowerCase()\n                loweredCase = true\n        }\n    }\n}\n\nBuffer.prototype.toJSON = function toJSON() {\n    return {\n        type: 'Buffer',\n        data: Array.prototype.slice.call(this._arr || this, 0),\n    }\n}\n\nfunction base64Slice(buf, start, end) {\n    if (start === 0 && end === buf.length) {\n        return base64fromByteArray(buf)\n    } else {\n        return base64fromByteArray(buf.slice(start, end))\n    }\n}\n\nfunction utf8Slice(buf, start, end) {\n    end = Math.min(buf.length, end)\n    var res = []\n\n    var i = start\n    while (i < end) {\n        var firstByte = buf[i]\n        var codePoint = null\n        var bytesPerSequence =\n            firstByte > 0xef\n                ? 4\n                : firstByte > 0xdf\n                ? 3\n                : firstByte > 0xbf\n                ? 2\n                : 1\n\n        if (i + bytesPerSequence <= end) {\n            var secondByte, thirdByte, fourthByte, tempCodePoint\n\n            switch (bytesPerSequence) {\n                case 1:\n                    if (firstByte < 0x80) {\n                        codePoint = firstByte\n                    }\n                    break\n                case 2:\n                    secondByte = buf[i + 1]\n                    if ((secondByte & 0xc0) === 0x80) {\n                        tempCodePoint =\n                            ((firstByte & 0x1f) << 0x6) | (secondByte & 0x3f)\n                        if (tempCodePoint > 0x7f) {\n                            codePoint = tempCodePoint\n                        }\n                    }\n                    break\n                case 3:\n                    secondByte = buf[i + 1]\n                    thirdByte = buf[i + 2]\n                    if (\n                        (secondByte & 0xc0) === 0x80 &&\n                        (thirdByte & 0xc0) === 0x80\n                    ) {\n                        tempCodePoint =\n                            ((firstByte & 0xf) << 0xc) |\n                            ((secondByte & 0x3f) << 0x6) |\n                            (thirdByte & 0x3f)\n                        if (\n                            tempCodePoint > 0x7ff &&\n                            (tempCodePoint < 0xd800 || tempCodePoint > 0xdfff)\n                        ) {\n                            codePoint = tempCodePoint\n                        }\n                    }\n                    break\n                case 4:\n                    secondByte = buf[i + 1]\n                    thirdByte = buf[i + 2]\n                    fourthByte = buf[i + 3]\n                    if (\n                        (secondByte & 0xc0) === 0x80 &&\n                        (thirdByte & 0xc0) === 0x80 &&\n                        (fourthByte & 0xc0) === 0x80\n                    ) {\n                        tempCodePoint =\n                            ((firstByte & 0xf) << 0x12) |\n                            ((secondByte & 0x3f) << 0xc) |\n                            ((thirdByte & 0x3f) << 0x6) |\n                            (fourthByte & 0x3f)\n                        if (\n                            tempCodePoint > 0xffff &&\n                            tempCodePoint < 0x110000\n                        ) {\n                            codePoint = tempCodePoint\n                        }\n                    }\n            }\n        }\n\n        if (codePoint === null) {\n            // we did not generate a valid codePoint so insert a\n            // replacement char (U+FFFD) and advance only 1 byte\n            codePoint = 0xfffd\n            bytesPerSequence = 1\n        } else if (codePoint > 0xffff) {\n            // encode to utf16 (surrogate pair dance)\n            codePoint -= 0x10000\n            res.push(((codePoint >>> 10) & 0x3ff) | 0xd800)\n            codePoint = 0xdc00 | (codePoint & 0x3ff)\n        }\n\n        res.push(codePoint)\n        i += bytesPerSequence\n    }\n\n    return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray(codePoints) {\n    var len = codePoints.length\n    if (len <= MAX_ARGUMENTS_LENGTH) {\n        return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n    }\n\n    // Decode in chunks to avoid \"call stack size exceeded\".\n    var res = ''\n    var i = 0\n    while (i < len) {\n        res += String.fromCharCode.apply(\n            String,\n            codePoints.slice(i, (i += MAX_ARGUMENTS_LENGTH)),\n        )\n    }\n    return res\n}\n\nfunction asciiSlice(buf, start, end) {\n    var ret = ''\n    end = Math.min(buf.length, end)\n\n    for (var i = start; i < end; ++i) {\n        ret += String.fromCharCode(buf[i] & 0x7f)\n    }\n    return ret\n}\n\nfunction latin1Slice(buf, start, end) {\n    var ret = ''\n    end = Math.min(buf.length, end)\n\n    for (var i = start; i < end; ++i) {\n        ret += String.fromCharCode(buf[i])\n    }\n    return ret\n}\n\nfunction hexSlice(buf, start, end) {\n    var len = buf.length\n\n    if (!start || start < 0) start = 0\n    if (!end || end < 0 || end > len) end = len\n\n    var out = ''\n    for (var i = start; i < end; ++i) {\n        out += toHex(buf[i])\n    }\n    return out\n}\n\nfunction utf16leSlice(buf, start, end) {\n    var bytes = buf.slice(start, end)\n    var res = ''\n    for (var i = 0; i < bytes.length; i += 2) {\n        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n    }\n    return res\n}\n\nBuffer.prototype.slice = function slice(start, end) {\n    var len = this.length\n    start = ~~start\n    end = end === undefined ? len : ~~end\n\n    if (start < 0) {\n        start += len\n        if (start < 0) start = 0\n    } else if (start > len) {\n        start = len\n    }\n\n    if (end < 0) {\n        end += len\n        if (end < 0) end = 0\n    } else if (end > len) {\n        end = len\n    }\n\n    if (end < start) end = start\n\n    var newBuf\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        newBuf = this.subarray(start, end)\n        newBuf.__proto__ = Buffer.prototype\n    } else {\n        var sliceLen = end - start\n        newBuf = new Buffer(sliceLen, undefined)\n        for (var i = 0; i < sliceLen; ++i) {\n            newBuf[i] = this[i + start]\n        }\n    }\n\n    return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset(offset, ext, length) {\n    if (offset % 1 !== 0 || offset < 0)\n        throw new RangeError('offset is not uint')\n    if (offset + ext > length)\n        throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE(\n    offset,\n    byteLength,\n    noAssert,\n) {\n    offset = offset | 0\n    byteLength = byteLength | 0\n    if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n    var val = this[offset]\n    var mul = 1\n    var i = 0\n    while (++i < byteLength && (mul *= 0x100)) {\n        val += this[offset + i] * mul\n    }\n\n    return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE(\n    offset,\n    byteLength,\n    noAssert,\n) {\n    offset = offset | 0\n    byteLength = byteLength | 0\n    if (!noAssert) {\n        checkOffset(offset, byteLength, this.length)\n    }\n\n    var val = this[offset + --byteLength]\n    var mul = 1\n    while (byteLength > 0 && (mul *= 0x100)) {\n        val += this[offset + --byteLength] * mul\n    }\n\n    return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 1, this.length)\n    return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 2, this.length)\n    return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 2, this.length)\n    return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length)\n\n    return (\n        (this[offset] | (this[offset + 1] << 8) | (this[offset + 2] << 16)) +\n        this[offset + 3] * 0x1000000\n    )\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length)\n\n    return (\n        this[offset] * 0x1000000 +\n        ((this[offset + 1] << 16) | (this[offset + 2] << 8) | this[offset + 3])\n    )\n}\n\nBuffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {\n    offset = offset | 0\n    byteLength = byteLength | 0\n    if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n    var val = this[offset]\n    var mul = 1\n    var i = 0\n    while (++i < byteLength && (mul *= 0x100)) {\n        val += this[offset + i] * mul\n    }\n    mul *= 0x80\n\n    if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n    return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {\n    offset = offset | 0\n    byteLength = byteLength | 0\n    if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n    var i = byteLength\n    var mul = 1\n    var val = this[offset + --i]\n    while (i > 0 && (mul *= 0x100)) {\n        val += this[offset + --i] * mul\n    }\n    mul *= 0x80\n\n    if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n    return val\n}\n\nBuffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 1, this.length)\n    if (!(this[offset] & 0x80)) return this[offset]\n    return (0xff - this[offset] + 1) * -1\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 2, this.length)\n    var val = this[offset] | (this[offset + 1] << 8)\n    return val & 0x8000 ? val | 0xffff0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 2, this.length)\n    var val = this[offset + 1] | (this[offset] << 8)\n    return val & 0x8000 ? val | 0xffff0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length)\n\n    return (\n        this[offset] |\n        (this[offset + 1] << 8) |\n        (this[offset + 2] << 16) |\n        (this[offset + 3] << 24)\n    )\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length)\n\n    return (\n        (this[offset] << 24) |\n        (this[offset + 1] << 16) |\n        (this[offset + 2] << 8) |\n        this[offset + 3]\n    )\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length)\n    return ieee754read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length)\n    return ieee754read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 8, this.length)\n    return ieee754read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 8, this.length)\n    return ieee754read(this, offset, false, 52, 8)\n}\n\nfunction checkInt(buf, value, offset, ext, max, min) {\n    if (!internalIsBuffer(buf))\n        throw new TypeError('\"buffer\" argument must be a Buffer instance')\n    if (value > max || value < min)\n        throw new RangeError('\"value\" argument is out of bounds')\n    if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE(\n    value,\n    offset,\n    byteLength,\n    noAssert,\n) {\n    value = +value\n    offset = offset | 0\n    byteLength = byteLength | 0\n    if (!noAssert) {\n        var maxBytes = Math.pow(2, 8 * byteLength) - 1\n        checkInt(this, value, offset, byteLength, maxBytes, 0)\n    }\n\n    var mul = 1\n    var i = 0\n    this[offset] = value & 0xff\n    while (++i < byteLength && (mul *= 0x100)) {\n        this[offset + i] = (value / mul) & 0xff\n    }\n\n    return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE(\n    value,\n    offset,\n    byteLength,\n    noAssert,\n) {\n    value = +value\n    offset = offset | 0\n    byteLength = byteLength | 0\n    if (!noAssert) {\n        var maxBytes = Math.pow(2, 8 * byteLength) - 1\n        checkInt(this, value, offset, byteLength, maxBytes, 0)\n    }\n\n    var i = byteLength - 1\n    var mul = 1\n    this[offset + i] = value & 0xff\n    while (--i >= 0 && (mul *= 0x100)) {\n        this[offset + i] = (value / mul) & 0xff\n    }\n\n    return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n    value = +value\n    offset = offset | 0\n    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n    this[offset] = value & 0xff\n    return offset + 1\n}\n\nfunction objectWriteUInt16(buf, value, offset, littleEndian) {\n    if (value < 0) value = 0xffff + value + 1\n    for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n        buf[offset + i] =\n            (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n            ((littleEndian ? i : 1 - i) * 8)\n    }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE(\n    value,\n    offset,\n    noAssert,\n) {\n    value = +value\n    offset = offset | 0\n    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value & 0xff\n        this[offset + 1] = value >>> 8\n    } else {\n        objectWriteUInt16(this, value, offset, true)\n    }\n    return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE(\n    value,\n    offset,\n    noAssert,\n) {\n    value = +value\n    offset = offset | 0\n    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value >>> 8\n        this[offset + 1] = value & 0xff\n    } else {\n        objectWriteUInt16(this, value, offset, false)\n    }\n    return offset + 2\n}\n\nfunction objectWriteUInt32(buf, value, offset, littleEndian) {\n    if (value < 0) value = 0xffffffff + value + 1\n    for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n        buf[offset + i] = (value >>> ((littleEndian ? i : 3 - i) * 8)) & 0xff\n    }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE(\n    value,\n    offset,\n    noAssert,\n) {\n    value = +value\n    offset = offset | 0\n    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset + 3] = value >>> 24\n        this[offset + 2] = value >>> 16\n        this[offset + 1] = value >>> 8\n        this[offset] = value & 0xff\n    } else {\n        objectWriteUInt32(this, value, offset, true)\n    }\n    return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE(\n    value,\n    offset,\n    noAssert,\n) {\n    value = +value\n    offset = offset | 0\n    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value >>> 24\n        this[offset + 1] = value >>> 16\n        this[offset + 2] = value >>> 8\n        this[offset + 3] = value & 0xff\n    } else {\n        objectWriteUInt32(this, value, offset, false)\n    }\n    return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE(\n    value,\n    offset,\n    byteLength,\n    noAssert,\n) {\n    value = +value\n    offset = offset | 0\n    if (!noAssert) {\n        var limit = Math.pow(2, 8 * byteLength - 1)\n\n        checkInt(this, value, offset, byteLength, limit - 1, -limit)\n    }\n\n    var i = 0\n    var mul = 1\n    var sub = 0\n    this[offset] = value & 0xff\n    while (++i < byteLength && (mul *= 0x100)) {\n        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n            sub = 1\n        }\n        this[offset + i] = (((value / mul) >> 0) - sub) & 0xff\n    }\n\n    return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE(\n    value,\n    offset,\n    byteLength,\n    noAssert,\n) {\n    value = +value\n    offset = offset | 0\n    if (!noAssert) {\n        var limit = Math.pow(2, 8 * byteLength - 1)\n\n        checkInt(this, value, offset, byteLength, limit - 1, -limit)\n    }\n\n    var i = byteLength - 1\n    var mul = 1\n    var sub = 0\n    this[offset + i] = value & 0xff\n    while (--i >= 0 && (mul *= 0x100)) {\n        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n            sub = 1\n        }\n        this[offset + i] = (((value / mul) >> 0) - sub) & 0xff\n    }\n\n    return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n    value = +value\n    offset = offset | 0\n    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n    if (value < 0) value = 0xff + value + 1\n    this[offset] = value & 0xff\n    return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n    value = +value\n    offset = offset | 0\n    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value & 0xff\n        this[offset + 1] = value >>> 8\n    } else {\n        objectWriteUInt16(this, value, offset, true)\n    }\n    return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n    value = +value\n    offset = offset | 0\n    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value >>> 8\n        this[offset + 1] = value & 0xff\n    } else {\n        objectWriteUInt16(this, value, offset, false)\n    }\n    return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n    value = +value\n    offset = offset | 0\n    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value & 0xff\n        this[offset + 1] = value >>> 8\n        this[offset + 2] = value >>> 16\n        this[offset + 3] = value >>> 24\n    } else {\n        objectWriteUInt32(this, value, offset, true)\n    }\n    return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n    value = +value\n    offset = offset | 0\n    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n    if (value < 0) value = 0xffffffff + value + 1\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value >>> 24\n        this[offset + 1] = value >>> 16\n        this[offset + 2] = value >>> 8\n        this[offset + 3] = value & 0xff\n    } else {\n        objectWriteUInt32(this, value, offset, false)\n    }\n    return offset + 4\n}\n\nfunction checkIEEE754(buf, value, offset, ext, max, min) {\n    if (offset + ext > buf.length) throw new RangeError('Index out of range')\n    if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat(buf, value, offset, littleEndian, noAssert) {\n    if (!noAssert) {\n        checkIEEE754(\n            buf,\n            value,\n            offset,\n            4,\n            3.4028234663852886e38,\n            -3.4028234663852886e38,\n        )\n    }\n    ieee754write(buf, value, offset, littleEndian, 23, 4)\n    return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n    return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n    return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble(buf, value, offset, littleEndian, noAssert) {\n    if (!noAssert) {\n        checkIEEE754(\n            buf,\n            value,\n            offset,\n            8,\n            1.7976931348623157e308,\n            -1.7976931348623157e308,\n        )\n    }\n    ieee754write(buf, value, offset, littleEndian, 52, 8)\n    return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE(\n    value,\n    offset,\n    noAssert,\n) {\n    return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE(\n    value,\n    offset,\n    noAssert,\n) {\n    return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy(target, targetStart, start, end) {\n    if (!start) start = 0\n    if (!end && end !== 0) end = this.length\n    if (targetStart >= target.length) targetStart = target.length\n    if (!targetStart) targetStart = 0\n    if (end > 0 && end < start) end = start\n\n    // Copy 0 bytes; we're done\n    if (end === start) return 0\n    if (target.length === 0 || this.length === 0) return 0\n\n    // Fatal error conditions\n    if (targetStart < 0) {\n        throw new RangeError('targetStart out of bounds')\n    }\n    if (start < 0 || start >= this.length)\n        throw new RangeError('sourceStart out of bounds')\n    if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n    // Are we oob?\n    if (end > this.length) end = this.length\n    if (target.length - targetStart < end - start) {\n        end = target.length - targetStart + start\n    }\n\n    var len = end - start\n    var i\n\n    if (this === target && start < targetStart && targetStart < end) {\n        // descending copy from end\n        for (i = len - 1; i >= 0; --i) {\n            target[i + targetStart] = this[i + start]\n        }\n    } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n        // ascending copy from start\n        for (i = 0; i < len; ++i) {\n            target[i + targetStart] = this[i + start]\n        }\n    } else {\n        Uint8Array.prototype.set.call(\n            target,\n            this.subarray(start, start + len),\n            targetStart,\n        )\n    }\n\n    return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill(val, start, end, encoding) {\n    // Handle string cases:\n    if (typeof val === 'string') {\n        if (typeof start === 'string') {\n            encoding = start\n            start = 0\n            end = this.length\n        } else if (typeof end === 'string') {\n            encoding = end\n            end = this.length\n        }\n        if (val.length === 1) {\n            var code = val.charCodeAt(0)\n            if (code < 256) {\n                val = code\n            }\n        }\n        if (encoding !== undefined && typeof encoding !== 'string') {\n            throw new TypeError('encoding must be a string')\n        }\n        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n            throw new TypeError('Unknown encoding: ' + encoding)\n        }\n    } else if (typeof val === 'number') {\n        val = val & 255\n    }\n\n    // Invalid ranges are not set to a default, so can range check early.\n    if (start < 0 || this.length < start || this.length < end) {\n        throw new RangeError('Out of range index')\n    }\n\n    if (end <= start) {\n        return this\n    }\n\n    start = start >>> 0\n    end = end === undefined ? this.length : end >>> 0\n\n    if (!val) val = 0\n\n    var i\n    if (typeof val === 'number') {\n        for (i = start; i < end; ++i) {\n            this[i] = val\n        }\n    } else {\n        var bytes = internalIsBuffer(val)\n            ? val\n            : utf8ToBytes(new Buffer(val, encoding).toString())\n        var len = bytes.length\n        for (i = 0; i < end - start; ++i) {\n            this[i + start] = bytes[i % len]\n        }\n    }\n\n    return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean(str) {\n    // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n    str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n    // Node converts strings with length < 2 to ''\n    if (str.length < 2) return ''\n    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n    while (str.length % 4 !== 0) {\n        str = str + '='\n    }\n    return str\n}\n\nfunction stringtrim(str) {\n    if (str.trim) return str.trim()\n    return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex(n) {\n    if (n < 16) return '0' + n.toString(16)\n    return n.toString(16)\n}\n\nfunction utf8ToBytes(string, units) {\n    units = units || Infinity\n    var codePoint\n    var length = string.length\n    var leadSurrogate = null\n    var bytes = []\n\n    for (var i = 0; i < length; ++i) {\n        codePoint = string.charCodeAt(i)\n\n        // is surrogate component\n        if (codePoint > 0xd7ff && codePoint < 0xe000) {\n            // last char was a lead\n            if (!leadSurrogate) {\n                // no lead yet\n                if (codePoint > 0xdbff) {\n                    // unexpected trail\n                    if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd)\n                    continue\n                } else if (i + 1 === length) {\n                    // unpaired lead\n                    if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd)\n                    continue\n                }\n\n                // valid lead\n                leadSurrogate = codePoint\n\n                continue\n            }\n\n            // 2 leads in a row\n            if (codePoint < 0xdc00) {\n                if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd)\n                leadSurrogate = codePoint\n                continue\n            }\n\n            // valid surrogate pair\n            codePoint =\n                (((leadSurrogate - 0xd800) << 10) | (codePoint - 0xdc00)) +\n                0x10000\n        } else if (leadSurrogate) {\n            // valid bmp char, but last char was a lead\n            if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd)\n        }\n\n        leadSurrogate = null\n\n        // encode utf8\n        if (codePoint < 0x80) {\n            if ((units -= 1) < 0) break\n            bytes.push(codePoint)\n        } else if (codePoint < 0x800) {\n            if ((units -= 2) < 0) break\n            bytes.push((codePoint >> 0x6) | 0xc0, (codePoint & 0x3f) | 0x80)\n        } else if (codePoint < 0x10000) {\n            if ((units -= 3) < 0) break\n            bytes.push(\n                (codePoint >> 0xc) | 0xe0,\n                ((codePoint >> 0x6) & 0x3f) | 0x80,\n                (codePoint & 0x3f) | 0x80,\n            )\n        } else if (codePoint < 0x110000) {\n            if ((units -= 4) < 0) break\n            bytes.push(\n                (codePoint >> 0x12) | 0xf0,\n                ((codePoint >> 0xc) & 0x3f) | 0x80,\n                ((codePoint >> 0x6) & 0x3f) | 0x80,\n                (codePoint & 0x3f) | 0x80,\n            )\n        } else {\n            throw new Error('Invalid code point')\n        }\n    }\n\n    return bytes\n}\n\nfunction asciiToBytes(str) {\n    var byteArray = []\n    for (var i = 0; i < str.length; ++i) {\n        // Node's code seems to be doing this and not & 0x7F..\n        byteArray.push(str.charCodeAt(i) & 0xff)\n    }\n    return byteArray\n}\n\nfunction utf16leToBytes(str, units) {\n    var c, hi, lo\n    var byteArray = []\n    for (var i = 0; i < str.length; ++i) {\n        if ((units -= 2) < 0) break\n\n        c = str.charCodeAt(i)\n        hi = c >> 8\n        lo = c % 256\n        byteArray.push(lo)\n        byteArray.push(hi)\n    }\n\n    return byteArray\n}\n\nfunction base64ToBytes(str) {\n    return base64toByteArray(base64clean(str))\n}\n\nfunction blitBuffer(src, dst, offset, length) {\n    for (var i = 0; i < length; ++i) {\n        if (i + offset >= dst.length || i >= src.length) break\n        dst[i + offset] = src[i]\n    }\n    return i\n}\n\nfunction isnan(val) {\n    return val !== val // eslint-disable-line no-self-compare\n}\n\n// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nfunction isBuffer(obj) {\n    return (\n        obj != null &&\n        (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))\n    )\n}\n\nfunction isFastBuffer(obj) {\n    return (\n        !!obj.constructor &&\n        typeof obj.constructor.isBuffer === 'function' &&\n        obj.constructor.isBuffer(obj)\n    )\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer(obj) {\n    return (\n        typeof obj.readFloatLE === 'function' &&\n        typeof obj.slice === 'function' &&\n        isFastBuffer(obj.slice(0, 0))\n    )\n}\n\nfunction ieee754read(buffer, offset, isLE, mLen, nBytes) {\n    var e, m\n    var eLen = nBytes * 8 - mLen - 1\n    var eMax = (1 << eLen) - 1\n    var eBias = eMax >> 1\n    var nBits = -7\n    var i = isLE ? nBytes - 1 : 0\n    var d = isLE ? -1 : 1\n    var s = buffer[offset + i]\n\n    i += d\n\n    e = s & ((1 << -nBits) - 1)\n    s >>= -nBits\n    nBits += eLen\n    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n    m = e & ((1 << -nBits) - 1)\n    e >>= -nBits\n    nBits += mLen\n    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n    if (e === 0) {\n        e = 1 - eBias\n    } else if (e === eMax) {\n        return m ? NaN : (s ? -1 : 1) * Infinity\n    } else {\n        m = m + Math.pow(2, mLen)\n        e = e - eBias\n    }\n    return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nfunction ieee754write(buffer, value, offset, isLE, mLen, nBytes) {\n    var e, m, c\n    var eLen = nBytes * 8 - mLen - 1\n    var eMax = (1 << eLen) - 1\n    var eBias = eMax >> 1\n    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0\n    var i = isLE ? 0 : nBytes - 1\n    var d = isLE ? 1 : -1\n    var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n    value = Math.abs(value)\n\n    if (isNaN(value) || value === Infinity) {\n        m = isNaN(value) ? 1 : 0\n        e = eMax\n    } else {\n        e = Math.floor(Math.log(value) / Math.LN2)\n        if (value * (c = Math.pow(2, -e)) < 1) {\n            e--\n            c *= 2\n        }\n        if (e + eBias >= 1) {\n            value += rt / c\n        } else {\n            value += rt * Math.pow(2, 1 - eBias)\n        }\n        if (value * c >= 2) {\n            e++\n            c /= 2\n        }\n\n        if (e + eBias >= eMax) {\n            m = 0\n            e = eMax\n        } else if (e + eBias >= 1) {\n            m = (value * c - 1) * Math.pow(2, mLen)\n            e = e + eBias\n        } else {\n            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n            e = 0\n        }\n    }\n\n    for (\n        ;\n        mLen >= 8;\n        buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8\n    ) {}\n\n    e = (e << mLen) | m\n    eLen += mLen\n    for (\n        ;\n        eLen > 0;\n        buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8\n    ) {}\n\n    buffer[offset + i - d] |= s * 128\n}\n", "// EVENT PHASE CONSTANTS\n// https://developer.mozilla.org/en-US/docs/Web/API/Event/eventPhase\nconst NONE = 0;\nconst CAPTURING_PHASE = 1;\nconst AT_TARGET = 2;\nconst BUBBLING_PHASE = 3;\n\nexport function isEventTarget(value: any): value is EventTarget {\n\treturn (\n\t\tvalue != null &&\n\t\ttypeof value.addEventListener === \"function\" &&\n\t\ttypeof value.removeEventListener === \"function\" &&\n\t\ttypeof value.dispatchEvent === \"function\"\n\t);\n}\n\nfunction setEventProperty<T extends keyof Event>(\n\tev: Event,\n\tkey: T,\n\tvalue: Event[T],\n): void {\n\tObject.defineProperty(ev, key, {value, writable: false, configurable: true});\n}\n\nfunction isListenerOrListenerObject(\n\tvalue: unknown,\n): value is EventListenerOrEventListenerObject {\n\treturn (\n\t\ttypeof value === \"function\" ||\n\t\t(value !== null &&\n\t\t\ttypeof value === \"object\" &&\n\t\t\ttypeof (value as any).handleEvent === \"function\")\n\t);\n}\n\nfunction normalizeListenerOptions(\n\toptions: AddEventListenerOptions | boolean | null | undefined,\n): AddEventListenerOptions {\n\tif (typeof options === \"boolean\") {\n\t\treturn {capture: options};\n\t} else if (options == null) {\n\t\treturn {};\n\t}\n\n\treturn options;\n}\n\nconst _parent = Symbol.for(\"CustomEventTarget.parent\");\nconst _listeners = Symbol.for(\"CustomEventTarget.listeners\");\nconst _delegates = Symbol.for(\"CustomEventTarget.delegates\");\nconst _dispatchEventOnSelf = Symbol.for(\"CustomEventTarget.dispatchSelf\");\n\ninterface EventListenerRecord {\n\ttype: string;\n\t// listener is the original value passed to addEventListener, callback is the\n\t// actual function we call\n\tlistener: EventListenerOrEventListenerObject;\n\tcallback: EventListener;\n\toptions: AddEventListenerOptions;\n}\n\nexport class CustomEventTarget<TParent extends CustomEventTarget<TParent> = any>\n\timplements EventTarget\n{\n\tdeclare static dispatchEventOnSelf: typeof _dispatchEventOnSelf;\n\tdeclare [_parent]: TParent | null;\n\tdeclare [_listeners]: Array<EventListenerRecord>;\n\tdeclare [_delegates]: Set<EventTarget>;\n\tconstructor(parent: TParent | null = null) {\n\t\tthis[_parent] = parent;\n\t\tthis[_listeners] = [];\n\t\tthis[_delegates] = new Set<EventTarget>();\n\t}\n\n\taddEventListener(\n\t\ttype: string,\n\t\tlistener: EventListenerOrEventListenerObject | null,\n\t\toptions?: boolean | AddEventListenerOptions,\n\t): void {\n\t\tif (!isListenerOrListenerObject(listener)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst listeners = this[_listeners];\n\t\toptions = normalizeListenerOptions(options);\n\t\tlet callback: EventListener;\n\t\tif (typeof listener === \"function\") {\n\t\t\tcallback = listener;\n\t\t} else {\n\t\t\tcallback = (ev: Event) => listener.handleEvent(ev);\n\t\t}\n\t\tconst record: EventListenerRecord = {type, listener, callback, options};\n\n\t\tif (options.once) {\n\t\t\trecord.callback = function (this: any) {\n\t\t\t\tconst i = listeners.indexOf(record);\n\t\t\t\tif (i !== -1) {\n\t\t\t\t\tlisteners.splice(i, 1);\n\t\t\t\t}\n\n\t\t\t\treturn callback.apply(this, arguments as any);\n\t\t\t};\n\t\t}\n\n\t\tif (\n\t\t\tlisteners.some(\n\t\t\t\t(record1) =>\n\t\t\t\t\trecord.type === record1.type &&\n\t\t\t\t\trecord.listener === record1.listener &&\n\t\t\t\t\t!record.options.capture === !record1.options.capture,\n\t\t\t)\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tlisteners.push(record);\n\n\t\tfor (const delegate of this[_delegates]) {\n\t\t\tdelegate.addEventListener(type, record.callback, record.options);\n\t\t}\n\t}\n\n\tremoveEventListener(\n\t\ttype: string,\n\t\tlistener: EventListenerOrEventListenerObject | null,\n\t\toptions?: EventListenerOptions | boolean,\n\t): void {\n\t\tconst listeners = this[_listeners];\n\t\tif (listeners == null || !isListenerOrListenerObject(listener)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst options1 = normalizeListenerOptions(options);\n\t\tconst i = listeners.findIndex(\n\t\t\t(record) =>\n\t\t\t\trecord.type === type &&\n\t\t\t\trecord.listener === listener &&\n\t\t\t\t!record.options.capture === !options1.capture,\n\t\t);\n\n\t\tif (i === -1) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst record = listeners[i];\n\t\tlisteners.splice(i, 1);\n\n\t\tfor (const delegate of this[_delegates]) {\n\t\t\tdelegate.removeEventListener(\n\t\t\t\trecord.type,\n\t\t\t\trecord.callback,\n\t\t\t\trecord.options,\n\t\t\t);\n\t\t}\n\t}\n\n\tdispatchEvent(ev: Event): boolean {\n\t\tconst path: Array<CustomEventTarget> = [];\n\t\tfor (let parent = this[_parent]; parent; parent = parent[_parent]) {\n\t\t\tpath.push(parent);\n\t\t}\n\n\t\tlet cancelBubble = false;\n\t\tlet immediateCancelBubble = false;\n\t\tconst stopPropagation = ev.stopPropagation;\n\t\tsetEventProperty(ev, \"stopPropagation\", () => {\n\t\t\tcancelBubble = true;\n\t\t\treturn stopPropagation.call(ev);\n\t\t});\n\n\t\tconst stopImmediatePropagation = ev.stopImmediatePropagation;\n\t\tsetEventProperty(ev, \"stopImmediatePropagation\", () => {\n\t\t\timmediateCancelBubble = true;\n\t\t\treturn stopImmediatePropagation.call(ev);\n\t\t});\n\t\tsetEventProperty(ev, \"target\", this);\n\n\t\t// The only possible errors in this block are errors thrown by callbacks,\n\t\t// and dispatchEvent will only log these errors rather than throwing them.\n\t\t// Therefore, we place all code in a try block, log errors in the catch\n\t\t// block, and use an unsafe return statement in the finally block.\n\t\t//\n\t\t// Each early return within the try block returns true because while the\n\t\t// return value is overridden in the finally block, TypeScript\n\t\t// (justifiably) does not recognize the unsafe return statement.\n\t\ttry {\n\t\t\tsetEventProperty(ev, \"eventPhase\", CAPTURING_PHASE);\n\t\t\tfor (let i = path.length - 1; i >= 0; i--) {\n\t\t\t\tconst target = path[i];\n\t\t\t\tconst listeners = target[_listeners];\n\t\t\t\tsetEventProperty(ev, \"currentTarget\", target);\n\t\t\t\tfor (let i = 0; i < listeners.length; i++) {\n\t\t\t\t\tconst record = listeners[i];\n\t\t\t\t\tif (record.type === ev.type && record.options.capture) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\trecord.callback.call(target, ev);\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\tconsole.error(err);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (immediateCancelBubble) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (cancelBubble) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t{\n\t\t\t\tsetEventProperty(ev, \"eventPhase\", AT_TARGET);\n\t\t\t\tsetEventProperty(ev, \"currentTarget\", this);\n\n\t\t\t\tthis[_dispatchEventOnSelf](ev);\n\t\t\t\tif (immediateCancelBubble) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tconst listeners = this[_listeners];\n\t\t\t\tfor (let i = 0; i < listeners.length; i++) {\n\t\t\t\t\tconst record = listeners[i];\n\t\t\t\t\tif (record.type === ev.type) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\trecord.callback.call(this, ev);\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\tconsole.error(err);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (immediateCancelBubble) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (cancelBubble) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ev.bubbles) {\n\t\t\t\tsetEventProperty(ev, \"eventPhase\", BUBBLING_PHASE);\n\t\t\t\tfor (let i = 0; i < path.length; i++) {\n\t\t\t\t\tconst target = path[i];\n\t\t\t\t\tsetEventProperty(ev, \"currentTarget\", target);\n\t\t\t\t\tconst listeners = target[_listeners];\n\t\t\t\t\tfor (let i = 0; i < listeners.length; i++) {\n\t\t\t\t\t\tconst record = listeners[i];\n\t\t\t\t\t\tif (record.type === ev.type && !record.options.capture) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\trecord.callback.call(target, ev);\n\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\tconsole.error(err);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (immediateCancelBubble) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (cancelBubble) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tsetEventProperty(ev, \"eventPhase\", NONE);\n\t\t\tsetEventProperty(ev, \"currentTarget\", null);\n\t\t\t// eslint-disable-next-line no-unsafe-finally\n\t\t\treturn !ev.defaultPrevented;\n\t\t}\n\t}\n\n\t[_dispatchEventOnSelf](_ev: Event): void {}\n}\n\nCustomEventTarget.dispatchEventOnSelf = _dispatchEventOnSelf;\n\nexport function addEventTargetDelegates<T extends CustomEventTarget>(\n\ttarget: T,\n\tdelegates: Array<unknown>,\n\tinclude: (target1: T) => boolean = (target1) => target === target1,\n): void {\n\tconst delegates1 = delegates.filter(isEventTarget);\n\tfor (\n\t\tlet target1: T | null = target;\n\t\ttarget1 && include(target1);\n\t\ttarget1 = target1[_parent]\n\t) {\n\t\tfor (let i = 0; i < delegates1.length; i++) {\n\t\t\tconst delegate = delegates1[i];\n\t\t\tif (target1[_delegates].has(delegate)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttarget1[_delegates].add(delegate);\n\t\t\tfor (const record of target1[_listeners]) {\n\t\t\t\tdelegate.addEventListener(record.type, record.callback, record.options);\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport function removeEventTargetDelegates<T extends CustomEventTarget>(\n\ttarget: T,\n\tdelegates: Array<unknown>,\n\tinclude: (target1: T) => boolean = (target1) => target === target1,\n): void {\n\tconst delegates1 = delegates.filter(isEventTarget);\n\tfor (\n\t\tlet target1: T | null = target;\n\t\ttarget1 && include(target1);\n\t\ttarget1 = target1[_parent]\n\t) {\n\t\tfor (let i = 0; i < delegates1.length; i++) {\n\t\t\tconst delegate = delegates1[i];\n\t\t\tif (!target1[_delegates].has(delegate)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttarget1[_delegates].delete(delegate);\n\t\t\tfor (const record of target1[_listeners]) {\n\t\t\t\tdelegate.removeEventListener(\n\t\t\t\t\trecord.type,\n\t\t\t\t\trecord.callback,\n\t\t\t\t\trecord.options,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport function clearEventListeners(target: CustomEventTarget): void {\n\tconst listeners = target[_listeners];\n\tconst delegates = target[_delegates];\n\tfor (let i = 0; i < listeners.length; i++) {\n\t\tconst record = listeners[i];\n\t\tfor (const delegate of delegates) {\n\t\t\tdelegate.removeEventListener(\n\t\t\t\trecord.type,\n\t\t\t\trecord.callback,\n\t\t\t\trecord.options,\n\t\t\t);\n\t\t}\n\t}\n\n\tlisteners.length = 0;\n\tdelegates.clear();\n}\n", "function wrap(value) {\n    return value === undefined ? [] : Array.isArray(value) ? value : [value];\n}\nfunction unwrap(arr) {\n    return arr.length === 0 ? undefined : arr.length === 1 ? arr[0] : arr;\n}\n/**\n * Ensures a value is an array.\n *\n * This function does the same thing as wrap() above except it handles nulls\n * and iterables, so it is appropriate for wrapping user-provided element\n * children.\n */\nfunction arrayify(value) {\n    return value == null\n        ? []\n        : Array.isArray(value)\n            ? value\n            : typeof value === \"string\" ||\n                typeof value[Symbol.iterator] !== \"function\"\n                ? [value]\n                : [...value];\n}\nfunction isIteratorLike(value) {\n    return value != null && typeof value.next === \"function\";\n}\nfunction isPromiseLike(value) {\n    return value != null && typeof value.then === \"function\";\n}\nfunction createRaceRecord(contender) {\n    const deferreds = new Set();\n    const record = { deferreds, settled: false };\n    // This call to `then` happens once for the lifetime of the value.\n    Promise.resolve(contender).then((value) => {\n        for (const { resolve } of deferreds) {\n            resolve(value);\n        }\n        deferreds.clear();\n        record.settled = true;\n    }, (err) => {\n        for (const { reject } of deferreds) {\n            reject(err);\n        }\n        deferreds.clear();\n        record.settled = true;\n    });\n    return record;\n}\n// Promise.race is memory unsafe. This is alternative which is. See:\n// https://github.com/nodejs/node/issues/17469#issuecomment-685235106\n// Keys are the values passed to race.\n// Values are a record of data containing a set of deferreds and whether the\n// value has settled.\nconst wm = new WeakMap();\nfunction safeRace(contenders) {\n    let deferred;\n    const result = new Promise((resolve, reject) => {\n        deferred = { resolve, reject };\n        for (const contender of contenders) {\n            if (!isPromiseLike(contender)) {\n                // If the contender is a not a then-able, attempting to use it as a key\n                // in the weakmap would throw an error. Luckily, it is safe to call\n                // `Promise.resolve(contender).then` on regular values multiple\n                // times because the promise fulfills immediately.\n                Promise.resolve(contender).then(resolve, reject);\n                continue;\n            }\n            let record = wm.get(contender);\n            if (record === undefined) {\n                record = createRaceRecord(contender);\n                record.deferreds.add(deferred);\n                wm.set(contender, record);\n            }\n            else if (record.settled) {\n                // If the value has settled, it is safe to call\n                // `Promise.resolve(contender).then` on it.\n                Promise.resolve(contender).then(resolve, reject);\n            }\n            else {\n                record.deferreds.add(deferred);\n            }\n        }\n    });\n    // The finally callback executes when any value settles, preventing any of\n    // the unresolved values from retaining a reference to the resolved value.\n    return result.finally(() => {\n        for (const contender of contenders) {\n            if (isPromiseLike(contender)) {\n                const record = wm.get(contender);\n                if (record) {\n                    record.deferreds.delete(deferred);\n                }\n            }\n        }\n    });\n}\n\nexport { arrayify, isIteratorLike, isPromiseLike, safeRace, unwrap, wrap };\n//# sourceMappingURL=_utils.js.map\n", "import {\n\tCustomEventTarget,\n\taddEventTargetDelegates,\n\tclearEventListeners,\n\tremoveEventTargetDelegates,\n} from \"./event-target.js\";\nimport {\n\tarrayify,\n\tisIteratorLike,\n\tisPromiseLike,\n\tsafeRace,\n\tunwrap,\n\twrap,\n} from \"./_utils.js\";\n\nconst NOOP = (): undefined => {};\n\n/**\n * A type which represents all valid values for an element tag.\n */\nexport type Tag = string | symbol | Component;\n\nfunction getTagName(tag: Tag): string {\n\treturn typeof tag === \"function\"\n\t\t? tag.name || \"Anonymous\"\n\t\t: typeof tag === \"string\"\n\t\t\t? tag\n\t\t\t: // tag is symbol, using else branch to avoid typeof tag === \"symbol\"\n\t\t\t\ttag.description || \"Anonymous\";\n}\n\n/**\n * A helper type to map the tag of an element to its expected props.\n *\n * @template TTag - The tag associated with the props. Can be a string, symbol\n * or a component function.\n */\nexport type TagProps<TTag extends Tag> = TTag extends string\n\t? JSX.IntrinsicElements[TTag]\n\t: TTag extends Component<infer TProps>\n\t\t? TProps & JSX.IntrinsicAttributes\n\t\t: Record<string, unknown> & JSX.IntrinsicAttributes;\n\n/**\n * Describes all valid values of an element tree, excluding iterables.\n *\n * Arbitrary objects can also be safely rendered, but will be converted to a\n * string using the toString() method. We exclude them from this type to catch\n * potential mistakes.\n */\nexport type Child = Element | string | number | boolean | null | undefined;\n\n/**\n * An arbitrarily nested iterable of Child values.\n *\n * We use a recursive interface here rather than making the Children type\n * directly recursive because recursive type aliases were added in TypeScript\n * 3.7.\n *\n * You should avoid referencing this type directly, as it is mainly exported to\n * prevent TypeScript errors.\n */\nexport interface ChildIterable extends Iterable<Child | ChildIterable> {}\n\n/**\n * Describes all valid values for an element tree, including arbitrarily nested\n * iterables of such values.\n *\n * This type can be used to represent the type of the children prop for an\n * element or the return/yield type of a component.\n */\nexport type Children = Child | ChildIterable;\n\n/**\n * Represents all functions which can be used as a component.\n *\n * @template [TProps=*] - The expected props for the component.\n */\nexport type Component<TProps extends Record<string, unknown> = any> = (\n\tthis: Context<TProps>,\n\tprops: TProps,\n\tctx: Context<TProps>,\n) =>\n\t| Children\n\t| PromiseLike<Children>\n\t// The return type of iterators must include void because TypeScript will\n\t// infer generators which return implicitly as having a void return type.\n\t| Iterator<Children, Children | void, any>\n\t| AsyncIterator<Children, Children | void, any>;\n\n/*** SPECIAL TAGS ***/\n/**\n * A special tag for grouping multiple children within the same parent.\n *\n * All non-string iterables which appear in the element tree are implicitly\n * wrapped in a fragment element.\n *\n * This tag is just the empty string, and you can use the empty string in\n * createElement calls or transpiler options directly to avoid having to\n * reference this export.\n */\nexport const Fragment = \"\";\nexport type Fragment = typeof Fragment;\n\n// TODO: We assert the following symbol tags as Components because TypeScript\n// support for symbol tags in JSX doesn't exist yet.\n// https://github.com/microsoft/TypeScript/issues/38367\n\n/**\n * A special tag for rendering into a new root node via a root prop.\n *\n * This tag is useful for creating element trees with multiple roots, for\n * things like modals or tooltips.\n *\n * Renderer.prototype.render() implicitly wraps top-level in a Portal element\n * with the root set to the second argument passed in.\n */\nexport const Portal = Symbol.for(\"crank.Portal\") as unknown as Component<{\n\troot?: object;\n}> &\n\tsymbol;\nexport type Portal = typeof Portal;\n\n/**\n * A special tag which preserves whatever was previously rendered in the\n * element's position.\n *\n * Copy elements are useful for when you want to prevent a subtree from\n * rerendering as a performance optimization. Copy elements can also be keyed,\n * in which case the previously rendered keyed element will be copied.\n */\nexport const Copy = Symbol.for(\"crank.Copy\") as unknown as Component<{}> &\n\tsymbol;\nexport type Copy = typeof Copy;\n\n/**\n * A special tag for rendering text nodes.\n *\n * Strings in the element tree are implicitly wrapped in a Text element with\n * value set to the string.\n */\nexport const Text = Symbol.for(\"crank.Text\") as unknown as Component<{\n\tvalue: string;\n}> &\n\tsymbol;\nexport type Text = typeof Text;\n\n/** A special tag for injecting raw nodes or strings via a value prop. */\nexport const Raw = Symbol.for(\"crank.Raw\") as unknown as Component<{\n\tvalue: string | object;\n}> &\n\tsymbol;\nexport type Raw = typeof Raw;\n\n/**\n * A type to keep track of keys. Any value can be a key, though null and\n * undefined are ignored.\n */\ntype Key = unknown;\n\ntype ChildrenIteratorResult = IteratorResult<Children, Children | void>;\n\nconst ElementSymbol = Symbol.for(\"crank.Element\");\n\n// To maximize compatibility between Crank versions, starting with 0.2.0, any\n// changes to the Element properties will be considered a breaking change.\nexport interface Element<TTag extends Tag = Tag> {\n\t/**\n\t * @internal\n\t * A unique symbol to identify elements as elements across versions and\n\t * realms, and to protect against basic injection attacks.\n\t * https://overreacted.io/why-do-react-elements-have-typeof-property/\n\t *\n\t * This property is defined on the element prototype rather than per\n\t * instance, because it is the same for every Element.\n\t */\n\t$$typeof: typeof ElementSymbol;\n\n\t/**\n\t * The tag of the element. Can be a string, symbol or function.\n\t */\n\ttag: TTag;\n\n\t/**\n\t * An object containing the \"properties\" of an element. These correspond to\n\t * the attribute syntax from JSX.\n\t */\n\tprops: TagProps<TTag>;\n}\n\n/**\n * Elements are the basic building blocks of Crank applications. They are\n * JavaScript objects which are interpreted by special classes called renderers\n * to produce and manage stateful nodes.\n *\n * @template {Tag} [TTag=Tag] - The type of the tag of the element.\n *\n * @example\n * // specific element types\n * let div: Element<\"div\">;\n * let portal: Element<Portal>;\n * let myEl: Element<MyComponent>;\n *\n * // general element types\n * let host: Element<string | symbol>;\n * let component: Element<Component>;\n *\n * Typically, you use a helper function like createElement to create elements\n * rather than instatiating this class directly.\n */\nexport class Element<TTag extends Tag = Tag> {\n\tconstructor(tag: TTag, props: TagProps<TTag>) {\n\t\tthis.tag = tag;\n\t\tthis.props = props;\n\t}\n}\n\n// See Element interface\nElement.prototype.$$typeof = ElementSymbol;\n\nexport function isElement(value: any): value is Element {\n\treturn value != null && value.$$typeof === ElementSymbol;\n}\n\nconst DEPRECATED_PROP_PREFIXES = [\"crank-\", \"c-\", \"$\"];\n\nconst DEPRECATED_SPECIAL_PROP_BASES = [\"key\", \"ref\", \"static\", \"copy\"];\n/**\n * Creates an element with the specified tag, props and children.\n *\n * This function is usually used as a transpilation target for JSX transpilers,\n * but it can also be called directly. It additionally extracts special props so\n * they aren't accessible to renderer methods or components, and assigns the\n * children prop according to any additional arguments passed to the function.\n */\nexport function createElement<TTag extends Tag>(\n\ttag: TTag,\n\tprops?: TagProps<TTag> | null | undefined,\n\t...children: Array<unknown>\n): Element<TTag> {\n\tif (props == null) {\n\t\tprops = {} as TagProps<TTag>;\n\t}\n\n\tif (\"static\" in (props as TagProps<TTag>)) {\n\t\tconsole.error(`The \\`static\\` prop is deprecated. Use \\`copy\\` instead.`);\n\t\t(props as TagProps<TTag>)[\"copy\"] = (props as TagProps<TTag>)[\"static\"];\n\t\tdelete (props as any)[\"static\"];\n\t}\n\n\tfor (let i = 0; i < DEPRECATED_PROP_PREFIXES.length; i++) {\n\t\tconst propPrefix = DEPRECATED_PROP_PREFIXES[i];\n\t\tfor (let j = 0; j < DEPRECATED_SPECIAL_PROP_BASES.length; j++) {\n\t\t\tconst propBase = DEPRECATED_SPECIAL_PROP_BASES[j];\n\t\t\tconst deprecatedPropName = propPrefix + propBase;\n\t\t\tif (deprecatedPropName in (props as TagProps<TTag>)) {\n\t\t\t\tconst targetPropBase = propBase === \"static\" ? \"copy\" : propBase;\n\t\t\t\tconsole.error(\n\t\t\t\t\t`The \\`${deprecatedPropName}\\` prop is deprecated. Use \\`${targetPropBase}\\` instead.`,\n\t\t\t\t);\n\t\t\t\t(props as TagProps<TTag>)[targetPropBase] = (props as TagProps<TTag>)[\n\t\t\t\t\tdeprecatedPropName\n\t\t\t\t];\n\t\t\t\tdelete (props as any)[deprecatedPropName];\n\t\t\t}\n\t\t}\n\t}\n\n\tif (children.length > 1) {\n\t\t(props as TagProps<TTag>).children = children;\n\t} else if (children.length === 1) {\n\t\t(props as TagProps<TTag>).children = children[0];\n\t}\n\n\treturn new Element(tag, props as TagProps<TTag>);\n}\n\n/** Clones a given element, shallowly copying the props object. */\nexport function cloneElement<TTag extends Tag>(\n\tel: Element<TTag>,\n): Element<TTag> {\n\tif (!isElement(el)) {\n\t\tthrow new TypeError(`Cannot clone non-element: ${String(el)}`);\n\t}\n\n\treturn new Element(el.tag, {...el.props});\n}\n\n/*** ELEMENT UTILITIES ***/\n\n// WHAT ARE WE DOING TO THE CHILDREN???\n/**\n * All values in the element tree are narrowed from the union in Child to\n * NarrowedChild during rendering, to simplify element diffing.\n */\ntype NarrowedChild = Element | string | undefined;\n\nfunction narrow(value: Children): NarrowedChild {\n\tif (typeof value === \"boolean\" || value == null) {\n\t\treturn;\n\t} else if (typeof value === \"string\" || isElement(value)) {\n\t\treturn value;\n\t} else if (typeof (value as any)[Symbol.iterator] === \"function\") {\n\t\treturn createElement(Fragment, null, value);\n\t}\n\n\treturn value.toString();\n}\n\n/**\n * A helper type which repesents all possible rendered values of an element.\n *\n * @template TNode - The type of node produced by the associated renderer.\n *\n * When asking the question, what is the \"value\" of a specific element, the\n * answer varies depending on the tag:\n *\n * For intrinsic elements, the value is the node created for the element, e.g.\n * the DOM node in the case of the DOMRenderer.\n *\n * For portals, the value is undefined, because a Portal element's root and\n * children are opaque to its parent.\n *\n * For component or fragment elements the value can be a node or an array of\n * nodes, depending on how many children they have.\n */\nexport type ElementValue<TNode> = Array<TNode> | TNode | undefined;\n\n/*** RETAINER FLAGS ***/\nconst DidDiff = 1 << 0;\nconst DidCommit = 1 << 1;\nconst IsCopied = 1 << 2;\nconst IsUpdating = 1 << 3;\nconst IsExecuting = 1 << 4;\nconst IsRefreshing = 1 << 5;\nconst IsScheduling = 1 << 6;\nconst IsSchedulingFallback = 1 << 7;\nconst IsUnmounted = 1 << 8;\n// TODO: Is this flag still necessary or can we use IsUnmounted?\nconst IsErrored = 1 << 9;\nconst IsResurrecting = 1 << 10;\n// TODO: Maybe we can get rid of IsSyncGen and IsAsyncGen\nconst IsSyncGen = 1 << 11;\nconst IsAsyncGen = 1 << 12;\nconst IsInForOfLoop = 1 << 13;\nconst IsInForAwaitOfLoop = 1 << 14;\nconst NeedsToYield = 1 << 15;\nconst PropsAvailable = 1 << 16;\nconst IsSchedulingRefresh = 1 << 17;\n\nfunction getFlag(ret: Retainer<unknown>, flag: number): boolean {\n\treturn !!(ret.f & flag);\n}\n\nfunction setFlag(ret: Retainer<unknown>, flag: number, value = true): void {\n\tif (value) {\n\t\tret.f |= flag;\n\t} else {\n\t\tret.f &= ~flag;\n\t}\n}\n\n/**\n * @internal\n * Retainers are objects which act as the internal representation of elements,\n * mirroring the element tree.\n */\nclass Retainer<TNode, TScope = unknown> {\n\t/** A bitmask. See RETAINER FLAGS above. */\n\tdeclare f: number;\n\tdeclare el: Element;\n\tdeclare ctx: ContextState<TNode, TScope, any> | undefined;\n\tdeclare children:\n\t\t| Array<Retainer<TNode, TScope> | undefined>\n\t\t| Retainer<TNode, TScope>\n\t\t| undefined;\n\tdeclare fallback: Retainer<TNode, TScope> | undefined;\n\t// This is only assigned for host, text and raw elements.\n\tdeclare value: ElementValue<TNode> | undefined;\n\tdeclare scope: TScope | undefined;\n\t// This is only assigned for host and raw elements.\n\tdeclare oldProps: Record<string, any> | undefined;\n\tdeclare pendingDiff: Promise<undefined> | undefined;\n\tdeclare onNextDiff: Function | undefined;\n\tdeclare graveyard: Array<Retainer<TNode, TScope>> | undefined;\n\tdeclare lingerers:\n\t\t| Array<Set<Retainer<TNode, TScope>> | undefined>\n\t\t| undefined;\n\n\tconstructor(el: Element) {\n\t\tthis.f = 0;\n\t\tthis.el = el;\n\t\tthis.ctx = undefined;\n\t\tthis.children = undefined;\n\t\tthis.fallback = undefined;\n\t\tthis.value = undefined;\n\t\tthis.oldProps = undefined;\n\t\tthis.pendingDiff = undefined;\n\t\tthis.onNextDiff = undefined;\n\t\tthis.graveyard = undefined;\n\t\tthis.lingerers = undefined;\n\t}\n}\n\nfunction cloneRetainer<TNode, TScope>(\n\tret: Retainer<TNode, TScope>,\n): Retainer<TNode, TScope> {\n\tconst clone = new Retainer<TNode, TScope>(ret.el);\n\tclone.f = ret.f;\n\tclone.ctx = ret.ctx;\n\tclone.children = ret.children;\n\tclone.fallback = ret.fallback;\n\tclone.value = ret.value;\n\tclone.scope = ret.scope;\n\tclone.oldProps = ret.oldProps;\n\tclone.pendingDiff = ret.pendingDiff;\n\tclone.onNextDiff = ret.onNextDiff;\n\tclone.graveyard = ret.graveyard;\n\tclone.lingerers = ret.lingerers;\n\n\treturn clone;\n}\n\n/**\n * Finds the value of the element according to its type.\n *\n * @returns A node, an array of nodes or undefined.\n */\nfunction getValue<TNode>(\n\tret: Retainer<TNode>,\n\tisNested = false,\n\tindex?: number,\n): ElementValue<TNode> {\n\tif (getFlag(ret, IsScheduling) && isNested) {\n\t\treturn ret.fallback ? getValue(ret.fallback, isNested, index) : undefined;\n\t} else if (ret.fallback && !getFlag(ret, DidDiff)) {\n\t\treturn ret.fallback\n\t\t\t? getValue(ret.fallback, isNested, index)\n\t\t\t: ret.fallback;\n\t} else if (ret.el.tag === Portal) {\n\t\treturn;\n\t} else if (ret.el.tag === Fragment || typeof ret.el.tag === \"function\") {\n\t\tif (index != null && ret.ctx) {\n\t\t\tret.ctx.index = index;\n\t\t}\n\t\treturn unwrap(getChildValues(ret, index));\n\t}\n\n\treturn ret.value;\n}\n\n/**\n * Walks an element's children to find its child values.\n *\n * @param ret - The retainer whose child values we are reading.\n * @param startIndex - Starting index to thread through for context index updates.\n *\n * @returns An array of nodes.\n */\nfunction getChildValues<TNode>(\n\tret: Retainer<TNode>,\n\tstartIndex?: number,\n): Array<TNode> {\n\tconst values: Array<TNode> = [];\n\tconst lingerers = ret.lingerers;\n\tconst children = wrap(ret.children);\n\tlet currentIndex = startIndex;\n\n\tfor (let i = 0; i < children.length; i++) {\n\t\tif (lingerers != null && lingerers[i] != null) {\n\t\t\tconst rets = lingerers[i]!;\n\t\t\tfor (const ret of rets) {\n\t\t\t\tconst value = getValue(ret, true, currentIndex);\n\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\tfor (let j = 0; j < value.length; j++) {\n\t\t\t\t\t\tvalues.push(value[j]);\n\t\t\t\t\t}\n\t\t\t\t\tif (currentIndex != null) {\n\t\t\t\t\t\tcurrentIndex += value.length;\n\t\t\t\t\t}\n\t\t\t\t} else if (value) {\n\t\t\t\t\tvalues.push(value);\n\t\t\t\t\tif (currentIndex != null) {\n\t\t\t\t\t\tcurrentIndex++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst child = children[i];\n\t\tif (child) {\n\t\t\tconst value = getValue(child, true, currentIndex);\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\tfor (let j = 0; j < value.length; j++) {\n\t\t\t\t\tvalues.push(value[j]);\n\t\t\t\t}\n\t\t\t\tif (currentIndex != null) {\n\t\t\t\t\tcurrentIndex += value.length;\n\t\t\t\t}\n\t\t\t} else if (value) {\n\t\t\t\tvalues.push(value);\n\t\t\t\tif (currentIndex != null) {\n\t\t\t\t\tcurrentIndex++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (lingerers != null && lingerers.length > children.length) {\n\t\tfor (let i = children.length; i < lingerers.length; i++) {\n\t\t\tconst rets = lingerers[i];\n\t\t\tif (rets != null) {\n\t\t\t\tfor (const ret of rets) {\n\t\t\t\t\tconst value = getValue(ret, true, currentIndex);\n\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\tfor (let j = 0; j < value.length; j++) {\n\t\t\t\t\t\t\tvalues.push(value[j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (currentIndex != null) {\n\t\t\t\t\t\t\tcurrentIndex += value.length;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (value) {\n\t\t\t\t\t\tvalues.push(value);\n\t\t\t\t\t\tif (currentIndex != null) {\n\t\t\t\t\t\t\tcurrentIndex++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn values;\n}\n\nfunction stripSpecialProps(props: Record<string, any>): Record<string, any> {\n\tlet _: unknown;\n\tlet result: Record<string, any>;\n\t({key: _, ref: _, copy: _, hydrate: _, children: _, ...result} = props);\n\treturn result;\n}\n\n/**\n * Interface for adapting the rendering process to a specific target environment.\n *\n * The RenderAdapter defines how Crank elements are mapped to nodes in your target\n * rendering environment (DOM, Canvas, WebGL, Terminal, etc.). Each method handles\n * a specific part of the element lifecycle, from creation to removal.\n *\n * @template TNode - The type representing a node in your target environment\n * @template TScope - Additional context data passed down the component tree\n * @template TRoot - The type of the root container (defaults to TNode)\n * @template TResult - The type returned when reading element values (defaults to ElementValue<TNode>)\n *\n * @example\n * ```typescript\n * const adapter: RenderAdapter<MyNode, MyScope> = {\n *   create: ({ tag, props }) => new MyNode(tag, props),\n *   patch: ({ node, props }) => node.update(props),\n *   arrange: ({ node, children }) => node.replaceChildren(children),\n *   // ... other methods\n * };\n * ```\n */\nexport interface RenderAdapter<\n\tTNode,\n\tTScope,\n\tTRoot extends TNode | undefined = TNode,\n\tTResult = ElementValue<TNode>,\n> {\n\t/**\n\t * Creates a new node for the given element tag and props.\n\t *\n\t * This method is called when Crank encounters a new element that needs to be\n\t * rendered for the first time. You should create and return a node appropriate\n\t * for your target environment.\n\t *\n\t * @param data.tag - The element tag (e.g., \"div\", \"sprite\", or a symbol)\n\t * @param data.tagName - String representation of the tag for debugging\n\t * @param data.props - The element's props object\n\t * @param data.scope - Current scope context (can be undefined)\n\t * @returns A new node instance\n\t *\n\t * @example\n\t * ```typescript\n\t * create: ({ tag, props, scope }) => {\n\t *   if (tag === \"sprite\") {\n\t *     return new PIXI.Sprite(props.texture);\n\t *   }\n\t *   throw new Error(`Unknown tag: ${tag}`);\n\t * }\n\t * ```\n\t */\n\tcreate(data: {\n\t\ttag: string | symbol;\n\t\ttagName: string;\n\t\tprops: Record<string, any>;\n\t\tscope: TScope | undefined;\n\t}): TNode;\n\n\t/**\n\t * Adopts existing nodes during hydration.\n\t *\n\t * Called when hydrating server-rendered content or reusing existing nodes.\n\t * Should return an array of child nodes if the provided node matches the\n\t * expected tag, or undefined if hydration should fail.\n\t *\n\t * @param data.tag - The element tag being hydrated\n\t * @param data.tagName - String representation of the tag\n\t * @param data.props - The element's props\n\t * @param data.node - The existing node to potentially adopt\n\t * @param data.scope - Current scope context\n\t * @returns Array of child nodes to hydrate, or undefined if adoption fails\n\t *\n\t * @example\n\t * ```typescript\n\t * adopt: ({ tag, node }) => {\n\t *   if (node && node.tagName.toLowerCase() === tag) {\n\t *     return Array.from(node.children);\n\t *   }\n\t *   return undefined; // Hydration mismatch\n\t * }\n\t * ```\n\t */\n\tadopt(data: {\n\t\ttag: string | symbol;\n\t\ttagName: string;\n\t\tprops: Record<string, any>;\n\t\tnode: TNode | undefined;\n\t\tscope: TScope | undefined;\n\t}): Array<TNode> | undefined;\n\n\t/**\n\t * Creates or updates a text node.\n\t *\n\t * Called when rendering text content. Should create a new text node or\n\t * update an existing one with the provided value.\n\t *\n\t * @param data.value - The text content to render\n\t * @param data.scope - Current scope context\n\t * @param data.oldNode - Previous text node to potentially reuse\n\t * @param data.hydrationNodes - Nodes available during hydration\n\t * @returns A text node containing the given value\n\t *\n\t * @example\n\t * ```typescript\n\t * text: ({ value, oldNode }) => {\n\t *   if (oldNode && oldNode.text !== value) {\n\t *     oldNode.text = value;\n\t *     return oldNode;\n\t *   }\n\t *   return new TextNode(value);\n\t * }\n\t * ```\n\t */\n\ttext(data: {\n\t\tvalue: string;\n\t\tscope: TScope | undefined;\n\t\toldNode: TNode | undefined;\n\t\thydrationNodes: Array<TNode> | undefined;\n\t}): TNode;\n\n\t/**\n\t * Computes scope context for child elements.\n\t *\n\t * Called to determine what scope context should be passed to child elements.\n\t * The scope can be used to pass rendering context like theme, coordinate systems,\n\t * or namespaces down the component tree.\n\t *\n\t * @param data.tag - The element tag\n\t * @param data.tagName - String representation of the tag\n\t * @param data.props - The element's props\n\t * @param data.scope - Current scope context\n\t * @returns New scope for children, or undefined to inherit current scope\n\t *\n\t * @example\n\t * ```typescript\n\t * scope: ({ tag, props, scope }) => {\n\t *   if (tag === \"svg\") {\n\t *     return { ...scope, namespace: \"http://www.w3.org/2000/svg\" };\n\t *   }\n\t *   return scope;\n\t * }\n\t * ```\n\t */\n\tscope(data: {\n\t\ttag: string | symbol;\n\t\ttagName: string;\n\t\tprops: Record<string, any>;\n\t\tscope: TScope | undefined;\n\t}): TScope | undefined;\n\n\t/**\n\t * Handles raw values (strings or nodes) that bypass normal element processing.\n\t *\n\t * Called when rendering Raw elements or other direct node insertions.\n\t * Should convert string values to appropriate nodes for your environment.\n\t *\n\t * @param data.value - Raw string or node value to render\n\t * @param data.scope - Current scope context\n\t * @param data.hydrationNodes - Nodes available during hydration\n\t * @returns ElementValue that can be handled by arrange()\n\t *\n\t * @example\n\t * ```typescript\n\t * raw: ({ value, scope }) => {\n\t *   if (typeof value === \"string\") {\n\t *     const container = new Container();\n\t *     container.innerHTML = value;\n\t *     return Array.from(container.children);\n\t *   }\n\t *   return value;\n\t * }\n\t * ```\n\t */\n\traw(data: {\n\t\tvalue: string | TNode;\n\t\tscope: TScope | undefined;\n\t\thydrationNodes: Array<TNode> | undefined;\n\t}): ElementValue<TNode>;\n\n\t/**\n\t * Updates a node's properties.\n\t *\n\t * Called when element props change. Should efficiently update only the\n\t * properties that have changed. This is where you implement prop-to-attribute\n\t * mapping, event listener binding, and other property synchronization.\n\t *\n\t * @param data.tag - The element tag\n\t * @param data.tagName - String representation of the tag\n\t * @param data.node - The node to update\n\t * @param data.props - New props object\n\t * @param data.oldProps - Previous props object (undefined for initial render)\n\t * @param data.scope - Current scope context\n\t * @param data.copyProps - Props to skip (used for copying between renderers)\n\t * @param data.isHydrating - Whether currently hydrating\n\t * @param data.quietProps - Props to not warn about during hydration\n\t *\n\t * @example\n\t * ```typescript\n\t * patch: ({ node, props, oldProps }) => {\n\t *   for (const [key, value] of Object.entries(props)) {\n\t *     if (oldProps?.[key] !== value) {\n\t *       if (key.startsWith(\"on\")) {\n\t *         node.addEventListener(key.slice(2), value);\n\t *       } else {\n\t *         node[key] = value;\n\t *       }\n\t *     }\n\t *   }\n\t * }\n\t * ```\n\t */\n\tpatch(data: {\n\t\ttag: string | symbol;\n\t\ttagName: string;\n\t\tnode: TNode;\n\t\tprops: Record<string, any>;\n\t\toldProps: Record<string, any> | undefined;\n\t\tscope: TScope | undefined;\n\t\tcopyProps: Set<string> | undefined;\n\t\tisHydrating: boolean;\n\t\tquietProps: Set<string> | undefined;\n\t}): void;\n\n\t/**\n\t * Arranges child nodes within their parent.\n\t *\n\t * Called after child elements are rendered to organize them within their\n\t * parent node. Should efficiently insert, move, or remove child nodes to\n\t * match the provided children array.\n\t *\n\t * @param data.tag - The parent element tag\n\t * @param data.tagName - String representation of the tag\n\t * @param data.node - The parent node\n\t * @param data.props - The parent element's props\n\t * @param data.children - Array of child nodes in correct order\n\t * @param data.oldProps - Previous props (for reference)\n\t *\n\t * @example\n\t * ```typescript\n\t * arrange: ({ node, children }) => {\n\t *   // Remove existing children\n\t *   node.removeChildren();\n\t *   // Add new children in order\n\t *   for (const child of children) {\n\t *     node.addChild(child);\n\t *   }\n\t * }\n\t * ```\n\t */\n\tarrange(data: {\n\t\ttag: string | symbol;\n\t\ttagName: string;\n\t\tnode: TNode;\n\t\tprops: Record<string, any>;\n\t\tchildren: Array<TNode>;\n\t\toldProps: Record<string, any> | undefined;\n\t}): void;\n\n\t/**\n\t * Removes a node from its parent.\n\t *\n\t * Called when an element is being unmounted. Should clean up the node\n\t * and remove it from its parent if appropriate.\n\t *\n\t * @param data.node - The node to remove\n\t * @param data.parentNode - The parent node\n\t * @param data.isNested - Whether this is a nested removal (child of removed element)\n\t *\n\t * @example\n\t * ```typescript\n\t * remove: ({ node, parentNode, isNested }) => {\n\t *   // Clean up event listeners, resources, etc.\n\t *   node.cleanup?.();\n\t *   // Remove from parent unless it's a nested removal\n\t *   if (!isNested && parentNode.contains(node)) {\n\t *     parentNode.removeChild(node);\n\t *   }\n\t * }\n\t * ```\n\t */\n\tremove(data: {node: TNode; parentNode: TNode; isNested: boolean}): void;\n\n\t/**\n\t * Reads the final rendered value from an ElementValue.\n\t *\n\t * Called to extract the final result from rendered elements. This allows\n\t * you to transform the internal node representation into the public API\n\t * that users of your renderer will see.\n\t *\n\t * @param value - The ElementValue to read (array, single node, or undefined)\n\t * @returns The public representation of the rendered value\n\t *\n\t * @example\n\t * ```typescript\n\t * read: (value) => {\n\t *   if (Array.isArray(value)) {\n\t *     return value.map(node => node.publicAPI);\n\t *   }\n\t *   return value?.publicAPI;\n\t * }\n\t * ```\n\t */\n\tread(value: ElementValue<TNode>): TResult;\n\n\t/**\n\t * Performs final rendering to the root container.\n\t *\n\t * Called after the entire render cycle is complete. This is where you\n\t * trigger the actual rendering/presentation in your target environment\n\t * (e.g., calling render() on a canvas, flushing to the screen, etc.).\n\t *\n\t * @param root - The root container\n\t *\n\t * @example\n\t * ```typescript\n\t * finalize: (root) => {\n\t *   // Trigger actual rendering\n\t *   if (root instanceof PIXIApplication) {\n\t *     root.render();\n\t *   }\n\t * }\n\t * ```\n\t */\n\tfinalize(root: TRoot): void;\n}\n\nconst defaultAdapter: RenderAdapter<any, any, any, any> = {\n\tcreate() {\n\t\tthrow new Error(\"adapter must implement create\");\n\t},\n\tadopt() {\n\t\tthrow new Error(\"adapter must implement adopt() for hydration\");\n\t},\n\tscope: ({scope}) => scope,\n\tread: (value) => value,\n\ttext: ({value}) => value,\n\traw: ({value}) => value,\n\tpatch: NOOP,\n\tarrange: NOOP,\n\tremove: NOOP,\n\tfinalize: NOOP,\n};\n\n/**\n * An abstract class which is subclassed to render to different target\n * environments. Subclasses call super() with a custom RenderAdapter object.\n * This class is responsible for kicking off the rendering process and caching\n * previous trees by root.\n *\n * @template TNode - The type of the node for a rendering environment.\n * @template TScope - Data which is passed down the tree.\n * @template TRoot - The type of the root for a rendering environment.\n * @template TResult - The type of exposed values.\n */\nexport class Renderer<\n\tTNode extends object,\n\tTScope,\n\tTRoot extends TNode | undefined = TNode,\n\tTResult = ElementValue<TNode>,\n> {\n\t/**\n\t * @internal\n\t * A weakmap which stores element trees by root.\n\t */\n\tdeclare cache: WeakMap<object, Retainer<TNode, TScope>>;\n\tdeclare adapter: RenderAdapter<TNode, TScope, TRoot, TResult>;\n\tconstructor(adapter: Partial<RenderAdapter<TNode, TScope, TRoot, TResult>>) {\n\t\tthis.cache = new WeakMap();\n\t\tthis.adapter = {...defaultAdapter, ...adapter};\n\t}\n\n\t/**\n\t * Renders an element tree into a specific root.\n\t *\n\t * @param children - An element tree. Rendering null deletes cached renders.\n\t * @param root - The root to be rendered into. The renderer caches renders\n\t * per root.\n\t * @param bridge - An optional context that will be the ancestor context of\n\t * all elements in the tree. Useful for connecting different renderers so\n\t * that events/provisions/errors properly propagate. The context for a given\n\t * root must be the same between renders.\n\t *\n\t * @returns The result of rendering the children, or a possible promise of\n\t * the result if the element tree renders asynchronously.\n\t */\n\trender(\n\t\tchildren: Children,\n\t\troot?: TRoot | undefined,\n\t\tbridge?: Context | undefined,\n\t): Promise<TResult> | TResult {\n\t\tconst ret = getRootRetainer(this, bridge, {children, root});\n\t\treturn renderRoot(this.adapter, root, ret, children) as\n\t\t\t| Promise<TResult>\n\t\t\t| TResult;\n\t}\n\n\thydrate(\n\t\tchildren: Children,\n\t\troot: TRoot,\n\t\tbridge?: Context | undefined,\n\t): Promise<TResult> | TResult {\n\t\tconst ret = getRootRetainer(this, bridge, {\n\t\t\tchildren,\n\t\t\troot,\n\t\t\thydrate: true,\n\t\t});\n\t\treturn renderRoot(this.adapter, root, ret, children) as\n\t\t\t| Promise<TResult>\n\t\t\t| TResult;\n\t}\n}\n\n/*** PRIVATE RENDERER FUNCTIONS ***/\nfunction getRootRetainer<\n\tTNode extends object,\n\tTScope,\n\tTRoot extends TNode | undefined,\n>(\n\trenderer: Renderer<TNode, TScope, TRoot, unknown>,\n\tbridge: Context | undefined,\n\t{\n\t\tchildren,\n\t\troot,\n\t\thydrate,\n\t}: {\n\t\tchildren: Children;\n\t\troot: TRoot | undefined;\n\t\thydrate?: boolean;\n\t},\n): Retainer<TNode, TScope> {\n\tlet ret: Retainer<TNode, TScope> | undefined;\n\tconst bridgeCtx = bridge && bridge[_ContextState];\n\tif (typeof root === \"object\" && root !== null) {\n\t\tret = renderer.cache.get(root);\n\t}\n\n\tconst adapter = renderer.adapter;\n\tif (ret === undefined) {\n\t\tret = new Retainer(createElement(Portal, {children, root, hydrate}));\n\t\tret.value = root;\n\t\tret.ctx = bridgeCtx as ContextState<any, any> | undefined;\n\t\tret.scope = adapter.scope({\n\t\t\ttag: Portal,\n\t\t\ttagName: getTagName(Portal),\n\t\t\tprops: stripSpecialProps(ret.el.props),\n\t\t\tscope: undefined,\n\t\t});\n\t\t// remember that typeof null === \"object\"\n\t\tif (typeof root === \"object\" && root !== null && children != null) {\n\t\t\trenderer.cache.set(root, ret);\n\t\t}\n\t} else if (ret.ctx !== bridgeCtx) {\n\t\tthrow new Error(\n\t\t\t\"A previous call to render() was passed a different context\",\n\t\t);\n\t} else {\n\t\tret.el = createElement(Portal, {children, root, hydrate});\n\t\tif (typeof root === \"object\" && root !== null && children == null) {\n\t\t\trenderer.cache.delete(root);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nfunction renderRoot<TNode, TScope, TRoot extends TNode | undefined, TResult>(\n\tadapter: RenderAdapter<TNode, TScope, TRoot, TResult>,\n\troot: TRoot | undefined,\n\tret: Retainer<TNode, TScope>,\n\tchildren: Children,\n): Promise<TResult> | TResult {\n\tconst diff = diffChildren(\n\t\tadapter,\n\t\troot,\n\t\tret,\n\t\tret.ctx,\n\t\tret.scope,\n\t\tret,\n\t\tchildren,\n\t);\n\n\tconst schedulePromises: Array<PromiseLike<unknown>> = [];\n\tif (isPromiseLike(diff)) {\n\t\treturn diff.then(() => {\n\t\t\tcommit(\n\t\t\t\tadapter,\n\t\t\t\tret,\n\t\t\t\tret,\n\t\t\t\tret.ctx,\n\t\t\t\tret.scope,\n\t\t\t\t0,\n\t\t\t\tschedulePromises,\n\t\t\t\tundefined,\n\t\t\t);\n\t\t\tif (schedulePromises.length > 0) {\n\t\t\t\treturn Promise.all(schedulePromises).then(() => {\n\t\t\t\t\tif (typeof root !== \"object\" || root === null) {\n\t\t\t\t\t\tunmount(adapter, ret, ret.ctx, ret, false);\n\t\t\t\t\t}\n\t\t\t\t\treturn adapter.read(unwrap(getChildValues(ret)));\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (typeof root !== \"object\" || root === null) {\n\t\t\t\tunmount(adapter, ret, ret.ctx, ret, false);\n\t\t\t}\n\t\t\treturn adapter.read(unwrap(getChildValues(ret)));\n\t\t});\n\t}\n\n\tcommit(adapter, ret, ret, ret.ctx, ret.scope, 0, schedulePromises, undefined);\n\tif (schedulePromises.length > 0) {\n\t\treturn Promise.all(schedulePromises).then(() => {\n\t\t\tif (typeof root !== \"object\" || root === null) {\n\t\t\t\tunmount(adapter, ret, ret.ctx, ret, false);\n\t\t\t}\n\t\t\treturn adapter.read(unwrap(getChildValues(ret)));\n\t\t});\n\t}\n\n\tif (typeof root !== \"object\" || root === null) {\n\t\tunmount(adapter, ret, ret.ctx, ret, false);\n\t}\n\treturn adapter.read(unwrap(getChildValues(ret)));\n}\n\nfunction diffChildren<TNode, TScope, TRoot extends TNode | undefined, TResult>(\n\tadapter: RenderAdapter<TNode, TScope, TRoot, TResult>,\n\troot: TRoot | undefined,\n\thost: Retainer<TNode, TScope>,\n\tctx: ContextState<TNode, TScope, TRoot, TResult> | undefined,\n\tscope: TScope | undefined,\n\tparent: Retainer<TNode, TScope>,\n\tnewChildren: Children,\n): Promise<undefined> | undefined {\n\tconst oldRetained = wrap(parent.children);\n\tconst newRetained: typeof oldRetained = [];\n\tconst newChildren1 = arrayify(newChildren);\n\tconst diffs: Array<Promise<undefined> | undefined> = [];\n\tlet childrenByKey: Map<Key, Retainer<TNode, TScope>> | undefined;\n\tlet seenKeys: Set<Key> | undefined;\n\tlet isAsync = false;\n\tlet oi = 0;\n\tlet oldLength = oldRetained.length;\n\tlet graveyard: Array<Retainer<TNode, TScope>> | undefined;\n\tfor (let ni = 0, newLength = newChildren1.length; ni < newLength; ni++) {\n\t\t// length checks to prevent index out of bounds deoptimizations.\n\t\tlet ret = oi >= oldLength ? undefined : oldRetained[oi];\n\t\tlet child = narrow(newChildren1[ni]);\n\t\t{\n\t\t\t// aligning new children with old retainers\n\t\t\tlet oldKey = typeof ret === \"object\" ? ret.el.props.key : undefined;\n\t\t\tlet newKey = typeof child === \"object\" ? child.props.key : undefined;\n\t\t\tif (newKey !== undefined && seenKeys && seenKeys.has(newKey)) {\n\t\t\t\tconsole.error(\n\t\t\t\t\t`Duplicate key found in <${getTagName(parent.el.tag)}>`,\n\t\t\t\t\tnewKey,\n\t\t\t\t);\n\t\t\t\tchild = cloneElement(child as Element);\n\t\t\t\tnewKey = child.props.key = undefined;\n\t\t\t}\n\n\t\t\tif (oldKey === newKey) {\n\t\t\t\tif (childrenByKey !== undefined && newKey !== undefined) {\n\t\t\t\t\tchildrenByKey.delete(newKey);\n\t\t\t\t}\n\n\t\t\t\toi++;\n\t\t\t} else {\n\t\t\t\tchildrenByKey = childrenByKey || createChildrenByKey(oldRetained, oi);\n\t\t\t\tif (newKey === undefined) {\n\t\t\t\t\twhile (ret !== undefined && oldKey !== undefined) {\n\t\t\t\t\t\toi++;\n\t\t\t\t\t\tret = oldRetained[oi];\n\t\t\t\t\t\toldKey = typeof ret === \"object\" ? ret.el.props.key : undefined;\n\t\t\t\t\t}\n\n\t\t\t\t\toi++;\n\t\t\t\t} else {\n\t\t\t\t\tret = childrenByKey.get(newKey);\n\t\t\t\t\tif (ret !== undefined) {\n\t\t\t\t\t\tchildrenByKey.delete(newKey);\n\t\t\t\t\t}\n\n\t\t\t\t\t(seenKeys = seenKeys || new Set()).add(newKey);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet diff: Promise<undefined> | undefined = undefined;\n\t\tif (typeof child === \"object\") {\n\t\t\tlet childCopied = false;\n\t\t\tif (child.tag === Copy) {\n\t\t\t\tchildCopied = true;\n\t\t\t} else if (\n\t\t\t\ttypeof ret === \"object\" &&\n\t\t\t\tret.el === child &&\n\t\t\t\tgetFlag(ret, DidCommit)\n\t\t\t) {\n\t\t\t\t// If the child is the same as the retained element, we skip\n\t\t\t\t// re-rendering.\n\t\t\t\tchildCopied = true;\n\t\t\t} else {\n\t\t\t\tif (ret && ret.el.tag === child.tag) {\n\t\t\t\t\tret.el = child;\n\t\t\t\t\tif (child.props.copy && typeof child.props.copy !== \"string\") {\n\t\t\t\t\t\tchildCopied = true;\n\t\t\t\t\t}\n\t\t\t\t} else if (ret) {\n\t\t\t\t\tlet candidateFound = false;\n\t\t\t\t\t// we do not need to add the retainer to the graveyard if it is the\n\t\t\t\t\t// fallback of another retainer\n\t\t\t\t\t// search for the tag in fallback chain\n\t\t\t\t\tfor (\n\t\t\t\t\t\tlet predecessor = ret, candidate = ret.fallback;\n\t\t\t\t\t\tcandidate;\n\t\t\t\t\t\tpredecessor = candidate, candidate = candidate.fallback\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (candidate.el.tag === child.tag) {\n\t\t\t\t\t\t\t// If we find a retainer in the fallback chain with the same tag,\n\t\t\t\t\t\t\t// we reuse it rather than creating a new retainer to preserve\n\t\t\t\t\t\t\t// state. This behavior is useful for when a Suspense component\n\t\t\t\t\t\t\t// re-renders and the children are re-rendered quickly.\n\t\t\t\t\t\t\tconst clone = cloneRetainer(candidate);\n\t\t\t\t\t\t\tsetFlag(clone, IsResurrecting);\n\t\t\t\t\t\t\tpredecessor.fallback = clone;\n\t\t\t\t\t\t\tconst fallback = ret;\n\t\t\t\t\t\t\tret = candidate;\n\t\t\t\t\t\t\tret.el = child;\n\t\t\t\t\t\t\tret.fallback = fallback;\n\t\t\t\t\t\t\tsetFlag(ret, DidDiff, false);\n\t\t\t\t\t\t\tcandidateFound = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!candidateFound) {\n\t\t\t\t\t\tconst fallback = ret;\n\t\t\t\t\t\tret = new Retainer<TNode, TScope>(child);\n\t\t\t\t\t\tret.fallback = fallback;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tret = new Retainer<TNode, TScope>(child);\n\t\t\t\t}\n\n\t\t\t\tif (childCopied && getFlag(ret, DidCommit)) {\n\t\t\t\t\t// pass\n\t\t\t\t} else if (child.tag === Raw || child.tag === Text) {\n\t\t\t\t\t// pass\n\t\t\t\t} else if (child.tag === Fragment) {\n\t\t\t\t\tdiff = diffChildren(\n\t\t\t\t\t\tadapter,\n\t\t\t\t\t\troot,\n\t\t\t\t\t\thost,\n\t\t\t\t\t\tctx,\n\t\t\t\t\t\tscope,\n\t\t\t\t\t\tret,\n\t\t\t\t\t\tret.el.props.children as Children,\n\t\t\t\t\t);\n\t\t\t\t} else if (typeof child.tag === \"function\") {\n\t\t\t\t\tdiff = diffComponent(adapter, root, host, ctx, scope, ret);\n\t\t\t\t} else {\n\t\t\t\t\tdiff = diffHost(adapter, root, ctx, scope, ret);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (typeof ret === \"object\") {\n\t\t\t\tif (childCopied) {\n\t\t\t\t\tsetFlag(ret, IsCopied);\n\t\t\t\t\tdiff = getInflightDiff(ret);\n\t\t\t\t} else {\n\t\t\t\t\tsetFlag(ret, IsCopied, false);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (isPromiseLike(diff)) {\n\t\t\t\tisAsync = true;\n\t\t\t}\n\t\t} else if (typeof child === \"string\") {\n\t\t\tif (typeof ret === \"object\" && ret.el.tag === Text) {\n\t\t\t\tret.el.props.value = child;\n\t\t\t} else {\n\t\t\t\tif (typeof ret === \"object\") {\n\t\t\t\t\t(graveyard = graveyard || []).push(ret);\n\t\t\t\t}\n\n\t\t\t\tret = new Retainer<TNode, TScope>(createElement(Text, {value: child}));\n\t\t\t}\n\t\t} else {\n\t\t\tif (typeof ret === \"object\") {\n\t\t\t\t(graveyard = graveyard || []).push(ret);\n\t\t\t}\n\n\t\t\tret = undefined;\n\t\t}\n\n\t\tdiffs[ni] = diff;\n\t\tnewRetained[ni] = ret;\n\t}\n\n\t// cleanup remaining retainers\n\tfor (; oi < oldLength; oi++) {\n\t\tconst ret = oldRetained[oi];\n\t\tif (\n\t\t\ttypeof ret === \"object\" &&\n\t\t\t(typeof ret.el.props.key === \"undefined\" ||\n\t\t\t\t!seenKeys ||\n\t\t\t\t!seenKeys.has(ret.el.props.key))\n\t\t) {\n\t\t\t(graveyard = graveyard || []).push(ret);\n\t\t}\n\t}\n\n\tif (childrenByKey !== undefined && childrenByKey.size > 0) {\n\t\tgraveyard = graveyard || [];\n\t\tfor (const ret of childrenByKey.values()) {\n\t\t\tgraveyard.push(ret);\n\t\t}\n\t}\n\n\tparent.children = unwrap(newRetained);\n\tif (isAsync) {\n\t\tconst diffs1 = Promise.all(diffs)\n\t\t\t.then(() => undefined)\n\t\t\t.finally(() => {\n\t\t\t\tsetFlag(parent, DidDiff);\n\t\t\t\tif (graveyard) {\n\t\t\t\t\tif (parent.graveyard) {\n\t\t\t\t\t\tfor (let i = 0; i < graveyard.length; i++) {\n\t\t\t\t\t\t\tparent.graveyard.push(graveyard[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tparent.graveyard = graveyard;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\tlet onNextDiffs!: Function;\n\t\tconst diffs2 = (parent.pendingDiff = safeRace([\n\t\t\tdiffs1,\n\t\t\tnew Promise<any>((resolve) => (onNextDiffs = resolve)),\n\t\t]));\n\n\t\tif (parent.onNextDiff) {\n\t\t\tparent.onNextDiff(diffs2);\n\t\t}\n\n\t\tparent.onNextDiff = onNextDiffs;\n\t\treturn diffs2;\n\t} else {\n\t\tsetFlag(parent, DidDiff);\n\t\tif (graveyard) {\n\t\t\tif (parent.graveyard) {\n\t\t\t\tfor (let i = 0; i < graveyard.length; i++) {\n\t\t\t\t\tparent.graveyard.push(graveyard[i]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tparent.graveyard = graveyard;\n\t\t\t}\n\t\t}\n\n\t\tif (parent.onNextDiff) {\n\t\t\tparent.onNextDiff(diffs);\n\t\t\tparent.onNextDiff = undefined;\n\t\t}\n\n\t\tparent.pendingDiff = undefined;\n\t}\n}\n\nfunction getInflightDiff(\n\tret: Retainer<unknown>,\n): Promise<undefined> | undefined {\n\t// It is not enough to check pendingDiff because pendingDiff is the diff for\n\t// children, but not the diff of an async component retainer's current run.\n\t// For the latter we check ctx.inflight.\n\tif (ret.ctx && ret.ctx.inflight) {\n\t\treturn ret.ctx.inflight[1];\n\t} else if (ret.pendingDiff) {\n\t\treturn ret.pendingDiff;\n\t}\n}\n\nfunction createChildrenByKey<TNode, TScope>(\n\tchildren: Array<Retainer<TNode, TScope> | undefined>,\n\toffset: number,\n): Map<Key, Retainer<TNode, TScope>> {\n\tconst childrenByKey = new Map<Key, Retainer<TNode, TScope>>();\n\tfor (let i = offset; i < children.length; i++) {\n\t\tconst child = children[i];\n\t\tif (\n\t\t\ttypeof child === \"object\" &&\n\t\t\ttypeof child.el.props.key !== \"undefined\"\n\t\t) {\n\t\t\tchildrenByKey.set(child.el.props.key, child);\n\t\t}\n\t}\n\n\treturn childrenByKey;\n}\n\nfunction diffHost<TNode, TScope, TRoot extends TNode | undefined>(\n\tadapter: RenderAdapter<TNode, TScope, TRoot, unknown>,\n\troot: TRoot,\n\tctx: ContextState<TNode, TScope, TRoot> | undefined,\n\tscope: TScope | undefined,\n\tret: Retainer<TNode, TScope>,\n): Promise<undefined> | undefined {\n\tconst el = ret.el;\n\tconst tag = el.tag as string | symbol;\n\tif (el.tag === Portal) {\n\t\troot = ret.value = el.props.root;\n\t}\n\n\tif (getFlag(ret, DidCommit)) {\n\t\tscope = ret.scope;\n\t} else {\n\t\tscope = ret.scope = adapter.scope({\n\t\t\ttag,\n\t\t\ttagName: getTagName(tag),\n\t\t\tprops: el.props,\n\t\t\tscope,\n\t\t});\n\t}\n\n\treturn diffChildren(\n\t\tadapter,\n\t\troot,\n\t\tret,\n\t\tctx,\n\t\tscope,\n\t\tret,\n\t\tret.el.props.children,\n\t);\n}\n\nfunction commit<TNode, TScope, TRoot extends TNode | undefined, TResult>(\n\tadapter: RenderAdapter<TNode, TScope, TRoot, TResult>,\n\thost: Retainer<TNode, TScope>,\n\tret: Retainer<TNode, TScope>,\n\tctx: ContextState<TNode, TScope, TRoot, TResult> | undefined,\n\tscope: TScope | undefined,\n\tindex: number,\n\tschedulePromises: Array<PromiseLike<unknown>>,\n\thydrationNodes: Array<TNode> | undefined,\n): ElementValue<TNode> {\n\tif (getFlag(ret, IsCopied) && getFlag(ret, DidCommit)) {\n\t\treturn getValue(ret);\n\t}\n\n\tconst el = ret.el;\n\tconst tag = el.tag;\n\tif (\n\t\ttypeof tag === \"function\" ||\n\t\ttag === Fragment ||\n\t\ttag === Portal ||\n\t\ttag === Raw ||\n\t\ttag === Text\n\t) {\n\t\tif (typeof el.props.copy === \"string\") {\n\t\t\tconsole.error(\n\t\t\t\t`String copy prop ignored for <${getTagName(tag)}>. Use booleans instead.`,\n\t\t\t);\n\t\t}\n\t\tif (typeof el.props.hydrate === \"string\") {\n\t\t\tconsole.error(\n\t\t\t\t`String hydrate prop ignored for <${getTagName(tag)}>. Use booleans instead.`,\n\t\t\t);\n\t\t}\n\t}\n\n\tlet value: ElementValue<TNode>;\n\tlet skippedHydrationNodes: Array<TNode> | undefined;\n\tif (\n\t\thydrationNodes &&\n\t\tel.props.hydrate != null &&\n\t\t!el.props.hydrate &&\n\t\ttypeof el.props.hydrate !== \"string\"\n\t) {\n\t\tskippedHydrationNodes = hydrationNodes;\n\t\thydrationNodes = undefined;\n\t}\n\n\tif (typeof tag === \"function\") {\n\t\tret.ctx!.index = index;\n\t\tvalue = commitComponent(ret.ctx!, schedulePromises, hydrationNodes);\n\t} else {\n\t\tif (tag === Fragment) {\n\t\t\tvalue = commitChildren(\n\t\t\t\tadapter,\n\t\t\t\thost,\n\t\t\t\tctx,\n\t\t\t\tscope,\n\t\t\t\tret,\n\t\t\t\tindex,\n\t\t\t\tschedulePromises,\n\t\t\t\thydrationNodes,\n\t\t\t);\n\t\t} else if (tag === Text) {\n\t\t\tvalue = commitText(\n\t\t\t\tadapter,\n\t\t\t\tret,\n\t\t\t\tel as Element<Text>,\n\t\t\t\tscope,\n\t\t\t\thydrationNodes,\n\t\t\t);\n\t\t} else if (tag === Raw) {\n\t\t\tvalue = commitRaw(adapter, host, ret, scope, hydrationNodes);\n\t\t} else {\n\t\t\tvalue = commitHost(adapter, ret, ctx, schedulePromises, hydrationNodes);\n\t\t}\n\n\t\tif (ret.fallback) {\n\t\t\tunmount(adapter, host, ctx, ret.fallback, false);\n\t\t\tret.fallback = undefined;\n\t\t}\n\t}\n\n\tif (skippedHydrationNodes) {\n\t\tskippedHydrationNodes.splice(0, wrap(value).length);\n\t}\n\n\tif (!getFlag(ret, DidCommit)) {\n\t\tsetFlag(ret, DidCommit);\n\t\tif (\n\t\t\ttypeof tag !== \"function\" &&\n\t\t\ttag !== Fragment &&\n\t\t\ttag !== Portal &&\n\t\t\ttypeof el.props.ref === \"function\"\n\t\t) {\n\t\t\tel.props.ref(adapter.read(value));\n\t\t}\n\t}\n\n\treturn value;\n}\n\nfunction commitChildren<\n\tTNode,\n\tTScope,\n\tTRoot extends TNode | undefined,\n\tTResult,\n>(\n\tadapter: RenderAdapter<TNode, unknown, TRoot, TResult>,\n\thost: Retainer<TNode, TScope>,\n\tctx: ContextState<TNode, TScope, TRoot, TResult> | undefined,\n\tscope: TScope | undefined,\n\tparent: Retainer<TNode, TScope>,\n\tindex: number,\n\tschedulePromises: Array<PromiseLike<unknown>>,\n\thydrationNodes: Array<TNode> | undefined,\n): Array<TNode> {\n\tlet values: Array<TNode> = [];\n\tfor (let i = 0, children = wrap(parent.children); i < children.length; i++) {\n\t\tlet child = children[i];\n\t\tlet schedulePromises1: Array<unknown> | undefined;\n\t\tlet isSchedulingFallback = false;\n\t\twhile (\n\t\t\tchild &&\n\t\t\t((!getFlag(child, DidDiff) && child.fallback) ||\n\t\t\t\tgetFlag(child, IsScheduling))\n\t\t) {\n\t\t\t// If the child is scheduling, it is a component retainer so ctx will be\n\t\t\t// defined.\n\t\t\tif (getFlag(child, IsScheduling) && child.ctx!.schedule) {\n\t\t\t\t(schedulePromises1 = schedulePromises1 || []).push(\n\t\t\t\t\tchild.ctx!.schedule.promise,\n\t\t\t\t);\n\t\t\t\tisSchedulingFallback = true;\n\t\t\t}\n\n\t\t\tif (!getFlag(child, DidDiff) && getFlag(child, DidCommit)) {\n\t\t\t\t// If this child has not diffed but has committed, it means it is a\n\t\t\t\t// fallback that is being resurrected.\n\t\t\t\tfor (const node of getChildValues(child)) {\n\t\t\t\t\tadapter.remove({\n\t\t\t\t\t\tnode,\n\t\t\t\t\t\tparentNode: host.value as TNode,\n\t\t\t\t\t\tisNested: false,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchild = child.fallback;\n\t\t\t// When a scheduling component is mounting asynchronously but diffs\n\t\t\t// immediately, it will cause previous async diffs to settle due to the\n\t\t\t// chasing mechanism. This would cause earlier renders to resolve sooner\n\t\t\t// than expected, because the render would be missing both its usual\n\t\t\t// children and the children of the scheduling render. Therefore, we need\n\t\t\t// to defer the settling of previous renders until either that render\n\t\t\t// settles, or the scheduling component finally finishes scheduling.\n\t\t\t//\n\t\t\t// To do this, we take advantage of the fact that commits for aborted\n\t\t\t// renders will still fire and walk the tree. During that commit walk,\n\t\t\t// when we encounter a scheduling element, we push a race of the\n\t\t\t// scheduling promise with the inflight diff of the async fallback\n\t\t\t// fallback to schedulePromises to delay the initiator.\n\t\t\t//\n\t\t\t// However, we need to make sure we only use the inflight diffs for the\n\t\t\t// fallback which we are trying to delay, in the case of multiple renders\n\t\t\t// and fallbacks. To do this, we take advantage of the fact that when\n\t\t\t// multiple renders race (e.g., render1->render2->render3->scheduling\n\t\t\t// component), the chasing mechanism will call stale commits in reverse\n\t\t\t// order.\n\t\t\t//\n\t\t\t// We can use this ordering to delay to find which fallbacks we need to\n\t\t\t// add to the race. Each commit call progressively marks an additional\n\t\t\t// fallback as a scheduling fallback, and does not contribute to the\n\t\t\t// scheduling promises if it is further than the last seen level.\n\t\t\t//\n\t\t\t// This prevents promise contamination where newer renders settle early\n\t\t\t// due to diffs from older renders.\n\t\t\tif (schedulePromises1 && isSchedulingFallback && child) {\n\t\t\t\tif (!getFlag(child, DidDiff)) {\n\t\t\t\t\tconst inflightDiff = getInflightDiff(child);\n\t\t\t\t\tschedulePromises1.push(inflightDiff);\n\t\t\t\t} else {\n\t\t\t\t\t// If a scheduling component's fallback has already diffed, we do not\n\t\t\t\t\t// need delay the render.\n\t\t\t\t\tschedulePromises1 = undefined;\n\t\t\t\t}\n\n\t\t\t\tif (getFlag(child, IsSchedulingFallback)) {\n\t\t\t\t\t// This fallback was marked by a more recent commit - keep processing\n\t\t\t\t\t// deeper levels\n\t\t\t\t\tisSchedulingFallback = true;\n\t\t\t\t} else {\n\t\t\t\t\t// First unmarked fallback we've encountered - mark it and stop\n\t\t\t\t\t// contributing to schedulePromises1 for deeper levels.\n\t\t\t\t\tsetFlag(child, IsSchedulingFallback, true);\n\t\t\t\t\tisSchedulingFallback = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (schedulePromises1 && schedulePromises1.length > 1) {\n\t\t\tschedulePromises.push(safeRace(schedulePromises1));\n\t\t}\n\n\t\tif (child) {\n\t\t\tconst value = commit(\n\t\t\t\tadapter,\n\t\t\t\thost,\n\t\t\t\tchild,\n\t\t\t\tctx,\n\t\t\t\tscope,\n\t\t\t\tindex,\n\t\t\t\tschedulePromises,\n\t\t\t\thydrationNodes,\n\t\t\t);\n\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\tfor (let j = 0; j < value.length; j++) {\n\t\t\t\t\tvalues.push(value[j]);\n\t\t\t\t}\n\t\t\t\tindex += value.length;\n\t\t\t} else if (value) {\n\t\t\t\tvalues.push(value);\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (parent.graveyard) {\n\t\tfor (let i = 0; i < parent.graveyard.length; i++) {\n\t\t\tconst child = parent.graveyard[i];\n\t\t\tunmount(adapter, host, ctx, child, false);\n\t\t}\n\n\t\tparent.graveyard = undefined;\n\t}\n\n\tif (parent.lingerers) {\n\t\t// if parent.lingerers is set, a descendant component is unmounting\n\t\t// asynchronously, so we overwrite values to include lingerering DOM nodes.\n\t\tvalues = getChildValues(parent);\n\t}\n\n\treturn values;\n}\n\nfunction commitText<TNode, TScope>(\n\tadapter: RenderAdapter<TNode, TScope, TNode | undefined, unknown>,\n\tret: Retainer<TNode, TScope>,\n\tel: Element<Text>,\n\tscope: TScope | undefined,\n\thydrationNodes: Array<TNode> | undefined,\n): TNode {\n\tconst value = adapter.text({\n\t\tvalue: el.props.value,\n\t\tscope,\n\t\toldNode: ret.value as TNode,\n\t\thydrationNodes,\n\t});\n\n\tret.value = value;\n\treturn value;\n}\n\nfunction commitRaw<TNode, TScope>(\n\tadapter: RenderAdapter<TNode, TScope, TNode | undefined, unknown>,\n\thost: Retainer<TNode>,\n\tret: Retainer<TNode>,\n\tscope: TScope | undefined,\n\thydrationNodes: Array<TNode> | undefined,\n): ElementValue<TNode> {\n\tif (!ret.oldProps || ret.oldProps.value !== ret.el.props.value) {\n\t\tconst oldNodes = wrap(ret.value);\n\t\tfor (let i = 0; i < oldNodes.length; i++) {\n\t\t\tconst oldNode = oldNodes[i];\n\t\t\tadapter.remove({\n\t\t\t\tnode: oldNode,\n\t\t\t\tparentNode: host.value as TNode,\n\t\t\t\tisNested: false,\n\t\t\t});\n\t\t}\n\t\tret.value = adapter.raw({\n\t\t\tvalue: ret.el.props.value as any,\n\t\t\tscope,\n\t\t\thydrationNodes,\n\t\t});\n\t}\n\n\tret.oldProps = stripSpecialProps(ret.el.props);\n\treturn ret.value;\n}\n\nfunction commitHost<TNode, TScope, TRoot extends TNode | undefined>(\n\tadapter: RenderAdapter<TNode, TScope, TRoot, unknown>,\n\tret: Retainer<TNode, TScope>,\n\tctx: ContextState<TNode, TScope, TRoot, unknown> | undefined,\n\tschedulePromises: Array<PromiseLike<unknown>>,\n\thydrationNodes: Array<TNode> | undefined,\n): ElementValue<TNode> {\n\tif (getFlag(ret, IsCopied) && getFlag(ret, DidCommit)) {\n\t\treturn getValue(ret);\n\t}\n\n\tconst tag = ret.el.tag as string | symbol;\n\tconst props = stripSpecialProps(ret.el.props);\n\tconst oldProps = ret.oldProps;\n\tlet node = ret.value as TNode;\n\n\tlet copyProps: Set<string> | undefined;\n\tlet copyChildren = false;\n\tif (oldProps) {\n\t\tfor (const propName in props) {\n\t\t\tif (props[propName] === Copy) {\n\t\t\t\t// The Copy tag can be used to skip the patching of a prop.\n\t\t\t\t//   <div class={shouldPatchClass ? \"class-name\" : Copy} />\n\t\t\t\tprops[propName] = oldProps[propName];\n\t\t\t\t(copyProps = copyProps || new Set()).add(propName);\n\t\t\t}\n\t\t}\n\n\t\tif (typeof ret.el.props.copy === \"string\") {\n\t\t\tconst copyMetaProp = new MetaProp(\"copy\", ret.el.props.copy);\n\t\t\tif (copyMetaProp.include) {\n\t\t\t\tfor (const propName of copyMetaProp.props) {\n\t\t\t\t\tif (propName in oldProps) {\n\t\t\t\t\t\tprops[propName] = oldProps[propName];\n\t\t\t\t\t\t(copyProps = copyProps || new Set()).add(propName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (const propName in oldProps) {\n\t\t\t\t\tif (!copyMetaProp.props.has(propName)) {\n\t\t\t\t\t\tprops[propName] = oldProps[propName];\n\t\t\t\t\t\t(copyProps = copyProps || new Set()).add(propName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcopyChildren = copyMetaProp.includes(\"children\");\n\t\t}\n\t}\n\n\tconst scope = ret.scope;\n\tlet childHydrationNodes: Array<TNode> | undefined;\n\tlet quietProps: Set<string> | undefined;\n\tlet hydrationMetaProp: MetaProp | undefined;\n\tif (!getFlag(ret, DidCommit)) {\n\t\tif (tag === Portal) {\n\t\t\tif (ret.el.props.hydrate && typeof ret.el.props.hydrate !== \"string\") {\n\t\t\t\tchildHydrationNodes = adapter.adopt({\n\t\t\t\t\ttag,\n\t\t\t\t\ttagName: getTagName(tag),\n\t\t\t\t\tnode,\n\t\t\t\t\tprops,\n\t\t\t\t\tscope,\n\t\t\t\t});\n\n\t\t\t\tif (childHydrationNodes) {\n\t\t\t\t\tfor (let i = 0; i < childHydrationNodes.length; i++) {\n\t\t\t\t\t\tadapter.remove({\n\t\t\t\t\t\t\tnode: childHydrationNodes[i],\n\t\t\t\t\t\t\tparentNode: node,\n\t\t\t\t\t\t\tisNested: false,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (!node && hydrationNodes) {\n\t\t\t\tconst nextChild = hydrationNodes.shift();\n\t\t\t\tif (typeof ret.el.props.hydrate === \"string\") {\n\t\t\t\t\thydrationMetaProp = new MetaProp(\"hydration\", ret.el.props.hydrate);\n\t\t\t\t\tif (hydrationMetaProp.include) {\n\t\t\t\t\t\t// if we're in inclusive mode, we add all props to quietProps and\n\t\t\t\t\t\t// remove props specified in the metaprop\n\t\t\t\t\t\tquietProps = new Set(Object.keys(props));\n\t\t\t\t\t\tfor (const propName of hydrationMetaProp.props) {\n\t\t\t\t\t\t\tquietProps.delete(propName);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tquietProps = hydrationMetaProp.props;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tchildHydrationNodes = adapter.adopt({\n\t\t\t\t\ttag,\n\t\t\t\t\ttagName: getTagName(tag),\n\t\t\t\t\tnode: nextChild!,\n\t\t\t\t\tprops,\n\t\t\t\t\tscope,\n\t\t\t\t});\n\n\t\t\t\tif (childHydrationNodes) {\n\t\t\t\t\tnode = nextChild!;\n\t\t\t\t\tfor (let i = 0; i < childHydrationNodes.length; i++) {\n\t\t\t\t\t\tadapter.remove({\n\t\t\t\t\t\t\tnode: childHydrationNodes[i],\n\t\t\t\t\t\t\tparentNode: node,\n\t\t\t\t\t\t\tisNested: false,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// TODO: For some reason, there are cases where the node is already set\n\t\t\t// and the DidCommit flag is false. Not checking for node fails a test\n\t\t\t// where a child dispatches an event in a schedule callback, the parent\n\t\t\t// listens for this event and refreshes.\n\t\t\tif (!node) {\n\t\t\t\tnode = adapter.create({\n\t\t\t\t\ttag,\n\t\t\t\t\ttagName: getTagName(tag),\n\t\t\t\t\tprops,\n\t\t\t\t\tscope,\n\t\t\t\t});\n\t\t\t}\n\t\t\tret.value = node;\n\t\t}\n\t}\n\n\tif (tag !== Portal) {\n\t\tadapter.patch({\n\t\t\ttag,\n\t\t\ttagName: getTagName(tag),\n\t\t\tnode,\n\t\t\tprops,\n\t\t\toldProps,\n\t\t\tscope,\n\t\t\tcopyProps,\n\t\t\tisHydrating: !!childHydrationNodes,\n\t\t\tquietProps,\n\t\t});\n\t}\n\n\tif (!copyChildren) {\n\t\tconst children = commitChildren(\n\t\t\tadapter,\n\t\t\tret,\n\t\t\tctx,\n\t\t\tscope,\n\t\t\tret,\n\t\t\t0,\n\t\t\tschedulePromises,\n\t\t\thydrationMetaProp && !hydrationMetaProp.includes(\"children\")\n\t\t\t\t? undefined\n\t\t\t\t: childHydrationNodes,\n\t\t);\n\n\t\tadapter.arrange({\n\t\t\ttag,\n\t\t\ttagName: getTagName(tag),\n\t\t\tnode: node,\n\t\t\tprops,\n\t\t\tchildren,\n\t\t\toldProps,\n\t\t});\n\t}\n\n\tret.oldProps = props;\n\tif (tag === Portal) {\n\t\tflush(adapter, ret.value as TRoot);\n\t\t// The root passed to Portal elements are opaque to parents so we return\n\t\t// undefined here.\n\t\treturn;\n\t}\n\n\treturn node;\n}\n\nclass MetaProp {\n\tdeclare include: boolean;\n\tdeclare props: Set<string>;\n\n\tconstructor(propName: string, propValue: string) {\n\t\tthis.include = true;\n\t\tthis.props = new Set<string>();\n\t\tlet noBangs = true;\n\t\tlet allBangs = true;\n\t\tconst tokens = propValue.split(/[,\\s]+/);\n\t\tfor (let i = 0; i < tokens.length; i++) {\n\t\t\tconst token = tokens[i].trim();\n\t\t\tif (!token) {\n\t\t\t\tcontinue;\n\t\t\t} else if (token.startsWith(\"!\")) {\n\t\t\t\tnoBangs = false;\n\t\t\t\tthis.props.add(token.slice(1));\n\t\t\t} else {\n\t\t\t\tallBangs = false;\n\t\t\t\tthis.props.add(token);\n\t\t\t}\n\t\t}\n\n\t\tif (!allBangs && !noBangs) {\n\t\t\tconsole.error(\n\t\t\t\t`Invalid ${propName} prop \"${propValue}\".\\nUse prop or !prop but not both.`,\n\t\t\t);\n\t\t\tthis.include = true;\n\t\t\tthis.props.clear();\n\t\t} else {\n\t\t\tthis.include = noBangs;\n\t\t}\n\t}\n\n\tincludes(propName: string): boolean {\n\t\tif (this.include) {\n\t\t\treturn this.props.has(propName);\n\t\t} else {\n\t\t\treturn !this.props.has(propName);\n\t\t}\n\t}\n}\n\nfunction contextContains(parent: ContextState, child: ContextState): boolean {\n\tfor (\n\t\tlet current: ContextState | undefined = child;\n\t\tcurrent !== undefined;\n\t\tcurrent = current.parent\n\t) {\n\t\tif (current === parent) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n// When rendering is done without a root, we use this special anonymous root to\n// make sure after callbacks are still called.\nconst ANONYMOUS_ROOT: any = {};\nfunction flush<TRoot>(\n\tadapter: RenderAdapter<unknown, unknown, TRoot>,\n\troot: TRoot | undefined,\n\tinitiator?: ContextState,\n) {\n\tif (root != null) {\n\t\tadapter.finalize(root);\n\t}\n\n\tif (typeof root !== \"object\" || root === null) {\n\t\troot = ANONYMOUS_ROOT;\n\t}\n\n\t// The initiator is the context which initiated the rendering process. If\n\t// initiator is defined we call and clear all flush callbacks which are\n\t// registered with the initiator or with a child context of the initiator,\n\t// because they are fully rendered.\n\t//\n\t// If no initiator is provided, we can call and clear all flush callbacks\n\t// which are not scheduling.\n\tconst afterMap = afterMapByRoot.get(root as any);\n\tif (afterMap) {\n\t\tconst afterMap1 = new Map<ContextState, Set<Function>>();\n\t\tfor (const [ctx, callbacks] of afterMap) {\n\t\t\tif (\n\t\t\t\tgetFlag(ctx.ret, IsScheduling) ||\n\t\t\t\t(initiator && !contextContains(initiator, ctx))\n\t\t\t) {\n\t\t\t\t// copy over callbacks to the new map (defer them)\n\t\t\t\tafterMap.delete(ctx);\n\t\t\t\tafterMap1.set(ctx, callbacks);\n\t\t\t}\n\t\t}\n\n\t\tif (afterMap1.size) {\n\t\t\tafterMapByRoot.set(root as any, afterMap1);\n\t\t} else {\n\t\t\tafterMapByRoot.delete(root as any);\n\t\t}\n\n\t\tfor (const [ctx, callbacks] of afterMap) {\n\t\t\tconst value = adapter.read(getValue(ctx.ret));\n\t\t\tfor (const callback of callbacks) {\n\t\t\t\tcallback(value);\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction unmount<TNode, TScope, TRoot extends TNode | undefined, TResult>(\n\tadapter: RenderAdapter<TNode, TScope, TRoot, TResult>,\n\thost: Retainer<TNode>,\n\tctx: ContextState<TNode, TScope, TRoot, TResult> | undefined,\n\tret: Retainer<TNode>,\n\tisNested: boolean,\n): void {\n\t// TODO: set the IsUnmounted flag consistently for all retainers\n\tif (ret.fallback) {\n\t\tunmount(adapter, host, ctx, ret.fallback, isNested);\n\t\tret.fallback = undefined;\n\t}\n\n\tif (getFlag(ret, IsResurrecting)) {\n\t\treturn;\n\t}\n\n\tif (ret.lingerers) {\n\t\tfor (let i = 0; i < ret.lingerers.length; i++) {\n\t\t\tconst lingerers = ret.lingerers[i];\n\t\t\tif (lingerers) {\n\t\t\t\tfor (const lingerer of lingerers) {\n\t\t\t\t\tunmount(adapter, host, ctx, lingerer, isNested);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tret.lingerers = undefined;\n\t}\n\n\tif (typeof ret.el.tag === \"function\") {\n\t\tunmountComponent(ret.ctx!, isNested);\n\t} else if (ret.el.tag === Fragment) {\n\t\tunmountChildren(adapter, host, ctx, ret, isNested);\n\t} else if (ret.el.tag === Portal) {\n\t\tunmountChildren(adapter, ret, ctx, ret, false);\n\t\tif (ret.value != null) {\n\t\t\tadapter.finalize(ret.value as TRoot);\n\t\t}\n\t} else {\n\t\tunmountChildren(adapter, ret, ctx, ret, true);\n\n\t\tif (getFlag(ret, DidCommit)) {\n\t\t\tif (ctx) {\n\t\t\t\t// Remove the value from every context which shares the same host.\n\t\t\t\tremoveEventTargetDelegates(\n\t\t\t\t\tctx.ctx,\n\t\t\t\t\t[ret.value],\n\t\t\t\t\t(ctx1) => ctx1[_ContextState].host === host,\n\t\t\t\t);\n\t\t\t}\n\t\t\tadapter.remove({\n\t\t\t\tnode: ret.value as TNode,\n\t\t\t\tparentNode: host.value as TNode,\n\t\t\t\tisNested,\n\t\t\t});\n\t\t}\n\t}\n}\n\nfunction unmountChildren<\n\tTNode,\n\tTScope,\n\tTRoot extends TNode | undefined,\n\tTResult,\n>(\n\tadapter: RenderAdapter<TNode, TScope, TRoot, TResult>,\n\thost: Retainer<TNode>,\n\tctx: ContextState<TNode, TScope, TRoot, TResult> | undefined,\n\tret: Retainer<TNode>,\n\tisNested: boolean,\n): void {\n\tif (ret.graveyard) {\n\t\tfor (let i = 0; i < ret.graveyard.length; i++) {\n\t\t\tconst child = ret.graveyard[i];\n\t\t\tunmount(adapter, host, ctx, child, isNested);\n\t\t}\n\n\t\tret.graveyard = undefined;\n\t}\n\n\tfor (let i = 0, children = wrap(ret.children); i < children.length; i++) {\n\t\tconst child = children[i];\n\t\tif (typeof child === \"object\") {\n\t\t\tunmount(adapter, host, ctx, child, isNested);\n\t\t}\n\t}\n}\nconst provisionMaps = new WeakMap<ContextState, Map<unknown, unknown>>();\n\nconst scheduleMap = new WeakMap<ContextState, Set<Function>>();\n\nconst cleanupMap = new WeakMap<ContextState, Set<Function>>();\n\n// keys are roots\nconst afterMapByRoot = new WeakMap<object, Map<ContextState, Set<Function>>>();\n\ninterface PullController {\n\titerationP: Promise<ChildrenIteratorResult> | undefined;\n\tdiff: Promise<undefined> | undefined;\n\tonChildError: ((err: unknown) => void) | undefined;\n}\n\ninterface ScheduleController {\n\tpromise: Promise<unknown>;\n\tonAbort: () => void;\n}\n\n// TODO: allow ContextState to be initialized for testing purposes\n/**\n * @internal\n * The internal class which holds context data.\n */\nclass ContextState<\n\tTNode = unknown,\n\tTScope = unknown,\n\tTRoot extends TNode | undefined = TNode | undefined,\n\tTResult = unknown,\n> {\n\t/** The adapter of the renderer which created this context. */\n\tdeclare adapter: RenderAdapter<TNode, TScope, TRoot, TResult>;\n\n\t/** The root node as set by the nearest ancestor portal. */\n\tdeclare root: TRoot | undefined;\n\n\t/**\n\t * The nearest ancestor host or portal retainer.\n\t *\n\t * When refresh is called, the host element will be arranged as the last step\n\t * of the commit, to make sure the parent's children properly reflects the\n\t * components's childrenk\n\t */\n\tdeclare host: Retainer<TNode>;\n\n\t/** The parent context state. */\n\tdeclare parent: ContextState | undefined;\n\n\t/** The actual context associated with this state. */\n\tdeclare ctx: Context<unknown, TResult>;\n\n\t/** The value of the scope at the point of element's creation. */\n\tdeclare scope: TScope | undefined;\n\n\t/** The internal node associated with this context. */\n\tdeclare ret: Retainer<TNode>;\n\n\t/**\n\t * Any iterator returned by a component function.\n\t *\n\t * Existence of this property implies that the component is a generator\n\t * component. It is deleted when a component is returned.\n\t */\n\tdeclare iterator:\n\t\t| Iterator<Children, Children | void, unknown>\n\t\t| AsyncIterator<Children, Children | void, unknown>\n\t\t| undefined;\n\n\t// See runComponent() for a description of these properties.\n\tdeclare inflight: [Promise<undefined>, Promise<undefined>] | undefined;\n\tdeclare enqueued: [Promise<undefined>, Promise<undefined>] | undefined;\n\n\tdeclare pull: PullController | undefined;\n\n\t// The onPropsProvided callback is set when a component requests props via\n\t// the for await...of loop and props are not available. It is called when\n\t// the component is updated or refreshed.\n\tdeclare onPropsProvided: ((props: unknown) => unknown) | undefined;\n\t// The onPropsRequested callback is set when a component is updated or\n\t// refreshed but the new props are not consumed. It is called when the new\n\t// props are requested.\n\tdeclare onPropsRequested: (() => unknown) | undefined;\n\n\t// The last known index of the component's children, relative to its nearest\n\t// ancestor host or portal.\n\tdeclare index: number;\n\n\tdeclare schedule: ScheduleController | undefined;\n\n\tconstructor(\n\t\tadapter: RenderAdapter<TNode, TScope, TRoot, TResult>,\n\t\troot: TRoot,\n\t\thost: Retainer<TNode>,\n\t\tparent: ContextState | undefined,\n\t\tscope: TScope | undefined,\n\t\tret: Retainer<TNode>,\n\t) {\n\t\tthis.adapter = adapter;\n\t\tthis.root = root;\n\t\tthis.host = host;\n\t\tthis.parent = parent;\n\t\t// This property must be set after this.parent is set because the Context\n\t\t// constructor reads this.parent.\n\t\tthis.ctx = new Context(this);\n\t\tthis.scope = scope;\n\t\tthis.ret = ret;\n\n\t\tthis.iterator = undefined;\n\t\tthis.inflight = undefined;\n\t\tthis.enqueued = undefined;\n\n\t\tthis.onPropsProvided = undefined;\n\t\tthis.onPropsRequested = undefined;\n\n\t\tthis.pull = undefined;\n\t\tthis.index = 0;\n\t\tthis.schedule = undefined;\n\t}\n}\n\n// Public type that only extracts props from component functions\nexport type ComponentProps<T> = T extends () => unknown\n\t? {}\n\t: T extends (props: infer U) => unknown\n\t\t? U\n\t\t: never;\n\n// Public helper type that handles both component functions and regular objects\nexport type ComponentPropsOrProps<T> = T extends Function\n\t? ComponentProps<T>\n\t: T;\n\nconst _ContextState = Symbol.for(\"crank.ContextState\");\n\n/**\n * A class which is instantiated and passed to every component as its this\n * value/second parameter. Contexts form a tree just like elements and all\n * components in the element tree are connected via contexts. Components can\n * use this tree to communicate data upwards via events and downwards via\n * provisions.\n *\n * @template [T=*] - The expected shape of the props passed to the component,\n * or a component function. Used to strongly type the Context iterator methods.\n * @template [TResult=*] - The readable element value type. It is used in\n * places such as the return value of refresh and the argument passed to\n * schedule and cleanup callbacks.\n */\nexport class Context<\n\tT = any,\n\tTResult = any,\n> extends CustomEventTarget<Context> {\n\t/**\n\t * @internal\n\t * DO NOT USE READ THIS PROPERTY.\n\t */\n\tdeclare [_ContextState]: ContextState<unknown, unknown, unknown, TResult>;\n\n\t// TODO: If we could make the constructor function take a nicer value, it\n\t// would be useful for testing purposes.\n\tconstructor(state: ContextState<unknown, unknown, unknown, TResult>) {\n\t\tsuper(state.parent ? state.parent.ctx : null);\n\t\tthis[_ContextState] = state;\n\t}\n\n\t/**\n\t * The current props of the associated element.\n\t */\n\tget props(): ComponentPropsOrProps<T> {\n\t\treturn this[_ContextState].ret.el.props as ComponentPropsOrProps<T>;\n\t}\n\n\t/**\n\t * The current value of the associated element.\n\t *\n\t * @deprecated\n\t */\n\tget value(): TResult {\n\t\tconsole.warn(\"Context.value is deprecated.\");\n\t\treturn this[_ContextState].adapter.read(getValue(this[_ContextState].ret));\n\t}\n\n\tget isExecuting(): boolean {\n\t\treturn getFlag(this[_ContextState].ret, IsExecuting);\n\t}\n\n\tget isUnmounted(): boolean {\n\t\treturn getFlag(this[_ContextState].ret, IsUnmounted);\n\t}\n\n\t*[Symbol.iterator](): Generator<ComponentPropsOrProps<T>, undefined> {\n\t\tconst ctx = this[_ContextState];\n\t\tsetFlag(ctx.ret, IsInForOfLoop);\n\t\ttry {\n\t\t\twhile (!getFlag(ctx.ret, IsUnmounted) && !getFlag(ctx.ret, IsErrored)) {\n\t\t\t\tif (getFlag(ctx.ret, NeedsToYield)) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`<${getTagName(ctx.ret.el.tag)}> context iterated twice without a yield`,\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tsetFlag(ctx.ret, NeedsToYield);\n\t\t\t\t}\n\n\t\t\t\tyield ctx.ret.el.props as ComponentPropsOrProps<T>;\n\t\t\t}\n\t\t} finally {\n\t\t\tsetFlag(ctx.ret, IsInForOfLoop, false);\n\t\t}\n\t}\n\n\tasync *[Symbol.asyncIterator](): AsyncGenerator<\n\t\tComponentPropsOrProps<T>,\n\t\tundefined\n\t> {\n\t\tconst ctx = this[_ContextState];\n\t\tsetFlag(ctx.ret, IsInForAwaitOfLoop);\n\t\ttry {\n\t\t\twhile (!getFlag(ctx.ret, IsUnmounted) && !getFlag(ctx.ret, IsErrored)) {\n\t\t\t\tif (getFlag(ctx.ret, NeedsToYield)) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`<${getTagName(ctx.ret.el.tag)}> context iterated twice without a yield`,\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tsetFlag(ctx.ret, NeedsToYield);\n\t\t\t\t}\n\n\t\t\t\tif (getFlag(ctx.ret, PropsAvailable)) {\n\t\t\t\t\tsetFlag(ctx.ret, PropsAvailable, false);\n\t\t\t\t\tyield ctx.ret.el.props;\n\t\t\t\t} else {\n\t\t\t\t\tconst props = await new Promise<ComponentPropsOrProps<T>>(\n\t\t\t\t\t\t(resolve) =>\n\t\t\t\t\t\t\t(ctx.onPropsProvided = resolve as (props: unknown) => unknown),\n\t\t\t\t\t);\n\t\t\t\t\tif (getFlag(ctx.ret, IsUnmounted) || getFlag(ctx.ret, IsErrored)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tyield props;\n\t\t\t\t}\n\n\t\t\t\tif (ctx.onPropsRequested) {\n\t\t\t\t\tctx.onPropsRequested();\n\t\t\t\t\tctx.onPropsRequested = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tsetFlag(ctx.ret, IsInForAwaitOfLoop, false);\n\t\t\tif (ctx.onPropsRequested) {\n\t\t\t\tctx.onPropsRequested();\n\t\t\t\tctx.onPropsRequested = undefined;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Re-executes a component.\n\t *\n\t * @param callback - Optional callback to execute before refresh\n\t * @returns The rendered result of the component or a promise thereof if the\n\t * component or its children execute asynchronously.\n\t */\n\trefresh(callback?: () => unknown): Promise<TResult> | TResult {\n\t\tconst ctx = this[_ContextState];\n\t\tif (getFlag(ctx.ret, IsUnmounted)) {\n\t\t\tconsole.error(\n\t\t\t\t`Component <${getTagName(ctx.ret.el.tag)}> is unmounted. Check the isUnmounted property if necessary.`,\n\t\t\t);\n\t\t\treturn ctx.adapter.read(getValue(ctx.ret));\n\t\t} else if (getFlag(ctx.ret, IsExecuting)) {\n\t\t\tconsole.error(\n\t\t\t\t`Component <${getTagName(ctx.ret.el.tag)}> is already executing Check the isExecuting property if necessary.`,\n\t\t\t);\n\t\t\treturn ctx.adapter.read(getValue(ctx.ret));\n\t\t}\n\n\t\tif (callback) {\n\t\t\tconst result = callback();\n\t\t\tif (isPromiseLike(result)) {\n\t\t\t\treturn Promise.resolve(result).then(() => {\n\t\t\t\t\tif (!getFlag(ctx.ret, IsUnmounted)) {\n\t\t\t\t\t\treturn this.refresh();\n\t\t\t\t\t}\n\t\t\t\t\treturn ctx.adapter.read(getValue(ctx.ret));\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (getFlag(ctx.ret, IsScheduling)) {\n\t\t\tsetFlag(ctx.ret, IsSchedulingRefresh);\n\t\t}\n\n\t\tlet diff: Promise<undefined> | undefined;\n\t\tconst schedulePromises: Array<PromiseLike<unknown>> = [];\n\t\ttry {\n\t\t\tsetFlag(ctx.ret, IsRefreshing);\n\t\t\tdiff = enqueueComponent(ctx);\n\t\t\tif (isPromiseLike(diff)) {\n\t\t\t\treturn diff\n\t\t\t\t\t.then(() => ctx.adapter.read(commitComponent(ctx, schedulePromises)))\n\t\t\t\t\t.then((result) => {\n\t\t\t\t\t\tif (schedulePromises.length) {\n\t\t\t\t\t\t\treturn Promise.all(schedulePromises).then(() => {\n\t\t\t\t\t\t\t\treturn ctx.adapter.read(getValue(ctx.ret));\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t})\n\t\t\t\t\t.catch((err) => {\n\t\t\t\t\t\tconst diff = propagateError(ctx, err, schedulePromises);\n\t\t\t\t\t\tif (diff) {\n\t\t\t\t\t\t\treturn diff.then(() => {\n\t\t\t\t\t\t\t\tif (schedulePromises.length) {\n\t\t\t\t\t\t\t\t\treturn Promise.all(schedulePromises).then(() => {\n\t\t\t\t\t\t\t\t\t\treturn ctx.adapter.read(getValue(ctx.ret));\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treturn ctx.adapter.read(getValue(ctx.ret));\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (schedulePromises.length) {\n\t\t\t\t\t\t\treturn Promise.all(schedulePromises).then(() => {\n\t\t\t\t\t\t\t\treturn ctx.adapter.read(getValue(ctx.ret));\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn ctx.adapter.read(getValue(ctx.ret));\n\t\t\t\t\t})\n\t\t\t\t\t.finally(() => setFlag(ctx.ret, IsRefreshing, false));\n\t\t\t}\n\n\t\t\tconst result = ctx.adapter.read(commitComponent(ctx, schedulePromises));\n\t\t\tif (schedulePromises.length) {\n\t\t\t\treturn Promise.all(schedulePromises).then(() => {\n\t\t\t\t\treturn ctx.adapter.read(getValue(ctx.ret));\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn result;\n\t\t} catch (err) {\n\t\t\t// TODO: await schedulePromises\n\t\t\tconst diff = propagateError(ctx, err, schedulePromises);\n\t\t\tif (diff) {\n\t\t\t\treturn diff\n\t\t\t\t\t.then(() => {\n\t\t\t\t\t\tif (schedulePromises.length) {\n\t\t\t\t\t\t\treturn Promise.all(schedulePromises).then(() => {\n\t\t\t\t\t\t\t\treturn ctx.adapter.read(getValue(ctx.ret));\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\t.then(() => ctx.adapter.read(getValue(ctx.ret)));\n\t\t\t}\n\n\t\t\tif (schedulePromises.length) {\n\t\t\t\treturn Promise.all(schedulePromises).then(() => {\n\t\t\t\t\treturn ctx.adapter.read(getValue(ctx.ret));\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn ctx.adapter.read(getValue(ctx.ret));\n\t\t} finally {\n\t\t\tif (!isPromiseLike(diff)) {\n\t\t\t\tsetFlag(ctx.ret, IsRefreshing, false);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Registers a callback which fires when the component's children are\n\t * created. Will only fire once per callback and update.\n\t */\n\tschedule(): Promise<TResult>;\n\tschedule(callback: (value: TResult) => unknown): void;\n\tschedule(callback?: (value: TResult) => unknown): Promise<TResult> | void {\n\t\tif (!callback) {\n\t\t\treturn new Promise<TResult>((resolve) => this.schedule(resolve));\n\t\t}\n\n\t\tconst ctx = this[_ContextState];\n\t\tlet callbacks = scheduleMap.get(ctx);\n\t\tif (!callbacks) {\n\t\t\tcallbacks = new Set<Function>();\n\t\t\tscheduleMap.set(ctx, callbacks);\n\t\t}\n\n\t\tcallbacks.add(callback);\n\t}\n\n\t/**\n\t * Registers a callback which fires when the component's children are fully\n\t * rendered. Will only fire once per callback and update.\n\t */\n\tafter(): Promise<TResult>;\n\tafter(callback: (value: TResult) => unknown): void;\n\tafter(callback?: (value: TResult) => unknown): Promise<TResult> | void {\n\t\tif (!callback) {\n\t\t\treturn new Promise<TResult>((resolve) => this.after(resolve));\n\t\t}\n\t\tconst ctx = this[_ContextState];\n\t\tconst root = ctx.root || ANONYMOUS_ROOT;\n\t\tlet afterMap = afterMapByRoot.get(root);\n\t\tif (!afterMap) {\n\t\t\tafterMap = new Map<ContextState, Set<Function>>();\n\t\t\tafterMapByRoot.set(root, afterMap);\n\t\t}\n\n\t\tlet callbacks = afterMap.get(ctx);\n\t\tif (!callbacks) {\n\t\t\tcallbacks = new Set<Function>();\n\t\t\tafterMap.set(ctx, callbacks);\n\t\t}\n\n\t\tcallbacks.add(callback);\n\t}\n\n\t/**\n\t * @deprecated the flush() method has been renamed to after().\n\t */\n\tflush(): Promise<TResult>;\n\tflush(callback: (value: TResult) => unknown): void;\n\tflush(callback?: (value: TResult) => unknown): Promise<TResult> | void {\n\t\tconsole.error(\"Context.flush() method has been renamed to after()\");\n\t\tthis.after(callback!);\n\t}\n\n\t/**\n\t * Registers a callback which fires when the component unmounts.\n\t *\n\t * The callback can be async to defer the unmounting of a component's children.\n\t */\n\tcleanup(): Promise<TResult>;\n\tcleanup(callback: (value: TResult) => unknown): void;\n\tcleanup(callback?: (value: TResult) => unknown): Promise<TResult> | void {\n\t\tif (!callback) {\n\t\t\treturn new Promise<TResult>((resolve) => this.cleanup(resolve));\n\t\t}\n\t\tconst ctx = this[_ContextState];\n\n\t\tif (getFlag(ctx.ret, IsUnmounted)) {\n\t\t\tconst value = ctx.adapter.read(getValue(ctx.ret));\n\t\t\tcallback(value);\n\t\t\treturn;\n\t\t}\n\n\t\tlet callbacks = cleanupMap.get(ctx);\n\t\tif (!callbacks) {\n\t\t\tcallbacks = new Set<Function>();\n\t\t\tcleanupMap.set(ctx, callbacks);\n\t\t}\n\n\t\tcallbacks.add(callback);\n\t}\n\n\tconsume<TKey extends keyof ProvisionMap>(key: TKey): ProvisionMap[TKey];\n\tconsume(key: unknown): any;\n\tconsume(key: unknown): any {\n\t\tfor (\n\t\t\tlet ctx = this[_ContextState].parent;\n\t\t\tctx !== undefined;\n\t\t\tctx = ctx.parent\n\t\t) {\n\t\t\tconst provisions = provisionMaps.get(ctx);\n\t\t\tif (provisions && provisions.has(key)) {\n\t\t\t\treturn provisions.get(key)!;\n\t\t\t}\n\t\t}\n\t}\n\n\tprovide<TKey extends keyof ProvisionMap>(\n\t\tkey: TKey,\n\t\tvalue: ProvisionMap[TKey],\n\t): void;\n\tprovide(key: unknown, value: any): void;\n\tprovide(key: unknown, value: any): void {\n\t\tconst ctx = this[_ContextState];\n\t\tlet provisions = provisionMaps.get(ctx);\n\t\tif (!provisions) {\n\t\t\tprovisions = new Map();\n\t\t\tprovisionMaps.set(ctx, provisions);\n\t\t}\n\n\t\tprovisions.set(key, value);\n\t}\n\n\t[CustomEventTarget.dispatchEventOnSelf](ev: Event): void {\n\t\tconst ctx = this[_ContextState];\n\t\t// dispatchEvent calls the prop callback if it exists\n\t\tlet propCallback = ctx.ret.el.props[\"on\" + ev.type] as unknown;\n\t\tif (typeof propCallback === \"function\") {\n\t\t\tpropCallback(ev);\n\t\t} else {\n\t\t\tfor (const propName in ctx.ret.el.props) {\n\t\t\t\tif (propName.toLowerCase() === \"on\" + ev.type.toLowerCase()) {\n\t\t\t\t\tpropCallback = ctx.ret.el.props[propName] as unknown;\n\t\t\t\t\tif (typeof propCallback === \"function\") {\n\t\t\t\t\t\tpropCallback(ev);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction diffComponent<TNode, TScope, TRoot extends TNode | undefined, TResult>(\n\tadapter: RenderAdapter<TNode, TScope, TRoot, TResult>,\n\troot: TRoot | undefined,\n\thost: Retainer<TNode, TScope>,\n\tparent: ContextState | undefined,\n\tscope: TScope | undefined,\n\tret: Retainer<TNode>,\n): Promise<undefined> | undefined {\n\tlet ctx: ContextState<TNode>;\n\tif (ret.ctx) {\n\t\tctx = ret.ctx;\n\t\tif (getFlag(ctx.ret, IsExecuting)) {\n\t\t\tconsole.error(\n\t\t\t\t`Component <${getTagName(ctx.ret.el.tag)}> is already executing`,\n\t\t\t);\n\t\t\treturn;\n\t\t} else if (ctx.schedule) {\n\t\t\treturn ctx.schedule.promise.then(() => {\n\t\t\t\treturn diffComponent(adapter, root, host, parent, scope, ret);\n\t\t\t});\n\t\t}\n\t} else {\n\t\tctx = ret.ctx = new ContextState(adapter, root, host, parent, scope, ret);\n\t}\n\n\tsetFlag(ctx.ret, IsUpdating);\n\treturn enqueueComponent(ctx);\n}\n\nfunction diffComponentChildren<TNode, TResult>(\n\tctx: ContextState<TNode, unknown, TNode | undefined, TResult>,\n\tchildren: Children,\n\tisYield: boolean,\n): Promise<undefined> | undefined {\n\tif (getFlag(ctx.ret, IsUnmounted) || getFlag(ctx.ret, IsErrored)) {\n\t\treturn;\n\t} else if (children === undefined) {\n\t\tconsole.error(\n\t\t\t`Component <${getTagName(ctx.ret.el.tag)}> has ${isYield ? \"yielded\" : \"returned\"} undefined. If this was intentional, ${isYield ? \"yield\" : \"return\"} null instead.`,\n\t\t);\n\t}\n\n\tlet diff: Promise<undefined> | undefined;\n\ttry {\n\t\t// TODO: Use a different flag here to indicate the component is\n\t\t// synchronously rendering children\n\n\t\t// We set the isExecuting flag in case a child component dispatches an event\n\t\t// which bubbles to this component and causes a synchronous refresh().\n\t\tsetFlag(ctx.ret, IsExecuting);\n\t\tdiff = diffChildren(\n\t\t\tctx.adapter,\n\t\t\tctx.root,\n\t\t\tctx.host,\n\t\t\tctx,\n\t\t\tctx.scope,\n\t\t\tctx.ret,\n\t\t\tnarrow(children),\n\t\t);\n\t\tif (diff) {\n\t\t\tdiff = diff.catch((err) => handleChildError(ctx, err));\n\t\t}\n\t} catch (err) {\n\t\tdiff = handleChildError(ctx, err);\n\t} finally {\n\t\tsetFlag(ctx.ret, IsExecuting, false);\n\t}\n\n\treturn diff;\n}\n\n/** Enqueues and executes the component associated with the context. */\nfunction enqueueComponent<TNode, TResult>(\n\tctx: ContextState<TNode, unknown, TNode | undefined, TResult>,\n): Promise<undefined> | undefined {\n\tif (!ctx.inflight) {\n\t\tconst [block, diff] = runComponent<TNode, TResult>(ctx);\n\t\tif (block) {\n\t\t\t// if block is a promise, diff is a promise\n\t\t\tctx.inflight = [block.finally(() => advanceComponent(ctx)), diff!];\n\t\t}\n\n\t\treturn diff;\n\t} else if (!ctx.enqueued) {\n\t\t// The enqueuedBlock and enqueuedDiff properties must be set\n\t\t// simultaneously, hence the usage of the Promise constructor.\n\t\tlet resolve: Function;\n\t\tctx.enqueued = [\n\t\t\tnew Promise<undefined>((resolve1) => (resolve = resolve1)).finally(() =>\n\t\t\t\tadvanceComponent(ctx),\n\t\t\t),\n\t\t\tctx.inflight[0]!.finally(() => {\n\t\t\t\tconst [block, diff] = runComponent<TNode, TResult>(ctx);\n\t\t\t\tresolve(block);\n\t\t\t\treturn diff;\n\t\t\t}),\n\t\t];\n\t}\n\n\treturn ctx.enqueued[1];\n}\n\n/** Called when the inflight block promise settles. */\nfunction advanceComponent(ctx: ContextState): void {\n\tctx.inflight = ctx.enqueued;\n\tctx.enqueued = undefined;\n}\n\n/**\n * This function is responsible for executing components, and handling the\n * different component types.\n *\n * @returns {[block, diff]} A tuple where:\n * - block is a promise or undefined which represents the duration during which\n *   the component is blocked.\n * - diff is a promise or undefined which represents the duration for diffing\n *   of children.\n *\n * While a component is blocked, further updates to the component are enqueued.\n *\n * Each component type blocks according to its implementation:\n * - Sync function components never block; when props or state change,\n *   updates are immediately passed to children.\n * - Async function components block only while awaiting their own async work\n *   (e.g., during an await), but do not block while their async children are rendering.\n * - Sync generator components block while their children are rendering;\n *   they only resume once their children have finished.\n * - Async generator components can block in two different ways:\n *   - By default, they behave like sync generator components, blocking while\n *     the component or its children are rendering.\n *   - Within a for await...of loop, they block only while waiting for new\n *     props to be requested, and not while children are rendering.\n */\nfunction runComponent<TNode, TResult>(\n\tctx: ContextState<TNode, unknown, TNode | undefined, TResult>,\n): [Promise<undefined> | undefined, Promise<undefined> | undefined] {\n\tif (getFlag(ctx.ret, IsUnmounted)) {\n\t\treturn [undefined, undefined];\n\t}\n\n\tconst ret = ctx.ret;\n\tconst initial = !ctx.iterator;\n\tif (initial) {\n\t\tsetFlag(ctx.ret, IsExecuting);\n\t\tclearEventListeners(ctx.ctx);\n\t\tlet returned: ReturnType<Component>;\n\t\ttry {\n\t\t\treturned = (ret.el.tag as Component).call(ctx.ctx, ret.el.props, ctx.ctx);\n\t\t} catch (err) {\n\t\t\tsetFlag(ctx.ret, IsErrored);\n\t\t\tthrow err;\n\t\t} finally {\n\t\t\tsetFlag(ctx.ret, IsExecuting, false);\n\t\t}\n\n\t\tif (isIteratorLike(returned)) {\n\t\t\tctx.iterator = returned;\n\t\t} else if (!isPromiseLike(returned)) {\n\t\t\t// sync function component\n\t\t\treturn [\n\t\t\t\tundefined,\n\t\t\t\tdiffComponentChildren<TNode, TResult>(ctx, returned, false),\n\t\t\t];\n\t\t} else {\n\t\t\t// async function component\n\t\t\tconst returned1 =\n\t\t\t\treturned instanceof Promise ? returned : Promise.resolve(returned);\n\t\t\treturn [\n\t\t\t\treturned1.catch(NOOP),\n\t\t\t\treturned1.then(\n\t\t\t\t\t(returned) =>\n\t\t\t\t\t\tdiffComponentChildren<TNode, TResult>(ctx, returned, false),\n\t\t\t\t\t(err) => {\n\t\t\t\t\t\tsetFlag(ctx.ret, IsErrored);\n\t\t\t\t\t\tthrow err;\n\t\t\t\t\t},\n\t\t\t\t),\n\t\t\t];\n\t\t}\n\t}\n\n\tlet iteration!: Promise<ChildrenIteratorResult> | ChildrenIteratorResult;\n\tif (initial) {\n\t\ttry {\n\t\t\tsetFlag(ctx.ret, IsExecuting);\n\t\t\titeration = ctx.iterator!.next();\n\t\t} catch (err) {\n\t\t\tsetFlag(ctx.ret, IsErrored);\n\t\t\tthrow err;\n\t\t} finally {\n\t\t\tsetFlag(ctx.ret, IsExecuting, false);\n\t\t}\n\n\t\tif (isPromiseLike(iteration)) {\n\t\t\tsetFlag(ctx.ret, IsAsyncGen);\n\t\t} else {\n\t\t\tsetFlag(ctx.ret, IsSyncGen);\n\t\t}\n\t}\n\n\tif (getFlag(ctx.ret, IsSyncGen)) {\n\t\t// sync generator component\n\t\tif (!initial) {\n\t\t\ttry {\n\t\t\t\tsetFlag(ctx.ret, IsExecuting);\n\t\t\t\tconst oldResult = ctx.adapter.read(getValue(ctx.ret));\n\t\t\t\titeration = ctx.iterator!.next(oldResult);\n\t\t\t} catch (err) {\n\t\t\t\tsetFlag(ctx.ret, IsErrored);\n\t\t\t\tthrow err;\n\t\t\t} finally {\n\t\t\t\tsetFlag(ctx.ret, IsExecuting, false);\n\t\t\t}\n\t\t}\n\n\t\tif (isPromiseLike(iteration)) {\n\t\t\tthrow new Error(\"Mixed generator component\");\n\t\t}\n\n\t\tif (\n\t\t\tgetFlag(ctx.ret, IsInForOfLoop) &&\n\t\t\t!getFlag(ctx.ret, NeedsToYield) &&\n\t\t\t!getFlag(ctx.ret, IsUnmounted) &&\n\t\t\t!getFlag(ctx.ret, IsSchedulingRefresh)\n\t\t) {\n\t\t\tconsole.error(\n\t\t\t\t`Component <${getTagName(ctx.ret.el.tag)}> yielded/returned more than once in for...of loop`,\n\t\t\t);\n\t\t}\n\n\t\tsetFlag(ctx.ret, NeedsToYield, false);\n\t\tsetFlag(ctx.ret, IsSchedulingRefresh, false);\n\t\tif (iteration.done) {\n\t\t\tsetFlag(ctx.ret, IsSyncGen, false);\n\t\t\tctx.iterator = undefined;\n\t\t}\n\n\t\tconst diff = diffComponentChildren<TNode, TResult>(\n\t\t\tctx,\n\t\t\titeration.value as Children,\n\t\t\t!iteration.done,\n\t\t);\n\t\tconst block = isPromiseLike(diff) ? diff.catch(NOOP) : undefined;\n\t\treturn [block, diff];\n\t} else {\n\t\tif (getFlag(ctx.ret, IsInForAwaitOfLoop)) {\n\t\t\t// initializes the async generator loop\n\t\t\tpullComponent(ctx, iteration);\n\t\t\tconst block = resumePropsAsyncIterator(ctx);\n\t\t\treturn [block, ctx.pull && ctx.pull.diff];\n\t\t} else {\n\t\t\t// We call resumePropsAsyncIterator in case the component exits the\n\t\t\t// for...of loop\n\t\t\tresumePropsAsyncIterator(ctx);\n\t\t\tif (!initial) {\n\t\t\t\ttry {\n\t\t\t\t\tsetFlag(ctx.ret, IsExecuting);\n\t\t\t\t\tconst oldResult = ctx.adapter.read(getValue(ctx.ret));\n\t\t\t\t\titeration = ctx.iterator!.next(oldResult);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tsetFlag(ctx.ret, IsErrored);\n\t\t\t\t\tthrow err;\n\t\t\t\t} finally {\n\t\t\t\t\tsetFlag(ctx.ret, IsExecuting, false);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!isPromiseLike(iteration)) {\n\t\t\t\tthrow new Error(\"Mixed generator component\");\n\t\t\t}\n\n\t\t\tconst diff = iteration.then(\n\t\t\t\t(iteration) => {\n\t\t\t\t\tif (getFlag(ctx.ret, IsInForAwaitOfLoop)) {\n\t\t\t\t\t\t// We have entered a for await...of loop, so we start pulling\n\t\t\t\t\t\tpullComponent(ctx, iteration);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tgetFlag(ctx.ret, IsInForOfLoop) &&\n\t\t\t\t\t\t\t!getFlag(ctx.ret, NeedsToYield) &&\n\t\t\t\t\t\t\t!getFlag(ctx.ret, IsUnmounted) &&\n\t\t\t\t\t\t\t!getFlag(ctx.ret, IsSchedulingRefresh)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t\t\t`Component <${getTagName(ctx.ret.el.tag)}> yielded/returned more than once in for...of loop`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tsetFlag(ctx.ret, NeedsToYield, false);\n\t\t\t\t\tsetFlag(ctx.ret, IsSchedulingRefresh, false);\n\t\t\t\t\tif (iteration.done) {\n\t\t\t\t\t\tsetFlag(ctx.ret, IsAsyncGen, false);\n\t\t\t\t\t\tctx.iterator = undefined;\n\t\t\t\t\t}\n\t\t\t\t\treturn diffComponentChildren<TNode, TResult>(\n\t\t\t\t\t\tctx,\n\t\t\t\t\t\t// Children can be void so we eliminate that here\n\t\t\t\t\t\titeration.value as Children,\n\t\t\t\t\t\t!iteration.done,\n\t\t\t\t\t);\n\t\t\t\t},\n\t\t\t\t(err) => {\n\t\t\t\t\tsetFlag(ctx.ret, IsErrored);\n\t\t\t\t\tthrow err;\n\t\t\t\t},\n\t\t\t);\n\n\t\t\treturn [diff.catch(NOOP), diff];\n\t\t}\n\t}\n}\n\n/**\n * Called to resume the props async iterator for async generator components.\n *\n * @returns {Promise<undefined> | undefined} A possible promise which\n * represents the duration during which the component is blocked.\n */\nfunction resumePropsAsyncIterator(\n\tctx: ContextState,\n): Promise<undefined> | undefined {\n\tif (ctx.onPropsProvided) {\n\t\tctx.onPropsProvided(ctx.ret.el.props);\n\t\tctx.onPropsProvided = undefined;\n\t\tsetFlag(ctx.ret, PropsAvailable, false);\n\t} else {\n\t\tsetFlag(ctx.ret, PropsAvailable);\n\t\tif (getFlag(ctx.ret, IsInForAwaitOfLoop)) {\n\t\t\treturn new Promise<undefined>(\n\t\t\t\t(resolve) => (ctx.onPropsRequested = resolve as () => unknown),\n\t\t\t);\n\t\t}\n\t}\n\n\treturn (\n\t\tctx.pull && ctx.pull.iterationP && ctx.pull.iterationP.then(NOOP, NOOP)\n\t);\n}\n\n/**\n * The logic for pulling from async generator components when they are in a for\n * await...of loop is implemented here.\n *\n * It makes sense to group this logic in a single async loop to prevent race\n * conditions caused by calling next(), throw() and return() concurrently.\n */\nasync function pullComponent<TNode, TResult>(\n\tctx: ContextState<TNode, unknown, TNode, TResult>,\n\titerationP:\n\t\t| Promise<ChildrenIteratorResult>\n\t\t| ChildrenIteratorResult\n\t\t| undefined,\n): Promise<void> {\n\tif (!iterationP || ctx.pull) {\n\t\treturn;\n\t}\n\n\tctx.pull = {iterationP: undefined, diff: undefined, onChildError: undefined};\n\n\t// TODO: replace done with iteration\n\t//let iteration: ChildrenIteratorResult | undefined;\n\tlet done = false;\n\ttry {\n\t\tlet childError: any;\n\t\twhile (!done) {\n\t\t\tif (isPromiseLike(iterationP)) {\n\t\t\t\tctx.pull.iterationP = iterationP;\n\t\t\t}\n\n\t\t\tlet onDiff!: Function;\n\t\t\tctx.pull.diff = new Promise((resolve) => (onDiff = resolve)).then(\n\t\t\t\t(): undefined => {\n\t\t\t\t\tif (\n\t\t\t\t\t\t!(getFlag(ctx.ret, IsUpdating) || getFlag(ctx.ret, IsRefreshing))\n\t\t\t\t\t) {\n\t\t\t\t\t\tcommitComponent(ctx, []);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t(err) => {\n\t\t\t\t\tif (\n\t\t\t\t\t\t!(getFlag(ctx.ret, IsUpdating) || getFlag(ctx.ret, IsRefreshing)) ||\n\t\t\t\t\t\t// TODO: is this flag necessary?\n\t\t\t\t\t\t!getFlag(ctx.ret, NeedsToYield)\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn propagateError(ctx, err, []);\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow err;\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tlet iteration: ChildrenIteratorResult;\n\t\t\ttry {\n\t\t\t\titeration = await iterationP;\n\t\t\t} catch (err) {\n\t\t\t\tdone = true;\n\t\t\t\tsetFlag(ctx.ret, IsErrored);\n\t\t\t\tsetFlag(ctx.ret, NeedsToYield, false);\n\t\t\t\tonDiff(Promise.reject(err));\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// this must be set after iterationP is awaited\n\t\t\tlet oldResult: Promise<TResult>;\n\t\t\t{\n\t\t\t\t// The 'floating' flag tracks whether the promise passed to the generator\n\t\t\t\t// is handled (via await, then, or catch). If handled, we reject the\n\t\t\t\t// promise so the user can catch errors. If not, we inject the error back\n\t\t\t\t// into the generator using throw, like for sync generator components.\n\t\t\t\tlet floating = true;\n\t\t\t\tconst oldResult1 = new Promise<TResult>((resolve, reject) => {\n\t\t\t\t\tctx.ctx.schedule(resolve);\n\t\t\t\t\tctx.pull!.onChildError = (err: any) => {\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t\tif (floating) {\n\t\t\t\t\t\t\tchildError = err;\n\t\t\t\t\t\t\tresumePropsAsyncIterator(ctx);\n\t\t\t\t\t\t\treturn ctx.pull!.diff;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t});\n\n\t\t\t\toldResult1.catch(NOOP);\n\t\t\t\t// We use Object.create() to clone the promise for float detection\n\t\t\t\t// because modern JS engines skip calling .then() on promises awaited\n\t\t\t\t// with await.\n\t\t\t\toldResult = Object.create(oldResult1);\n\t\t\t\toldResult.then = function (\n\t\t\t\t\tonfulfilled?: ((value: TResult) => any) | null,\n\t\t\t\t\tonrejected?: ((reason: any) => any) | null,\n\t\t\t\t): Promise<any> {\n\t\t\t\t\tfloating = false;\n\t\t\t\t\treturn oldResult1.then(onfulfilled, onrejected);\n\t\t\t\t};\n\n\t\t\t\toldResult.catch = function (\n\t\t\t\t\tonrejected?: ((reason: any) => any) | null,\n\t\t\t\t): Promise<any> {\n\t\t\t\t\tfloating = false;\n\t\t\t\t\treturn oldResult1.catch(onrejected);\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (childError != null) {\n\t\t\t\ttry {\n\t\t\t\t\tsetFlag(ctx.ret, IsExecuting);\n\t\t\t\t\tif (typeof ctx.iterator!.throw !== \"function\") {\n\t\t\t\t\t\tthrow childError;\n\t\t\t\t\t}\n\t\t\t\t\titeration = await ctx.iterator!.throw(childError);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tdone = true;\n\t\t\t\t\tsetFlag(ctx.ret, IsErrored);\n\t\t\t\t\tsetFlag(ctx.ret, NeedsToYield, false);\n\t\t\t\t\tonDiff(Promise.reject(err));\n\t\t\t\t\tbreak;\n\t\t\t\t} finally {\n\t\t\t\t\tchildError = undefined;\n\t\t\t\t\tsetFlag(ctx.ret, IsExecuting, false);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// this makes sure we pause before entering a loop if we yield before it\n\t\t\tif (!getFlag(ctx.ret, IsInForAwaitOfLoop)) {\n\t\t\t\tsetFlag(ctx.ret, PropsAvailable, false);\n\t\t\t}\n\n\t\t\tdone = !!iteration.done;\n\n\t\t\tlet diff: Promise<undefined> | undefined;\n\t\t\ttry {\n\t\t\t\tif (!isPromiseLike(iterationP)) {\n\t\t\t\t\t// if iterationP is an iteration and not a promise, the component was\n\t\t\t\t\t// not in a for await...of loop when the iteration started, so we can\n\t\t\t\t\t// skip the diffing of children as it is handled elsewhere.\n\t\t\t\t\tdiff = undefined;\n\t\t\t\t} else if (\n\t\t\t\t\t!getFlag(ctx.ret, NeedsToYield) &&\n\t\t\t\t\tgetFlag(ctx.ret, PropsAvailable) &&\n\t\t\t\t\tgetFlag(ctx.ret, IsInForAwaitOfLoop)\n\t\t\t\t) {\n\t\t\t\t\t// logic to skip yielded children in a stale for await of iteration.\n\t\t\t\t\tdiff = undefined;\n\t\t\t\t} else {\n\t\t\t\t\tdiff = diffComponentChildren<TNode, TResult>(\n\t\t\t\t\t\tctx,\n\t\t\t\t\t\titeration.value!,\n\t\t\t\t\t\t!iteration.done,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\tonDiff(Promise.reject(err));\n\t\t\t} finally {\n\t\t\t\tonDiff(diff);\n\t\t\t\tsetFlag(ctx.ret, NeedsToYield, false);\n\t\t\t}\n\n\t\t\tif (getFlag(ctx.ret, IsUnmounted)) {\n\t\t\t\t// TODO: move this unmounted branch outside the loop\n\t\t\t\twhile (\n\t\t\t\t\t(!iteration || !iteration.done) &&\n\t\t\t\t\tctx.iterator &&\n\t\t\t\t\tgetFlag(ctx.ret, IsInForAwaitOfLoop)\n\t\t\t\t) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tsetFlag(ctx.ret, IsExecuting);\n\t\t\t\t\t\titeration = await ctx.iterator.next(oldResult);\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tsetFlag(ctx.ret, IsErrored);\n\t\t\t\t\t\t// we throw the error here to cause an unhandled rejection because\n\t\t\t\t\t\t// the promise returned from pullComponent is never awaited\n\t\t\t\t\t\tthrow err;\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tsetFlag(ctx.ret, IsExecuting, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t(!iteration || !iteration.done) &&\n\t\t\t\t\tctx.iterator &&\n\t\t\t\t\ttypeof ctx.iterator.return === \"function\"\n\t\t\t\t) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tsetFlag(ctx.ret, IsExecuting);\n\t\t\t\t\t\tawait ctx.iterator.return();\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tsetFlag(ctx.ret, IsErrored);\n\t\t\t\t\t\tthrow err;\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tsetFlag(ctx.ret, IsExecuting, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t} else if (!getFlag(ctx.ret, IsInForAwaitOfLoop)) {\n\t\t\t\t// we have exited the for...await of, so updates will be handled by the\n\t\t\t\t// regular runComponent/enqueueComponent logic.\n\t\t\t\tbreak;\n\t\t\t} else if (!iteration.done) {\n\t\t\t\ttry {\n\t\t\t\t\tsetFlag(ctx.ret, IsExecuting);\n\t\t\t\t\titerationP = ctx.iterator!.next(\n\t\t\t\t\t\toldResult,\n\t\t\t\t\t) as Promise<ChildrenIteratorResult>;\n\t\t\t\t} finally {\n\t\t\t\t\tsetFlag(ctx.ret, IsExecuting, false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} finally {\n\t\tif (done) {\n\t\t\tsetFlag(ctx.ret, IsAsyncGen, false);\n\t\t\tctx.iterator = undefined;\n\t\t}\n\n\t\tctx.pull = undefined;\n\t}\n}\n\nfunction commitComponent<TNode>(\n\tctx: ContextState<TNode>,\n\tschedulePromises: Array<PromiseLike<unknown>>,\n\thydrationNodes?: Array<TNode> | undefined,\n): ElementValue<TNode> {\n\tif (ctx.schedule) {\n\t\tctx.schedule.promise.then(() => {\n\t\t\tcommitComponent(ctx, []);\n\t\t\tpropagateComponent(ctx);\n\t\t});\n\t\treturn getValue(ctx.ret);\n\t}\n\n\tconst values = commitChildren(\n\t\tctx.adapter,\n\t\tctx.host,\n\t\tctx,\n\t\tctx.scope,\n\t\tctx.ret,\n\t\tctx.index,\n\t\tschedulePromises,\n\t\thydrationNodes,\n\t);\n\n\tif (getFlag(ctx.ret, IsUnmounted)) {\n\t\treturn;\n\t}\n\n\taddEventTargetDelegates(ctx.ctx, values);\n\n\t// Execute schedule callbacks early to check for async deferral\n\tconst wasScheduling = getFlag(ctx.ret, IsScheduling);\n\tlet schedulePromises1: Array<PromiseLike<unknown>> | undefined;\n\tconst callbacks = scheduleMap.get(ctx);\n\tif (callbacks) {\n\t\tscheduleMap.delete(ctx);\n\t\tsetFlag(ctx.ret, IsScheduling);\n\t\tconst result = ctx.adapter.read(unwrap(values));\n\t\tfor (const callback of callbacks) {\n\t\t\tconst scheduleResult = callback(result);\n\t\t\tif (isPromiseLike(scheduleResult)) {\n\t\t\t\t(schedulePromises1 = schedulePromises1 || []).push(scheduleResult);\n\t\t\t}\n\t\t}\n\n\t\tif (schedulePromises1 && !getFlag(ctx.ret, DidCommit)) {\n\t\t\tconst scheduleCallbacksP = Promise.all(schedulePromises1).then(() => {\n\t\t\t\tsetFlag(ctx.ret, IsScheduling, wasScheduling);\n\t\t\t\tpropagateComponent(ctx);\n\t\t\t\tif (ctx.ret.fallback) {\n\t\t\t\t\tunmount(ctx.adapter, ctx.host, ctx.parent, ctx.ret.fallback, false);\n\t\t\t\t}\n\n\t\t\t\tctx.ret.fallback = undefined;\n\t\t\t});\n\n\t\t\tlet onAbort!: () => void;\n\t\t\tconst scheduleP = safeRace([\n\t\t\t\tscheduleCallbacksP,\n\t\t\t\tnew Promise<void>((resolve) => (onAbort = resolve)),\n\t\t\t]).finally(() => {\n\t\t\t\tctx.schedule = undefined;\n\t\t\t});\n\n\t\t\tctx.schedule = {promise: scheduleP, onAbort};\n\t\t\tschedulePromises.push(scheduleP);\n\t\t} else {\n\t\t\tsetFlag(ctx.ret, IsScheduling, wasScheduling);\n\t\t}\n\t} else {\n\t\tsetFlag(ctx.ret, IsScheduling, wasScheduling);\n\t}\n\n\tif (!getFlag(ctx.ret, IsScheduling)) {\n\t\tif (!getFlag(ctx.ret, IsUpdating)) {\n\t\t\tpropagateComponent(ctx);\n\t\t}\n\n\t\tif (ctx.ret.fallback) {\n\t\t\tunmount(ctx.adapter, ctx.host, ctx.parent, ctx.ret.fallback, false);\n\t\t}\n\n\t\tctx.ret.fallback = undefined;\n\t\tsetFlag(ctx.ret, IsUpdating, false);\n\t}\n\n\tsetFlag(ctx.ret, DidCommit);\n\t// We always use getValue() instead of the unwrapping values because there\n\t// are various ways in which the values could have been updated, especially\n\t// if schedule callbacks call refresh() or async mounting is happening.\n\treturn getValue(ctx.ret, true);\n}\n\n/**\n * Checks if a target retainer is active (contributing) in the host's retainer tree.\n * Performs a downward traversal from host to find if target is in the active path.\n */\nfunction isRetainerActive<TNode>(\n\ttarget: Retainer<TNode>,\n\thost: Retainer<TNode>,\n): boolean {\n\tconst stack: Retainer<TNode>[] = [host];\n\n\twhile (stack.length > 0) {\n\t\tconst current = stack.pop()!;\n\n\t\tif (current === target) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Add direct children to stack (skip if this is a host boundary)\n\t\t// Host boundaries are: DOM elements (string tags) or Portal, but NOT Fragment\n\t\tconst isHostBoundary =\n\t\t\tcurrent !== host &&\n\t\t\t((typeof current.el.tag === \"string\" && current.el.tag !== Fragment) ||\n\t\t\t\tcurrent.el.tag === Portal);\n\t\tif (current.children && !isHostBoundary) {\n\t\t\tconst children = wrap(current.children);\n\t\t\tfor (const child of children) {\n\t\t\t\tif (child) {\n\t\t\t\t\tstack.push(child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add fallback chains (only if current retainer is using fallback)\n\t\tif (current.fallback && !getFlag(current, DidDiff)) {\n\t\t\tstack.push(current.fallback);\n\t\t}\n\t}\n\n\treturn false;\n}\n\n/**\n * Propagates component changes up to ancestors when rendering starts from a\n * component via refresh() or multiple for await...of renders. This handles\n * event listeners and DOM arrangement that would normally happen during\n * top-down rendering.\n */\nfunction propagateComponent<TNode>(ctx: ContextState<TNode>): void {\n\tconst values = getChildValues(ctx.ret, ctx.index);\n\taddEventTargetDelegates(\n\t\tctx.ctx,\n\t\tvalues,\n\t\t(ctx1) => ctx1[_ContextState].host === ctx.host,\n\t);\n\tconst host = ctx.host;\n\tconst initiator = ctx.ret;\n\n\t// Check if initiator is active in the host's tree\n\tif (!isRetainerActive(initiator, host)) {\n\t\treturn;\n\t}\n\n\tconst props = stripSpecialProps(host.el.props);\n\tconst hostChildren = getChildValues(host, 0);\n\n\tctx.adapter.arrange({\n\t\ttag: host.el.tag as string | symbol,\n\t\ttagName: getTagName(host.el.tag),\n\t\tnode: host.value as TNode,\n\t\tprops,\n\t\toldProps: props,\n\t\tchildren: hostChildren,\n\t});\n\n\tflush(ctx.adapter, ctx.root, ctx);\n}\n\nasync function unmountComponent(\n\tctx: ContextState,\n\tisNested: boolean,\n): Promise<undefined> {\n\tif (getFlag(ctx.ret, IsUnmounted)) {\n\t\treturn;\n\t}\n\n\tlet cleanupPromises: Array<PromiseLike<unknown>> | undefined;\n\t// TODO: think about errror handling for callbacks\n\tconst callbacks = cleanupMap.get(ctx);\n\tif (callbacks) {\n\t\tconst oldResult = ctx.adapter.read(getValue(ctx.ret));\n\t\tcleanupMap.delete(ctx);\n\t\tfor (const callback of callbacks) {\n\t\t\tconst cleanup = callback(oldResult);\n\t\t\tif (isPromiseLike(cleanup)) {\n\t\t\t\t(cleanupPromises = cleanupPromises || []).push(cleanup);\n\t\t\t}\n\t\t}\n\t}\n\n\tlet didLinger = false;\n\tif (!isNested && cleanupPromises && getChildValues(ctx.ret).length > 0) {\n\t\tdidLinger = true;\n\t\tconst index = ctx.index;\n\t\tconst lingerers = ctx.host.lingerers || (ctx.host.lingerers = []);\n\t\tlet set = lingerers[index];\n\t\tif (set == null) {\n\t\t\tset = new Set<Retainer<unknown>>();\n\t\t\tlingerers[index] = set;\n\t\t}\n\n\t\tset.add(ctx.ret);\n\t\tawait Promise.all(cleanupPromises);\n\t\tset!.delete(ctx.ret);\n\t\tif (set!.size === 0) {\n\t\t\tlingerers[index] = undefined;\n\t\t}\n\n\t\tif (!lingerers.some(Boolean)) {\n\t\t\t// If there are no lingerers remaining, we can remove the lingerers array\n\t\t\tctx.host.lingerers = undefined;\n\t\t}\n\t}\n\n\tif (getFlag(ctx.ret, IsUnmounted)) {\n\t\t// If the component was unmounted while awaiting the cleanup callbacks,\n\t\t// we do not need to continue unmounting.\n\t\treturn;\n\t}\n\n\tsetFlag(ctx.ret, IsUnmounted);\n\n\t// If component has pending schedule promises, resolve them since component\n\t// is unmounting\n\tif (ctx.schedule) {\n\t\tctx.schedule.onAbort();\n\t\tctx.schedule = undefined;\n\t}\n\n\tclearEventListeners(ctx.ctx);\n\tunmountChildren(ctx.adapter, ctx.host, ctx, ctx.ret, isNested);\n\tif (didLinger) {\n\t\t// If we lingered, we call finalize to ensure rendering is finalized\n\t\tif (ctx.root != null) {\n\t\t\tctx.adapter.finalize(ctx.root);\n\t\t}\n\t}\n\n\tif (ctx.iterator) {\n\t\tif (ctx.pull) {\n\t\t\t// we let pullComponent handle unmounting\n\t\t\tresumePropsAsyncIterator(ctx);\n\t\t\treturn;\n\t\t}\n\n\t\t// we wait for inflight value so yields resume with the most up to date\n\t\t// props\n\t\tif (ctx.inflight) {\n\t\t\tawait ctx.inflight[1];\n\t\t}\n\n\t\tlet iteration: ChildrenIteratorResult | undefined;\n\t\tif (getFlag(ctx.ret, IsInForOfLoop)) {\n\t\t\ttry {\n\t\t\t\tsetFlag(ctx.ret, IsExecuting);\n\t\t\t\tconst oldResult = ctx.adapter.read(getValue(ctx.ret));\n\t\t\t\tconst iterationP = ctx.iterator!.next(oldResult);\n\t\t\t\tif (isPromiseLike(iterationP)) {\n\t\t\t\t\tif (!getFlag(ctx.ret, IsAsyncGen)) {\n\t\t\t\t\t\tthrow new Error(\"Mixed generator component\");\n\t\t\t\t\t}\n\n\t\t\t\t\titeration = await iterationP;\n\t\t\t\t} else {\n\t\t\t\t\tif (!getFlag(ctx.ret, IsSyncGen)) {\n\t\t\t\t\t\tthrow new Error(\"Mixed generator component\");\n\t\t\t\t\t}\n\n\t\t\t\t\titeration = iterationP;\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\tsetFlag(ctx.ret, IsErrored);\n\t\t\t\tthrow err;\n\t\t\t} finally {\n\t\t\t\tsetFlag(ctx.ret, IsExecuting, false);\n\t\t\t}\n\t\t}\n\n\t\tif (\n\t\t\t(!iteration || !iteration.done) &&\n\t\t\tctx.iterator &&\n\t\t\ttypeof ctx.iterator.return === \"function\"\n\t\t) {\n\t\t\ttry {\n\t\t\t\tsetFlag(ctx.ret, IsExecuting);\n\t\t\t\tconst iterationP = ctx.iterator.return();\n\t\t\t\tif (isPromiseLike(iterationP)) {\n\t\t\t\t\tif (!getFlag(ctx.ret, IsAsyncGen)) {\n\t\t\t\t\t\tthrow new Error(\"Mixed generator component\");\n\t\t\t\t\t}\n\n\t\t\t\t\titeration = await iterationP;\n\t\t\t\t} else {\n\t\t\t\t\tif (!getFlag(ctx.ret, IsSyncGen)) {\n\t\t\t\t\t\tthrow new Error(\"Mixed generator component\");\n\t\t\t\t\t}\n\n\t\t\t\t\titeration = iterationP;\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\tsetFlag(ctx.ret, IsErrored);\n\t\t\t\tthrow err;\n\t\t\t} finally {\n\t\t\t\tsetFlag(ctx.ret, IsExecuting, false);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*** ERROR HANDLING UTILITIES ***/\nfunction handleChildError<TNode>(\n\tctx: ContextState<TNode, unknown, TNode>,\n\terr: unknown,\n): Promise<undefined> | undefined {\n\tif (!ctx.iterator) {\n\t\tthrow err;\n\t}\n\n\tif (ctx.pull) {\n\t\t// we let pullComponent handle child errors\n\t\tctx.pull.onChildError!(err);\n\t\treturn ctx.pull.diff;\n\t}\n\n\tif (!ctx.iterator.throw) {\n\t\tthrow err;\n\t}\n\n\tresumePropsAsyncIterator(ctx);\n\tlet iteration: ChildrenIteratorResult | Promise<ChildrenIteratorResult>;\n\ttry {\n\t\tsetFlag(ctx.ret, IsExecuting);\n\t\titeration = ctx.iterator.throw(err);\n\t} catch (err) {\n\t\tsetFlag(ctx.ret, IsErrored);\n\t\tthrow err;\n\t} finally {\n\t\tsetFlag(ctx.ret, IsExecuting, false);\n\t}\n\n\tif (isPromiseLike(iteration)) {\n\t\treturn iteration.then(\n\t\t\t(iteration) => {\n\t\t\t\tif (iteration.done) {\n\t\t\t\t\tsetFlag(ctx.ret, IsSyncGen, false);\n\t\t\t\t\tsetFlag(ctx.ret, IsAsyncGen, false);\n\t\t\t\t\tctx.iterator = undefined;\n\t\t\t\t}\n\n\t\t\t\treturn diffComponentChildren(\n\t\t\t\t\tctx,\n\t\t\t\t\titeration.value as Children,\n\t\t\t\t\t!iteration.done,\n\t\t\t\t);\n\t\t\t},\n\t\t\t(err) => {\n\t\t\t\tsetFlag(ctx.ret, IsErrored);\n\t\t\t\tthrow err;\n\t\t\t},\n\t\t);\n\t}\n\n\tif (iteration.done) {\n\t\tsetFlag(ctx.ret, IsSyncGen, false);\n\t\tsetFlag(ctx.ret, IsAsyncGen, false);\n\t\tctx.iterator = undefined;\n\t}\n\n\treturn diffComponentChildren(\n\t\tctx,\n\t\titeration.value as Children,\n\t\t!iteration.done,\n\t);\n}\n\n/**\n * Propagates an error up the context tree by calling handleChildError with\n * each parent.\n *\n * @returns A promise which resolves to undefined when the error has been\n * handled, or undefined if the error was handled synchronously.\n */\nfunction propagateError<TNode>(\n\tctx: ContextState<TNode>,\n\terr: unknown,\n\tschedulePromises: Array<PromiseLike<unknown>>,\n): Promise<undefined> | undefined {\n\tconst parent = ctx.parent;\n\tif (!parent) {\n\t\tthrow err;\n\t}\n\n\tlet diff: Promise<undefined> | undefined;\n\ttry {\n\t\tdiff = handleChildError(parent, err);\n\t} catch (err) {\n\t\treturn propagateError(parent, err, schedulePromises);\n\t}\n\n\tif (isPromiseLike(diff)) {\n\t\treturn diff.then(\n\t\t\t() => void commitComponent(parent, schedulePromises),\n\t\t\t(err) => propagateError(parent, err, schedulePromises),\n\t\t);\n\t}\n\n\tcommitComponent(parent, schedulePromises);\n}\n\n/**\n * An interface which can be extended to provide strongly typed provisions.\n * See Context.prototype.consume and Context.prototype.provide.\n */\nexport interface ProvisionMap extends Crank.ProvisionMap {}\n\nexport interface EventMap extends Crank.EventMap {}\n\ntype MappedEventListener<T extends string> = (ev: Crank.EventMap[T]) => unknown;\n\ntype MappedEventListenerOrEventListenerObject<T extends string> =\n\t| MappedEventListener<T>\n\t| {handleEvent: MappedEventListener<T>};\n\nexport interface Context extends Crank.Context {\n\taddEventListener<T extends string>(\n\t\ttype: T,\n\t\tlistener: MappedEventListenerOrEventListenerObject<T> | null,\n\t\toptions?: boolean | AddEventListenerOptions,\n\t): void;\n\n\tremoveEventListener<T extends string>(\n\t\ttype: T,\n\t\tlistener: MappedEventListenerOrEventListenerObject<T> | null,\n\t\toptions?: EventListenerOptions | boolean,\n\t): void;\n\n\tdispatchEvent<T extends string>(ev: EventMap[T] | Event): boolean;\n}\n\n// TODO: uncomment and use in the Element interface below\n// type CrankElement = Element;\ndeclare global {\n\tnamespace Crank {\n\t\texport interface EventMap {\n\t\t\t[tag: string]: Event;\n\t\t}\n\n\t\texport interface ProvisionMap {}\n\n\t\texport interface Context {}\n\t}\n\n\tnamespace JSX {\n\t\t// TODO: JSX Element type (the result of JSX expressions) don't work\n\t\t// because TypeScript demands that all Components return JSX elements for\n\t\t// some reason.\n\t\t// interface Element extends CrankElement {}\n\n\t\texport interface IntrinsicElements {\n\t\t\t[tag: string]: any;\n\t\t}\n\n\t\texport interface IntrinsicAttributes {\n\t\t\tchildren?: unknown;\n\t\t\tkey?: unknown;\n\t\t\tref?: unknown;\n\t\t\tcopy?: unknown;\n\t\t\thydrate?: unknown;\n\t\t}\n\n\t\texport interface ElementChildrenAttribute {\n\t\t\tchildren: {};\n\t\t}\n\t}\n}\n\n/**\n * A re-export of some Crank exports as the default export.\n *\n * Some JSX tools expect things like createElement/Fragment to be defined on\n * the default export. Prefer using the named exports directly.\n */\nexport default {createElement, Fragment};\n"],
  "mappings": "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",
  "names": ["e", "fill", "compare", "i", "byteLength", "record", "i", "ret", "result", "diff", "returned", "iteration", "err"]
}
